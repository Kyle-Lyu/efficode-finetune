{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    \"\"\"\n    Finds the shared elements from the given two lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A list containing the shared elements.\n\n    \"\"\"\n    return list(set(list1) & set(list2))\n\n# Test the function\nassert set(similar_elements((3, 4, 5, 6), (5, 7, 4, 10))) == set((4, 5))"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(num):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if num < 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\n# Test the function\nassert is_not_prime(2) == False"}
{"task_id": "Mbpp/4", "solution": "import heapq\n\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    numbers (list): A list of numbers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers, in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)\n\n# Test the function\nassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check whether the two numbers differ at one bit position only.\n\n    Parameters:\n    num1 (int): The first number.\n    num2 (int): The second number.\n\n    Returns:\n    bool: True if the numbers differ at one bit position, False otherwise.\n    \"\"\"\n    # XOR the two numbers to find the positions where they differ\n    xor_result = num1 ^ num2\n\n    # Count the number of set bits (1s) in the XOR result\n    count = 0\n    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1\n\n    # Return True if there is exactly one set bit, indicating a difference at one bit position\n    return count == 1\n\n# Test the function\nassert differ_At_One_Bit_Pos(13, 9) == True"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(string):\n    \"\"\"\n    Find all words which are at least 4 characters long in a given string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    list: A list of words that are at least 4 characters long.\n    \"\"\"\n    words = string.split()\n    char_long_words = [word for word in words if len(word) >= 4]\n    return char_long_words\n\n# Test the function\nassert set(find_char_long('Please move back to stream')) == set(['Please', 'move', 'back', 'stream'])"}
{"task_id": "Mbpp/8", "solution": "def square_nums(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list with the squares of each number.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    list: A new list with the squares of each number.\n    \"\"\"\n    return [num ** 2 for num in numbers]\n\n# Test the function\nassert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "Mbpp/9", "solution": "def find_Rotations(string):\n    \"\"\"\n    Finds the minimum number of rotations required to get the same string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n\n    Raises:\n    TypeError: If the input is not a string.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcde\")\n    5\n    >>> find_Rotations(\"\")\n    0\n    \"\"\"\n\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n\n    if len(string) <= 1:\n        return 0\n\n    rotations = 1\n    while string != string[1:] + string[0]:\n        string = string[1:] + string[0]\n        rotations += 1\n\n    return rotations"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from a string.\n\n    Parameters:\n    string (str): The input string.\n    char (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    if char in string:\n        first_index = string.find(char)\n        last_index = string.rfind(char)\n        if first_index != last_index:\n            return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n        else:\n            return string[:first_index] + string[first_index+1:]\n    else:\n        return string\n\n# Test the function\nassert remove_Occ(\"hello\", \"l\") == \"heo\""}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list): A 2D matrix.\n\n    Returns:\n    list: The sorted matrix.\n\n    \"\"\"\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix\n\n# Test the function\nassert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base (float): The base of the triangular prism.\n    height (float): The height of the triangular prism.\n    length (float): The length of the triangular prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n\n    Raises:\n    ValueError: If any of the input parameters are negative or zero.\n\n    Examples:\n    >>> find_Volume(10, 8, 6)\n    240.0\n    >>> find_Volume(0, 5, 7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input parameters cannot be negative or zero.\n    \"\"\"\n\n    if base <= 0 or height <= 0 or length <= 0:\n        raise ValueError(\"Input parameters cannot be negative or zero.\")\n\n    volume = (1/2) * base * height * length\n    return volume"}
{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(input_string):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Parameters:\n    input_string (str): The input string to be checked.\n\n    Returns:\n    bool: True if the string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    # Split the input string into words\n    words = input_string.split(\"_\")\n\n    # Check if each word consists only of lowercase letters\n    for word in words:\n        if not word.islower():\n            return False\n\n    return True\n\n# Test the function\nassert text_lowercase_underscore(\"aab_cbbbc\") == True"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n\n    Parameters:\n    side_length (int or float): The length of the side of the square.\n\n    Returns:\n    int or float: The perimeter of the square.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> square_perimeter(10)\n    40\n    >>> square_perimeter(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 4 * side_length\n\n# Test the function\nassert square_perimeter(10) == 40"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(string1, string2):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Args:\n    string1 (str): The first string.\n    string2 (str): The second string.\n\n    Returns:\n    str: The modified string with characters removed.\n    \"\"\"\n    clean_string = ''.join([char for char in string1 if char not in string2])\n    return clean_string\n\n# Test the function\nassert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): The input array of integers.\n\n    Returns:\n    bool: True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))\n\n# Test cases\nassert test_duplicate([1, 2, 3, 4, 5]) == False\nassert test_duplicate([1, 2, 2, 3, 4]) == True\nassert test_duplicate([1, 1, 1, 1, 1]) == True"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(num):\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is a Woodall number, False otherwise.\n    \"\"\"\n    factor = 1\n    while factor < num:\n        if num % factor == 0:\n            num //= factor\n        else:\n            return False\n        factor *= 2\n    return True\n\n# Test the function\nassert is_woodall(383) == True"}
{"task_id": "Mbpp/56", "solution": "def check(num):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    def reverse_number(n):\n        \"\"\"\n        Reverse a given number.\n\n        Parameters:\n        n (int): The number to be reversed.\n\n        Returns:\n        int: The reversed number.\n        \"\"\"\n        return int(str(n)[::-1])\n\n    return num == (2 * reverse_number(num)) - 1\n\n# Test cases\nassert check(70) == False"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    \"\"\"\n    Finds the largest number that can be formed with the given list of digits.\n\n    Parameters:\n    digits (list): A list of integers representing the digits.\n\n    Returns:\n    int: The largest number that can be formed with the given digits.\n\n    Examples:\n    >>> find_Max_Num([1, 2, 3])\n    321\n    >>> find_Max_Num([4, 2, 9, 7])\n    9742\n    >>> find_Max_Num([5, 5, 5])\n    555\n    \"\"\"\n\n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n\n    # Convert the sorted digits to a string and return as an integer\n    return int(''.join(map(str, sorted_digits)))\n\n# Test the function\nassert find_Max_Num([1, 2, 3]) == 321\nassert find_Max_Num([4, 2, 9, 7]) == 9742\nassert find_Max_Num([5, 5, 5]) == 555"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(num1, num2):\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    bool: True if the two integers have opposite signs, False otherwise.\n    \"\"\"\n    return (num1 ^ num2) < 0\n\n# Test the function\nassert opposite_Signs(1, -2) == True"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    Function to find the nth octagonal number.\n\n    Parameters:\n    n (int): The index of the octagonal number to find.\n\n    Returns:\n    int: The nth octagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> is_octagonal(5)\n    65\n    >>> is_octagonal(0)\n    0\n    >>> is_octagonal(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (3 * n - 2)\n\n# Testing the function\nassert is_octagonal(5) == 65"}
{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count\n\n# Test the function\nassert count_Substrings('112112') == 6"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list of numbers.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> smallest_num([10, 20, 1, 45, 99])\n    1\n    >>> smallest_num([])\n    Traceback (most recent call last):\n        ...\n    ValueError: List is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List is empty.\")\n    return min(numbers)"}
{"task_id": "Mbpp/63", "solution": "def max_difference(tuple_list):\n    \"\"\"\n    Finds the maximum difference between available pairs in the given tuple list.\n\n    Args:\n    tuple_list (list): A list of tuples.\n\n    Returns:\n    int: The maximum difference between available pairs.\n\n    Raises:\n    ValueError: If the tuple_list is empty.\n\n    Examples:\n    >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n    7\n    >>> max_difference([])\n    Traceback (most recent call last):\n    ...\n    ValueError: The tuple_list cannot be empty.\n    \"\"\"\n    if not tuple_list:\n        raise ValueError(\"The tuple_list cannot be empty.\")\n\n    max_diff = float('-inf')\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            diff = abs(tuple_list[i][0] - tuple_list[j][1])\n            max_diff = max(max_diff, diff)\n\n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def subject_marks(marks):\n    return sorted(marks, key=lambda x: x[1])\n\n# Test the function\nassert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    \"\"\"\n    Recursively flattens a list and sums all of its elements.\n\n    Parameters:\n    lst (list): The list to be flattened and summed.\n\n    Returns:\n    int: The sum of all elements in the flattened list.\n\n    \"\"\"\n    def flatten(lst):\n        \"\"\"\n        Recursively flattens a list.\n\n        Parameters:\n        lst (list): The list to be flattened.\n\n        Returns:\n        list: The flattened list.\n\n        \"\"\"\n        result = []\n        for item in lst:\n            if isinstance(item, list):\n                result.extend(flatten(item))\n            else:\n                result.append(item)\n        return result\n\n    flattened_list = flatten(lst)\n    return sum(flattened_list)\n\n# Test the function\nassert recursive_list_sum([1, 2, [3,4],[5,6]]) == 21"}
{"task_id": "Mbpp/66", "solution": "def pos_count(lst):\n    \"\"\"\n    Counts the number of positive numbers in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The number of positive numbers in the list.\n    \"\"\"\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n\n# Test the function\nassert pos_count([1,-2,3,-4]) == 2"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Function to find the number of ways to partition a set of Bell numbers.\n\n    Parameters:\n    n (int): The number of Bell numbers to partition.\n\n    Returns:\n    int: The number of ways to partition the set of Bell numbers.\n\n    \"\"\"\n\n    def partition(n, k):\n        if n == 0:\n            return 1\n        if k == 0:\n            return 0\n        return partition(n - 1, k) + k * partition(n, k - 1)\n\n    return partition(n, n)\n\n# Test the function\nassert bell_number(2) == 2"}
{"task_id": "Mbpp/68", "solution": "def is_monotonic(arr):\n    \"\"\"\n    Check whether the given array is monotonic or not.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    increasing = decreasing = True\n\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n\n    return increasing or decreasing\n\n# Test cases\nassert is_monotonic([6, 5, 4, 4]) == True\nassert is_monotonic([1, 2, 3, 4]) == True\nassert is_monotonic([4, 3, 2, 1]) == True\nassert is_monotonic([1, 2, 1, 4]) == False\nassert is_monotonic([1, 3, 2, 4]) == False"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(lst, sublist):\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n\n    Parameters:\n    lst (list): The main list to check.\n    sublist (list): The sublist to find.\n\n    Returns:\n    bool: True if the sublist is found in the list, False otherwise.\n    \"\"\"\n    if len(sublist) > len(lst):\n        return False\n\n    for i in range(len(lst) - len(sublist) + 1):\n        if lst[i:i+len(sublist)] == sublist:\n            return True\n\n    return False\n\n# Test cases\nassert is_sublist([2,4,3,5,7],[3,7])==False"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    \"\"\"\n    Check if all the given tuples have equal length.\n\n    Parameters:\n    tuples (list): A list of tuples.\n\n    Returns:\n    bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    lengths = set(len(t) for t in tuples)\n    return len(lengths) <= 1\n\n# Test the function\nassert get_equal([(11, 22, 33), (44, 55, 66)]) == True"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(lst):\n    \"\"\"\n    Sorts a list of elements using the Comb Sort algorithm.\n\n    Parameters:\n    lst (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n\n    Examples:\n    >>> comb_sort([5, 15, 37, 25, 79])\n    [5, 15, 25, 37, 79]\n    \"\"\"\n\n    def get_next_gap(gap):\n        # Shrink gap by a factor of 1.3\n        gap = (gap * 10) // 13\n        if gap < 1:\n            return 1\n        return gap\n\n    n = len(lst)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n\n        for i in range(0, n - gap):\n            if lst[i] > lst[i + gap]:\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                swapped = True\n\n    return lst"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(num):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    for i in range(num):\n        for j in range(num):\n            if i**2 - j**2 == num:\n                return True\n    return False\n\n# Test the function\nassert dif_Square(5) == True"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(patterns, sequence):\n    \"\"\"\n    Check whether the sequence follows the patterns given in the patterns array.\n\n    Args:\n    patterns (list): A list of patterns.\n    sequence (list): A list of elements.\n\n    Returns:\n    bool: True if the sequence follows the patterns, False otherwise.\n    \"\"\"\n    if len(patterns) != len(sequence):\n        return False\n\n    pattern_map = {}\n    for i in range(len(patterns)):\n        if patterns[i] in pattern_map:\n            if pattern_map[patterns[i]] != sequence[i]:\n                return False\n        else:\n            pattern_map[patterns[i]] = sequence[i]\n\n    return True\n\n# Test cases\nassert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True\nassert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"c\"])==False\nassert is_samepatterns([\"red\",\"green\"], [\"a\", \"b\", \"c\"])==False"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuples (list): A list of tuples.\n    k (int): The divisor.\n\n    Returns:\n    list: A list of tuples that have all elements divisible by k.\n    \"\"\"\n    result = []\n    for tuple in tuples:\n        if all(element % k == 0 for element in tuple):\n            result.append(tuple)\n    return result\n\n# Test the function\nassert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]"}
{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(num):\n    \"\"\"\n    Check if a number is divisible by 11.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    # Convert the number to a string to access its digits\n    num_str = str(num)\n\n    # Initialize the sum of odd-positioned digits and the sum of even-positioned digits\n    odd_sum = 0\n    even_sum = 0\n\n    # Iterate through the digits and calculate the sums\n    for i in range(len(num_str)):\n        if i % 2 == 0:\n            even_sum += int(num_str[i])\n        else:\n            odd_sum += int(num_str[i])\n\n    # Check if the difference between the sums is divisible by 11\n    return (odd_sum - even_sum) % 11 == 0\n\n# Test the function\nassert is_divisible_by_11(12345) == False"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    Check whether the length of the word is odd or not.\n\n    Parameters:\n    word (str): The word to check.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0\n\n# Test cases\nassert word_len(\"Hadoop\") == False"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    The nth tetrahedral number is the sum of the first n natural numbers,\n    where n is a positive integer.\n\n    Parameters:\n    n (int): The value of n.\n\n    Returns:\n    int: The nth tetrahedral number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> tetrahedral_number(5)\n    35\n    >>> tetrahedral_number(0)\n    0\n    >>> tetrahedral_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (n + 1) * (n + 2) // 6\n\n# Test the function\nassert tetrahedral_number(5) == 35"}
{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume\n\n# Test the function\nassert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)"}
{"task_id": "Mbpp/84", "solution": "def newman_conway(n):\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n\n    Parameters:\n    n (int): The index of the number to find in the sequence.\n\n    Returns:\n    int: The nth number in the Newman-Conway sequence.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be at least 1\")\n\n    sequence = [0, 1, 1]  # Initialize the sequence with the first two numbers\n\n    for i in range(3, n + 1):\n        sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n\n    return sequence[n]\n\n# Test the function\nassert newman_conway(10) == 6"}
{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative\")\n\n    return 4 * math.pi * radius**2\n\n# Test the function\nassert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Find the nth centered hexagonal number.\n\n    Parameters:\n    n (int): The index of the centered hexagonal number to find.\n\n    Returns:\n    int: The nth centered hexagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> centered_hexagonal_number(10)\n    271\n    >>> centered_hexagonal_number(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (2 * n - 1)\n\n# Test the function\nassert centered_hexagonal_number(10) == 271"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    \n    # Merge dict1 and dict2\n    merged_dict.update(dict1)\n    merged_dict.update(dict2)\n    \n    # Merge dict3 into merged_dict\n    merged_dict.update(dict3)\n    \n    return merged_dict\n\n# Test the function\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict\n\n# Test the function\nassert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    Finds the closest smaller number than n.\n\n    Parameters:\n    n (int): The number to find the closest smaller number for.\n\n    Returns:\n    int: The closest smaller number than n.\n\n    Raises:\n    ValueError: If n is less than or equal to 0.\n\n    Examples:\n    >>> closest_num(11)\n    10\n    >>> closest_num(10)\n    9\n    >>> closest_num(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be greater than 0.\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0.\")\n\n    return n - 1\n\n# Testing the function\nassert closest_num(11) == 10\nassert closest_num(10) == 9\nassert closest_num(0) == 0  # This will raise a ValueError"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Parameters:\n    words (list): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n\n    Raises:\n    TypeError: If the input is not a list.\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> len_log([\"python\",\"PHP\",\"bigdata\"])\n    7\n    >>> len_log([])\n    Traceback (most recent call last):\n    ...\n    ValueError: List is empty.\n    >>> len_log(\"invalid input\")\n    Traceback (most recent call last):\n    ...\n    TypeError: Input must be a list.\n    \"\"\"\n\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if len(words) == 0:\n        raise ValueError(\"List is empty.\")\n\n    longest_len = 0\n    for word in words:\n        longest_len = max(longest_len, len(word))\n\n    return longest_len"}
{"task_id": "Mbpp/91", "solution": "def find_substring(lst, substring):\n    \"\"\"\n    Check if a string is present as a substring in a given list of string values.\n\n    Parameters:\n    lst (list): A list of string values.\n    substring (str): The substring to check for.\n\n    Returns:\n    bool: True if the substring is found, False otherwise.\n    \"\"\"\n    for string in lst:\n        if substring in string:\n            return True\n    return False\n\n# Test the function\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"], \"ack\") == True"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(num):\n    \"\"\"\n    Check whether the given number is undulating or not.\n\n    An undulating number is a number that contains three or more consecutive identical digits.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    num_str = str(num)\n    for i in range(len(num_str) - 2):\n        if num_str[i] == num_str[i+1] and num_str[i+1] == num_str[i+2]:\n            return True\n    return False\n\n# Test the function\nassert is_undulating(1212121) == True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Parameters:\n    a (int or float): The base number.\n    b (int): The exponent.\n\n    Returns:\n    int or float: The value of 'a' raised to the power 'b'.\n    \"\"\"\n    return a ** b\n\n# Test the function\nassert power(3, 4) == 81"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n    lst (list): A list of tuples.\n\n    Returns:\n    str: The first value of the tuple with the smallest second value.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n\n    min_value = min(lst, key=lambda x: x[1])\n    return min_value[0]"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(lst):\n    \"\"\"\n    Finds the length of the smallest list in a list of lists.\n\n    Parameters:\n    lst (list): A list of lists.\n\n    Returns:\n    int: The length of the smallest list.\n\n    Raises:\n    ValueError: If the input is not a list of lists.\n\n    Examples:\n    >>> Find_Min_Length([[1],[1,2]])\n    1\n    >>> Find_Min_Length([[1,2,3],[4,5],[6]])\n    1\n    >>> Find_Min_Length([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input is not a list of lists.\n    \"\"\"\n\n    if not isinstance(lst, list) or not all(isinstance(sublist, list) for sublist in lst):\n        raise ValueError(\"Input is not a list of lists.\")\n\n    if not lst:\n        return 0\n\n    min_length = min(len(sublist) for sublist in lst)\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    \"\"\"\n    This function takes an integer n as input and returns the number of divisors of n.\n\n    Parameters:\n    n (int): The integer for which the number of divisors is to be found.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n\n# Test the function\nassert divisor(15) == 4"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(flat_list):\n    frequency_dict = {}\n    for sublist in flat_list:\n        for element in sublist:\n            frequency_dict[element] = frequency_dict.get(element, 0) + 1\n    return frequency_dict\n\n# Test the function\nassert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}"}
{"task_id": "Mbpp/98", "solution": "import math\n\ndef multiply_num(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n\n# Test the function\nassert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(decimal):\n    if decimal == 0:\n        return '0'\n\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n\n    return binary\n\n# Test cases\nassert decimal_to_binary(8) == '1000'"}
{"task_id": "Mbpp/100", "solution": "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef next_smallest_palindrome(n):\n    while True:\n        n += 1\n        if is_palindrome(n):\n            return n\n\n# Test the function\nassert next_smallest_palindrome(99) == 101"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The index of the element to find.\n\n    Returns:\n    int: The kth element in the array.\n\n    Raises:\n    ValueError: If the k is not a valid index in the array.\n\n    Examples:\n    >>> kth_element([12,3,5,7,19], 2)\n    3\n    >>> kth_element([12,3,5,7,19], 5)\n    19\n    >>> kth_element([12,3,5,7,19], 1)\n    12\n    >>> kth_element([12,3,5,7,19], 6)\n    Traceback (most recent call last):\n        ...\n    ValueError: k is not a valid index in the array\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k is not a valid index in the array\")\n    return sorted(arr)[k-1]"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    \"\"\"\n    Convert a snake case string to camel case string.\n\n    Parameters:\n    snake_str (str): The snake case string to be converted.\n\n    Returns:\n    str: The camel case string.\n\n    Examples:\n    >>> snake_to_camel('python_program')\n    'PythonProgram'\n    \"\"\"\n    words = snake_str.split('_')\n    return ''.join(word.capitalize() for word in words)\n\n# Test the function\nassert snake_to_camel('python_program') == 'PythonProgram'"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Parameters:\n    n (int): The number of vertices in the graph.\n    m (int): The number of edges in the graph.\n\n    Returns:\n    int: The Eulerian number a(n, m).\n\n    Raises:\n    ValueError: If n or m is negative.\n\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"n and m must be non-negative\")\n\n    if m == 0:\n        return 1\n\n    if n == 0:\n        return 0\n\n    a = [[0] * (m + 1) for _ in range(n + 1)]\n    a[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            a[i][j] = a[i - 1][j - 1] + i * a[i - 1][j]\n\n    return a[n][m]\n\n# Test the function\nassert eulerian_num(3, 1) == 4"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n    lst (list): A list of lists, where each sublist contains strings.\n\n    Returns:\n    list: A new list with each sublist sorted in alphabetical order.\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]\n\n# Test the function\nassert sort_sublists([[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"}
{"task_id": "Mbpp/105", "solution": "def count(lst):\n    \"\"\"\n    Counts the number of True values in the given list.\n\n    Parameters:\n    lst (list): A list of boolean values.\n\n    Returns:\n    int: The number of True values in the list.\n    \"\"\"\n    return sum(1 for value in lst if value)\n\n# Test the function\nassert count([True, False, True]) == 2"}
{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuples.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tpl (tuple): The tuple to which the list is to be appended.\n\n    Returns:\n    tuple: The resulting tuple with the list appended.\n    \"\"\"\n    return tpl + tuple(lst)\n\n# Test the function\nassert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\n\n# Test the function\nassert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"}
{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, num_rotations):\n    \"\"\"\n    Finds the number of numbers with an odd value when rotating a binary string the given number of times.\n\n    Parameters:\n    binary_string (str): The binary string to be rotated.\n    num_rotations (int): The number of rotations to be performed.\n\n    Returns:\n    int: The number of numbers with an odd value when rotating the binary string the given number of times.\n    \"\"\"\n\n    def rotate_string(string, num):\n        \"\"\"\n        Rotates a given string by a given number of positions.\n\n        Parameters:\n        string (str): The string to be rotated.\n        num (int): The number of positions to rotate the string.\n\n        Returns:\n        str: The rotated string.\n        \"\"\"\n        return string[num:] + string[:num]\n\n    def is_odd(num):\n        \"\"\"\n        Checks if a given number is odd.\n\n        Parameters:\n        num (int): The number to be checked.\n\n        Returns:\n        bool: True if the number is odd, False otherwise.\n        \"\"\"\n        return num % 2 != 0\n\n    count = 0\n    original_binary = binary_string\n\n    for _ in range(num_rotations):\n        binary_string = rotate_string(binary_string, 1)\n        decimal_value = int(binary_string, 2)\n        if is_odd(decimal_value):\n            count += 1\n\n    return count\n\n# Test the function\nassert odd_Equivalent(\"011001\", 6) == 3"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Parameters:\n    nested_lists (list): A list of lists containing elements.\n\n    Returns:\n    list: A list containing the common elements found in the nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for sublist in nested_lists[1:]:\n        common_elements = common_elements.intersection(sublist)\n\n    return list(common_elements)\n\n# Test the function\nassert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])) == set([18, 12])"}
{"task_id": "Mbpp/113", "solution": "def check_integer(string):\n    \"\"\"\n    Check if a string represents an integer or not.\n\n    Parameters:\n    string (str): The string to be checked.\n\n    Returns:\n    bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False\n\n# Test cases\nassert check_integer(\"python\") == False"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(t):\n    \"\"\"\n    Convert a given tuple of positive integers into a single integer.\n\n    Parameters:\n    t (tuple): The input tuple of positive integers.\n\n    Returns:\n    int: The single integer formed by concatenating the elements of the input tuple.\n\n    Examples:\n    >>> tuple_to_int((1, 2, 3))\n    123\n    >>> tuple_to_int((4, 5, 6))\n    456\n    \"\"\"\n    return int(''.join(map(str, t)))\n\n# Test the function\nassert tuple_to_int((1, 2, 3)) == 123\nassert tuple_to_int((4, 5, 6)) == 456"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    \"\"\"\n    Convert a string to a list of strings split on the space character.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    list: A list of strings split on the space character.\n    \"\"\"\n    return string.split()\n\n# Test the function\nassert string_to_list(\"python programming\") == ['python', 'programming']"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n\n    Returns:\n    int: The element that appears only once in the array.\n\n    Raises:\n    ValueError: If the input array does not contain exactly one element that appears only once.\n\n    Examples:\n    >>> search([1,1,2,2,3])\n    3\n    >>> search([1,1,2,2,3,3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input array does not contain exactly one element that appears only once.\n    \"\"\"\n\n    if len(arr) == 0:\n        raise ValueError(\"Input array is empty.\")\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] == arr[mid - 1]:\n            if (mid - left) % 2 == 0:\n                right = mid - 2\n            else:\n                left = mid + 1\n        elif arr[mid] == arr[mid + 1]:\n            if (right - mid) % 2 == 0:\n                left = mid + 2\n            else:\n                right = mid - 1\n        else:\n            return arr[mid]\n\n    return arr[left]"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(lst):\n    \"\"\"\n    Finds the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Parameters:\n    lst (list): A list of tuples.\n\n    Returns:\n    int: The maximum absolute product between numbers in pairs of tuples.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )\n    36\n    >>> max_product_tuple([(1, -2), (-3, 4), (-5, -6)] )\n    30\n    >>> max_product_tuple([])\n    Traceback (most recent call last):\n    ...\n    ValueError: Input list cannot be empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    max_product = float('-inf')\n    for pair in lst:\n        product = abs(pair[0] * pair[1])\n        if product > max_product:\n            max_product = product\n\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def is_amicable(n):\n    \"\"\"\n    Check if a number is amicable.\n\n    An amicable number is a pair of numbers where the sum of the proper divisors of each number is equal to the other number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is amicable, False otherwise.\n    \"\"\"\n    def sum_of_divisors(m):\n        \"\"\"\n        Calculate the sum of proper divisors of a number.\n\n        Args:\n        m (int): The number to calculate the sum of divisors for.\n\n        Returns:\n        int: The sum of proper divisors of the number.\n        \"\"\"\n        divisors = [1]\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                divisors.append(i)\n                if i != m // i:\n                    divisors.append(m // i)\n        return sum(divisors)\n\n    sum_of_n = sum_of_divisors(n)\n    sum_of_sum_of_n = sum_of_divisors(sum_of_n)\n    return sum_of_sum_of_n != n and sum_of_sum_of_n == n\n\n\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to a specified limit.\n\n    Args:\n    limit (int): The upper limit to calculate the sum for.\n\n    Returns:\n    int: The sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    amicable_sum = 0\n    for i in range(1, limit + 1):\n        if is_amicable(i):\n            amicable_sum += i\n    return amicable_sum\n\n\n# Test the function\nassert amicable_numbers_sum(999) == 504"}
{"task_id": "Mbpp/124", "solution": "import math\n\ndef angle_complex(z):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Parameters:\n    z (complex): The complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n\n    Raises:\n    TypeError: If the input is not a complex number.\n\n    Examples:\n    >>> angle_complex(0,1j)\n    1.5707963267948966\n    >>> angle_complex(1+1j)\n    1.1071487177940904\n    >>> angle_complex(1-1j)\n    -0.4636476090008061\n    \"\"\"\n    if not isinstance(z, complex):\n        raise TypeError(\"Input must be a complex number\")\n\n    angle = math.atan2(z.imag, z.real)\n    return angle\n\n# Test the function\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)"}
{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    max_diff = 0\n    count_zeros = 0\n    count_ones = 0\n\n    for char in binary_string:\n        if char == '0':\n            count_zeros += 1\n        else:\n            count_ones += 1\n\n        diff = count_ones - count_zeros\n        max_diff = max(max_diff, diff)\n\n    return max_diff\n\n# Test the function\nassert find_length(\"11000010001\") == 6"}
{"task_id": "Mbpp/126", "solution": "def sum_of_common_divisors(a, b):\n    \"\"\"\n    Finds the sum of common divisors of two given numbers.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The sum of common divisors.\n    \"\"\"\n\n    def get_divisors(n):\n        \"\"\"\n        Helper function to get the divisors of a number.\n\n        Parameters:\n        n (int): The number.\n\n        Returns:\n        list: A list of divisors.\n        \"\"\"\n        divisors = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    divisors_a = get_divisors(a)\n    divisors_b = get_divisors(b)\n    common_divisors = list(set(divisors_a) & set(divisors_b))\n    return sum(common_divisors)\n\n# Test the function\nassert sum_of_common_divisors(10, 15) == 6"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Function to multiply two integers.\n\n    Parameters:\n    a (int): First integer.\n    b (int): Second integer.\n\n    Returns:\n    int: Product of the two integers.\n    \"\"\"\n    return a * b\n\n# Test the function\nassert multiply_int(10, 20) == 200"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Parameters:\n    n (int): The minimum length of words to be considered long.\n    sentence (str): The input sentence containing the words.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list\n\n# Test the function\nassert long_words(3, \"python is a programming language\") == ['python', 'programming', 'language']"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if a given matrix is a magic square.\n\n    Parameters:\n    matrix (list): A 2D matrix representing the square.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    # Check if the matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate the expected sum of each row, column, and diagonal\n    n = len(matrix)\n    expected_sum = sum(matrix[0])\n\n    # Check each row\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check each column\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != expected_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    main_diag_sum = 0\n    for i in range(n):\n        main_diag_sum += matrix[i][i]\n    if main_diag_sum != expected_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    secondary_diag_sum = 0\n    for i in range(n):\n        secondary_diag_sum += matrix[i][n - 1 - i]\n    if secondary_diag_sum != expected_sum:\n        return False\n\n    return True\n\n# Test the function\nassert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with maximum frequency in a given list.\n\n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    int or float: The item with maximum frequency in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n    2\n    >>> max_occurrences([])\n    Traceback (most recent call last):\n    ...\n    ValueError: List is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty.\")\n\n    frequency = {}\n    max_item = lst[0]\n    max_count = 1\n\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n        if frequency[item] > max_count:\n            max_count = frequency[item]\n            max_item = item\n\n    return max_item"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(string):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    string_list = list(string)\n    vowel_list = [char for char in string_list if char.lower() in vowels]\n    vowel_list.reverse()\n    vowel_index = 0\n    for i in range(len(string_list)):\n        if string_list[i].lower() in vowels:\n            string_list[i] = vowel_list[vowel_index]\n            vowel_index += 1\n    return ''.join(string_list)\n\n# Test cases\nassert reverse_vowels(\"Python\") == \"Python\"\nassert reverse_vowels(\"Hello World\") == \"Hollo Werld\"\nassert reverse_vowels(\"Programming\") == \"PrOgraimgn\"\nassert reverse_vowels(\"Python is fun\") == \"Python is nuf\"\nassert reverse_vowels(\"This is a test\") == \"This is a tset\""}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    \"\"\"\n    Convert a tuple to a string.\n\n    Parameters:\n    tup (tuple): The input tuple.\n\n    Returns:\n    str: The converted string.\n    \"\"\"\n    return ''.join(tup)\n\n# Test the function\nassert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's')) == \"exercises\""}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers in a given list of numbers.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The sum of the negative numbers.\n\n    Raises:\n    TypeError: If the input is not a list.\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])\n    -32\n    >>> sum_negativenum([])\n    Traceback (most recent call last):\n    ...\n    ValueError: List is empty.\n    >>> sum_negativenum(\"not a list\")\n    Traceback (most recent call last):\n    ...\n    TypeError: Input must be a list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if len(numbers) == 0:\n        raise ValueError(\"List is empty.\")\n\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Function to find the nth hexagonal number.\n\n    Parameters:\n    n (int): The position of the hexagonal number to find.\n\n    Returns:\n    int: The nth hexagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> hexagonal_num(10)\n    190\n    >>> hexagonal_num(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (2 * n - 1)\n\n# Testing the function\nassert hexagonal_num(10) == 190"}
{"task_id": "Mbpp/137", "solution": "import math\n\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    \n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    if non_zero_count == 0:\n        return 0\n    \n    return zero_count / non_zero_count\n\n# Test the function\nassert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)"}
{"task_id": "Mbpp/138", "solution": "def is_sum_of_powers_of_two(n):\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n\n    # Base case: if n is 0, it cannot be represented as sum of non-zero powers of 2\n    if n == 0:\n        return False\n\n    # Iterate through all possible powers of 2 from 1 to n/2\n    for i in range(1, n // 2 + 1):\n        # Check if n can be represented as sum of non-zero powers of 2\n        if is_sum_of_powers_of_two(n - 2**i):\n            return True\n\n    # If no combination of powers of 2 sums up to n, return False\n    return False\n\n# Test the function\nassert is_sum_of_powers_of_two(10) == True"}
{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    float: The circumference of the circle.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    return 2 * math.pi * radius\n\n# Test the function\nassert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(lst):\n    \"\"\"\n    Extracts a single list of numbers from a list of lists.\n\n    Args:\n    lst (list): A list of lists containing numbers.\n\n    Returns:\n    list: A single list of numbers extracted from the input list.\n    \"\"\"\n    return [num for sublist in lst for num in sublist]\n\n# Test the function\nassert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Parameters:\n    lst (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list in ascending order.\n\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"\n        Reverses the order of the first k elements in the list.\n\n        Parameters:\n        arr (list): The list to be flipped.\n        k (int): The number of elements to be flipped.\n\n        Returns:\n        None\n\n        \"\"\"\n        arr[:k] = reversed(arr[:k])\n\n    def find_max_index(arr, n):\n        \"\"\"\n        Finds the index of the maximum element in the list.\n\n        Parameters:\n        arr (list): The list to search for the maximum element.\n        n (int): The number of elements to consider.\n\n        Returns:\n        int: The index of the maximum element.\n\n        \"\"\"\n        max_index = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n\n    n = len(lst)\n    for i in range(n, 1, -1):\n        max_index = find_max_index(lst, i)\n        if max_index != i - 1:\n            if max_index != 0:\n                flip(lst, max_index)\n                flip(lst, i - 1)\n            flip(lst, i)\n\n    return lst\n\n# Test the function\nassert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the number of items that are identical in the same position of three given lists.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n\n    Returns:\n    int: The number of items that are identical in the same position of the three lists.\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n\n# Test the function\nassert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9]) == 3"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    Finds the maximum difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): The input array of integers.\n\n    Returns:\n    int: The maximum difference between any two elements in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n\n    Examples:\n    >>> max_Abs_Diff((2, 1, 5, 3))\n    4\n    >>> max_Abs_Diff((1, 1, 1, 1))\n    0\n    >>> max_Abs_Diff((-1, -5, -2, -8))\n    7\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n\n    max_diff = float('-inf')\n    min_val = float('inf')\n\n    for num in arr:\n        max_diff = max(max_diff, num - min_val)\n        min_val = min(min_val, num)\n\n    return max_diff"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    \"\"\"\n    Finds integers x and y that satisfy ax + by = n as a tuple, or returns None if no solution exists.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    n (int): The desired value.\n\n    Returns:\n    tuple or None: A tuple (x, y) that satisfies ax + by = n, or None if no solution exists.\n    \"\"\"\n    for x in range(n + 1):\n        for y in range(n + 1):\n            if a * x + b * y == n:\n                return x, y\n    return None\n\n# Test cases\nassert find_solution(2, 3, 7) == (2, 1)"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(lst1, lst2):\n    \"\"\"\n    Remove all elements from lst1 that are present in lst2.\n\n    Args:\n    lst1 (list): The first list.\n    lst2 (list): The second list.\n\n    Returns:\n    list: A new list with elements from lst1 that are not present in lst2.\n    \"\"\"\n    return [x for x in lst1 if x not in lst2]\n\n# Test the function\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n\n# Test the function\nassert sum_series(6) == 12"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    \"\"\"\n    Counts the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The number of characters that occur at the same position in the string as in the English alphabet.\n    \"\"\"\n    count = 0\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    string = string.lower()\n\n    for i in range(len(string)):\n        if string[i] == alphabet[i]:\n            count += 1\n\n    return count\n\n# Test the function\nassert count_char_position(\"xbcefg\") == 2"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count\n\n# Test cases\nassert find_even_pair([5, 4, 7, 2, 1]) == 4"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Finds the smallest power of 2 greater than or equal to n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n\n# Test cases\nassert next_power_of_2(0) == 1\nassert next_power_of_2(1) == 1\nassert next_power_of_2(2) == 2\nassert next_power_of_2(3) == 4\nassert next_power_of_2(4) == 4\nassert next_power_of_2(5) == 8\nassert next_power_of_2(6) == 8\nassert next_power_of_2(7) == 8\nassert next_power_of_2(8) == 8\nassert next_power_of_2(9) == 16\nassert next_power_of_2(10) == 16"}
{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    \"\"\"\n    Counts the number of occurrences of a number in a given list.\n\n    Parameters:\n    lst (list): The list to search for occurrences.\n    num: The number to count occurrences of.\n\n    Returns:\n    int: The number of occurrences of num in lst.\n    \"\"\"\n    return lst.count(num)\n\n# Test cases\nassert frequency([1,2,3], 4) == 0"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Finds the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n\n    Returns:\n    int: The sum of numbers within the specified range.\n\n    Raises:\n    ValueError: If the start or end indices are out of range.\n\n    Examples:\n    >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10)\n    29\n    >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 0, 12)\n    66\n    >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 0, 0)\n    2\n    >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 1, 2)\n    8\n    >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 10, 8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Start index cannot be greater than end index.\n    \"\"\"\n    if start > end:\n        raise ValueError(\"Start index cannot be greater than end index.\")\n\n    if start < 0 or end >= len(lst):\n        raise ValueError(\"Start or end indices are out of range.\")\n\n    return sum(lst[start:end+1])"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of its sides.\n\n    Parameters:\n    side_length (float): The length of the sides of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n\n    Raises:\n    ValueError: If the side_length is not a positive number.\n\n    Examples:\n    >>> perimeter_pentagon(5)\n    25\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 5 * side_length\n\n# Test the function\nassert perimeter_pentagon(5) == 25"}
{"task_id": "Mbpp/172", "solution": "def count_occurance(string):\n    \"\"\"\n    Counts the number of occurrences of the string 'std' in a given string.\n\n    Parameters:\n    string (str): The input string to search for 'std' occurrences.\n\n    Returns:\n    int: The number of occurrences of 'std' in the input string.\n    \"\"\"\n    return string.count('std')\n\n# Test the function\nassert count_occurance(\"letstdlenstdporstd\") == 3"}
{"task_id": "Mbpp/222", "solution": "def check_type(t):\n    \"\"\"\n    Check if all the elements in a tuple have the same data type.\n\n    Parameters:\n    t (tuple): The input tuple.\n\n    Returns:\n    bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    if len(t) < 2:\n        return True\n\n    first_type = type(t[0])\n    for element in t[1:]:\n        if type(element) != first_type:\n            return False\n\n    return True\n\n# Test cases\nassert check_type((5, 6, 7, 3, 5, 6)) == True\nassert check_type((\"hello\", \"world\", \"python\")) == True\nassert check_type((1, \"2\", 3.0)) == False\nassert check_type(()) == True"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    count = 0\n    for i in range(n):\n        if arr[i] == element:\n            count += 1\n    return count > n // 2\n\n# Test cases\nassert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\nassert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 4) == False\nassert is_majority([1, 2, 2, 2, 2, 2, 2], 7, 2) == True\nassert is_majority([1, 2, 2, 2, 2, 2, 2], 7, 3) == False"}
{"task_id": "Mbpp/224", "solution": "def count_set_bits(num):\n    \"\"\"\n    Counts the number of set bits (binary digits with value 1) in a given number.\n\n    Parameters:\n    num (int): The number to count the set bits in.\n\n    Returns:\n    int: The number of set bits in the given number.\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\n# Test the function\nassert count_set_bits(2) == 1"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with characters removed.\n    \"\"\"\n    return string[::2]\n\n# Test the function\nassert odd_values_string('abcdef') == 'ace'"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Finds the minimum of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)\n\n# Test the function\nassert min_of_three(10, 20, 0) == 0"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in a given string with a specified character and returns the modified string.\n\n    Parameters:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return string.replace(\" \", character)\n\n# Test the function\nassert replace_blank(\"hello people\",'@') == \"hello@people\""}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    \"\"\"\n    Function to return the n largest items from a list.\n\n    Parameters:\n    lst (list): The input list.\n    n (int): The number of largest items to return.\n\n    Returns:\n    list: A list containing the n largest items from the input list.\n    \"\"\"\n    if n == 0:\n        return []\n    sorted_lst = sorted(lst, reverse=True)\n    return sorted_lst[:n]\n\n# Test the function\nassert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2)) == set([100, 90])"}
{"task_id": "Mbpp/233", "solution": "import math\n\ndef lateral_surface_cylinder(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n\n    Raises:\n    ValueError: If either radius or height is negative.\n\n    Examples:\n    >>> lateral_surface_cylinder(10, 5)\n    314.15000000000003\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be non-negative\")\n\n    base_area = math.pi * radius**2\n    lateral_area = 2 * math.pi * radius * height\n    return 2 * base_area + lateral_area\n\n# Test the function\nassert math.isclose(lateral_surface_cylinder(10, 5), 314.15000000000003, rel_tol=0.001)"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Parameters:\n    side_length (float or int): The length of the side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> volume_cube(3)\n    27\n    >>> volume_cube(0)\n    0\n    >>> volume_cube(-2)\n    Traceback (most recent call last):\n    ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n\n    if side_length < 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    return side_length ** 3\n\n# Test the function\nassert volume_cube(3) == 27\nassert volume_cube(0) == 0\nassert volume_cube(-2)"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(num):\n    \"\"\"\n    This function sets all even bits of a given number.\n\n    Parameters:\n    num (int): The input number.\n\n    Returns:\n    int: The number with all even bits set.\n\n    Examples:\n    >>> even_bit_set_number(10)\n    10\n    >>> even_bit_set_number(7)\n    6\n    >>> even_bit_set_number(15)\n    14\n    \"\"\"\n\n    # Convert the number to binary representation\n    binary = bin(num)[2:]\n\n    # Set all even bits to 1\n    binary = binary[:-1] + '1' + binary[-1]\n\n    # Convert the binary representation back to decimal\n    result = int(binary, 2)\n\n    return result"}
{"task_id": "Mbpp/237", "solution": "def check_occurences(lst):\n    \"\"\"\n    This function takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\n    Parameters:\n    lst (list): A list of tuples.\n\n    Returns:\n    dict: A dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    occurences = {}\n    for tuple_ in lst:\n        if tuple_ in occurences:\n            occurences[tuple_] += 1\n        else:\n            occurences[tuple_] = 1\n    return occurences\n\n# Test the function\nassert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(string):\n    \"\"\"\n    Counts the number of non-empty substrings of a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The number of non-empty substrings.\n\n    \"\"\"\n    length = len(string)\n    count = length * (length + 1) // 2\n    return count\n\n# Test the function\nassert number_of_substrings(\"abc\") == 6"}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Function to find the number of possible sequences of length n, where each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Parameters:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The number of possible sequences.\n    \"\"\"\n\n    # Initialize a 2D matrix to store the number of sequences\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # There is only one sequence of length 1, where the element is any positive integer less than or equal to m\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Calculate the number of sequences for lengths 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # Calculate the number of sequences where the current element is greater than or equal to twice the previous element\n            for k in range(j // 2, j + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # Return the total number of sequences\n    return sum(dp[n])\n\n# Test the function\nassert get_total_number_of_sequences(10, 4) == 4"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n\n    Returns:\n    list: The modified list1 with the last element replaced by the elements of list2.\n    \"\"\"\n    list1[-1] = list2\n    return list1\n\n# Test the function\nassert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"}
{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    \"\"\"\n    Counts the total number of characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    return len(string)\n\n# Test the function\nassert count_charac(\"python programming\") == 18"}
{"task_id": "Mbpp/244", "solution": "def next_perfect_square(num):\n    \"\"\"\n    Finds the next perfect square greater than a given number.\n\n    Parameters:\n    num (int): The given number.\n\n    Returns:\n    int: The next perfect square greater than num.\n\n    Raises:\n    ValueError: If num is negative.\n\n    Examples:\n    >>> next_perfect_square(35)\n    36\n    >>> next_perfect_square(100)\n    121\n    >>> next_perfect_square(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number must be non-negative.\n    \"\"\"\n\n    if num < 0:\n        raise ValueError(\"Number must be non-negative.\")\n\n    # Find the square root of num\n    sqrt_num = int(num ** 0.5)\n\n    # Check if num is a perfect square\n    if sqrt_num ** 2 == num:\n        return (sqrt_num + 1) ** 2\n\n    # Find the next perfect square greater than num\n    return (sqrt_num + 1) ** 2\n\n# Test the function\nassert next_perfect_square(35) == 36\nassert next_perfect_square(100) == 121\nassert next_perfect_square(-5)"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    if n < 3:\n        return 0\n\n    inc = [0] * n  # Array to store increasing subsequence sums\n    dec = [0] * n  # Array to store decreasing subsequence sums\n\n    # Calculate increasing subsequence sums\n    inc[0] = arr[0]\n    for i in range(1, n):\n        inc[i] = max(inc[i-1], arr[i])\n\n    # Calculate decreasing subsequence sums\n    dec[-1] = arr[-1]\n    for i in range(n-2, -1, -1):\n        dec[i] = max(dec[i+1], arr[i])\n\n    # Find maximum sum of bitonic subsequence\n    max_sum = arr[0]\n    for i in range(1, n-1):\n        max_sum = max(max_sum, inc[i-1] + dec[i+1] - arr[i])\n\n    return max_sum\n\n# Test the function\nassert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194"}
{"task_id": "Mbpp/247", "solution": "def lps(s):\n    \"\"\"\n    Finds the length of the longest palindromic subsequence in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The length of the longest palindromic subsequence.\n\n    Examples:\n    >>> lps(\"TENS FOR TENS\")\n    5\n    >>> lps(\"ABCD\")\n    1\n    >>> lps(\"\")\n    0\n    \"\"\"\n\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Create a 2D matrix to store the lengths of palindromic subsequences\n    dp = [[0] * n for _ in range(n)]\n\n    # All substrings of length 1 are palindromes of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Check for palindromic subsequences of length 2 and greater\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\n    return dp[0][n-1]\n\n# Test the function\nassert lps(\"TENS FOR TENS\") == 5\nassert lps(\"ABCD\") == 1\nassert lps(\"\") == 0"}
{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Parameters:\n    tup (tuple): The input tuple.\n    element: The element to count.\n\n    Returns:\n    int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(element)\n\n# Test the function\nassert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 4) == 0"}
{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n\n# Test the function\nassert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"}
{"task_id": "Mbpp/252", "solution": "import math\n\ndef convert(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Parameters:\n    z (complex): The complex number to be converted.\n\n    Returns:\n    tuple: A tuple containing the magnitude and angle of the polar coordinates.\n    \"\"\"\n    magnitude = abs(z)\n    angle = math.atan2(z.imag, z.real)\n    return (magnitude, angle)\n\n# Test the function\nassert convert(1) == (1.0, 0.0)"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    \"\"\"\n    Returns the number of integer elements in a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int: The number of integer elements in the list.\n    \"\"\"\n    count = 0\n    for element in lst:\n        if isinstance(element, int):\n            count += 1\n    return count\n\n# Test the function\nassert count_integer([1, 2, 'abc', 1.2]) == 2"}
{"task_id": "Mbpp/255", "solution": "def combinations_colors(lst, n):\n    if n == 0:\n        return [()]\n\n    result = []\n    for i in range(len(lst)):\n        sub_combinations = combinations_colors(lst, n-1)\n        for sub_combination in sub_combinations:\n            result.append((lst[i],) + sub_combination)\n\n    return result\n\n# Test cases\nassert combinations_colors([\"Red\", \"Green\", \"Blue\"], 1) == [('Red',), ('Green',), ('Blue',)]\nassert combinations_colors([\"Red\", \"Green\", \"Blue\"], 2) == [('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Red'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Red'), ('Blue', 'Green'), ('Blue', 'Blue')]\nassert combinations_colors([\"Red\", \"Green\", \"Blue\"], 3) == [('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Red'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Red'), ('Red', 'Blue', 'Green'), ('Red', 'Blue', 'Blue'), ('Green', 'Red', 'Red'), ('Green', 'Red', 'Green'), ('Green', 'Red', 'Blue'), ('Green', 'Green', 'Red'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Red'), ('Green', 'Blue', 'Green'), ('Green', 'Blue', 'Blue'), ('Blue', 'Red', 'Red'), ('Blue', 'Red', 'Green'), ('Blue', 'Red', 'Blue'), ('Blue', 'Green', 'Red'), ('Blue', 'Green', 'Green'), ('Blue', 'Green', 'Blue'), ('Blue', 'Blue', 'Red'), ('Blue', 'Blue', 'Green'), ('Blue', 'Blue', 'Blue')]\n```"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n    Parameters:\n    n (int): The non-negative number.\n\n    Returns:\n    int: The number of prime numbers less than n.\n    \"\"\"\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count\n\n# Test the function\nassert count_Primes_nums(5) == 2"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    \"\"\"\n    Swaps the order of two numbers and returns a tuple with the second number first and then the first number.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    tuple: A tuple with the second number first and then the first number.\n    \"\"\"\n    return b, a\n\n# Test the function\nassert swap_numbers(10, 20) == (20, 10)"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuples1, tuples2):\n    if len(tuples1) != len(tuples2):\n        raise ValueError(\"The lengths of the two tuples must be equal\")\n\n    result = []\n    for i in range(len(tuples1)):\n        max_element = max(tuples1[i][0], tuples2[i][0]), max(tuples1[i][1], tuples2[i][1])\n        result.append(max_element)\n\n    return tuple(result)\n\n# Test the function\nassert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))"}
{"task_id": "Mbpp/260", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef newman_prime(n):\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num):\n            count += 1\n        num += 1\n    return num - 1\n\n# Test the function\nassert newman_prime(3) == 7"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Function to perform mathematical division operation element-wise across two given tuples.\n\n    Args:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A new tuple containing the result of element-wise division of tuple1 by tuple2.\n\n    Raises:\n    ValueError: If the length of tuple1 and tuple2 is not the same.\n    ZeroDivisionError: If an element in tuple2 is zero.\n\n    Examples:\n    >>> division_elements((10, 4, 6, 9), (5, 2, 3, 3))\n    (2, 2, 2, 3)\n    >>> division_elements((10, 4, 6, 9), (5, 2, 0, 3))\n    Traceback (most recent call last):\n    ...\n    ZeroDivisionError: division by zero\n    \"\"\"\n\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"The length of tuple1 and tuple2 must be the same.\")\n\n    result = []\n    for i in range(len(tuple1)):\n        if tuple2[i] == 0:\n            raise ZeroDivisionError(\"division by zero\")\n        result.append(tuple1[i] / tuple2[i])\n\n    return tuple(result)"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits the given list into two parts where the length of the first part is L, and returns the resulting lists in a tuple.\n\n    Args:\n    lst (list): The input list.\n    L (int): The length of the first part of the list.\n\n    Returns:\n    tuple: A tuple containing the two resulting lists.\n\n    Raises:\n    ValueError: If L is greater than the length of the input list.\n\n    Examples:\n    >>> split_two_parts([1,1,2,3,4,4,5,1],3)\n    ([1, 1, 2], [3, 4, 4, 5, 1])\n    \"\"\"\n    if L > len(lst):\n        raise ValueError(\"L cannot be greater than the length of the input list\")\n\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/264", "solution": "def dog_age(human_age):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    Parameters:\n    human_age (int): The age of the dog in human years.\n\n    Returns:\n    int: The age of the dog in dog's years.\n\n    Raises:\n    ValueError: If the human_age is not a non-negative integer.\n\n    \"\"\"\n    if not isinstance(human_age, int) or human_age < 0:\n        raise ValueError(\"Human age must be a non-negative integer.\")\n\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4\n\n# Test the function\nassert dog_age(12) == 61"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    result = []\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n    return result\n\n# Test the function\nassert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n\n    Parameters:\n    side_length (float or int): The length of the side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> lateralsurface_cube(5)\n    100\n    >>> lateralsurface_cube(0)\n    0\n    >>> lateralsurface_cube(-2)\n    Traceback (most recent call last):\n    ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    return 4 * side_length ** 2\n\n# Test the function\nassert lateralsurface_cube(5) == 100"}
{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    \"\"\"\n    This function takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i**2\n    return sum\n\n# Test the function\nassert square_Sum(2) == 10"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Find the n'th star number.\n\n    A star number is defined as the sum of the factorials of its digits.\n    For example, 145 is a star number because 1!-- + 4!-- + 5!-- = 145.\n\n    Parameters:\n    n (int): The index of the star number to find.\n\n    Returns:\n    int: The n'th star number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> find_star_num(3)\n    37\n    >>> find_star_num(5)\n    299\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    def factorial(num):\n        if num == 0:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    def is_star_num(num):\n        return sum(factorial(int(digit)) for digit in str(num)) == num\n\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if is_star_num(num):\n            count += 1\n\n    return num"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    This function takes a character as input and returns its ASCII value.\n\n    Parameters:\n    char (str): A single character.\n\n    Returns:\n    int: The ASCII value of the character.\n    \"\"\"\n    return ord(char)\n\n# Test the function\nassert ascii_value('A') == 65"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    \"\"\"\n    Finds the sum of even numbers at even positions in a list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of even numbers at even positions.\n\n    Raises:\n    TypeError: If the input is not a list.\n    ValueError: If the list contains non-integer elements.\n\n    Examples:\n    >>> sum_even_and_even_index([5, 6, 12, 1, 18, 8])\n    30\n    >>> sum_even_and_even_index([1, 2, 3, 4, 5, 6])\n    12\n    >>> sum_even_and_even_index([10, 20, 30, 40, 50, 60])\n    120\n    \"\"\"\n\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    sum_even = 0\n    for i, num in enumerate(lst):\n        if not isinstance(num, int):\n            raise ValueError(\"List must contain only integers.\")\n        if i % 2 == 0 and num % 2 == 0:\n            sum_even += num\n\n    return sum_even"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    \"\"\"\n    Calculates the sum of the first n even natural numbers raised to the fifth power.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of the first n even natural numbers raised to the fifth power.\n    \"\"\"\n    sum = 0\n    for i in range(2, 2 * n + 1, 2):\n        sum += i ** 5\n    return sum\n\n# Test the function\nassert even_Power_Sum(2) == 1056"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    \"\"\"\n    Extracts the rear element of each tuple in the given list of tuples and returns a list of these rear elements.\n\n    Args:\n    tuples_list (list): A list of tuples.\n\n    Returns:\n    list: A list containing the rear element of each tuple.\n    \"\"\"\n    rear_elements = [tup[-1] for tup in tuples_list]\n    return rear_elements\n\n# Test the function\nassert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"}
{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"The two tuples must have the same length\")\n    \n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple1[i] - tuple2[i])\n    \n    return tuple(result)\n\n# Test the function\nassert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"}
{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculates the sum of even index binomial coefficients for a given positive integer n.\n\n    Parameters:\n    n (int): The positive integer.\n\n    Returns:\n    int: The sum of even index binomial coefficients.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> even_binomial_Coeff_Sum(4)\n    8\n    >>> even_binomial_Coeff_Sum(5)\n    10\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_even_coeffs = 0\n    for k in range(0, n+1, 2):\n        coeff = binomial_coefficient(n, k)\n        sum_even_coeffs += coeff\n\n    return sum_even_coeffs\n\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculates the binomial coefficient (n choose k).\n\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The binomial coefficient.\n\n    Raises:\n    ValueError: If n or k is not a non-negative integer.\n\n    Examples:\n    >>> binomial_coefficient(5, 3)\n    10\n    >>> binomial_coefficient(10, 7)\n    120\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0 or not isinstance(k, int) or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n\n    if k > n:\n        return 0\n\n    if k > n - k:\n        k = n - k\n\n    numerator = 1\n    denominator = 1\n    for i in range(1, k + 1):\n        numerator *= n - k + i\n        denominator *= i\n\n    return numerator // denominator"}
{"task_id": "Mbpp/276", "solution": "import math\n\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    return math.pi * radius**2 * height\n\n# Test the function\nassert math.isclose(volume_cylinder(10, 5), 1570.7963267948966, rel_tol=0.001)"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    filtered_dict = {key: value for key, value in dictionary.items() if value >= n}\n    return filtered_dict\n\n# Test the function\nassert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190}, 170) == {'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(t):\n    count = 0\n    for element in t:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count\n\n# Test the function\nassert count_first_elements((1, 5, 7, (4, 6), 10)) == 3"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Function to find the nth decagonal number.\n\n    Parameters:\n    n (int): The position of the decagonal number to find.\n\n    Returns:\n    int: The nth decagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> is_num_decagonal(3)\n    27\n    >>> is_num_decagonal(0)\n    0\n    >>> is_num_decagonal(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a positive integer.\")\n    return n * (10 * n - 1) // 2\n\n# Testing the function\nassert is_num_decagonal(3) == 27"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return True, i\n    return False, -1\n\n# Test the function\nassert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if the elements of a given list are unique or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))\n\n# Test cases\nassert all_unique([1, 2, 3]) == True\nassert all_unique([1, 2, 2]) == False\nassert all_unique([]) == True"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    \"\"\"\n    Subtracts two lists element-wise.\n\n    Parameters:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n\n    Returns:\n    list: A new list containing the element-wise difference between list1 and list2.\n\n    Raises:\n    ValueError: If the input lists have different lengths.\n\n    Examples:\n    >>> sub_list([1, 2, 3],[4,5,6])\n    [-3, -3, -3]\n    >>> sub_list([1, 2, 3],[1,2])\n    Traceback (most recent call last):\n      ...\n    ValueError: Input lists must have the same length.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [x - y for x, y in zip(list1, list2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(num):\n    num_str = str(num)\n    for digit in num_str:\n        if num_str.count(digit) > int(digit):\n            return False\n    return True\n\n# Test cases\nassert validate(1234) == True\nassert validate(121) == False\nassert validate(1111) == True\nassert validate(122) == False\nassert validate(100) == False"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    \"\"\"\n    Check if all items in the list are equal to the given element.\n\n    Parameters:\n    lst (list): The list to be checked.\n    element: The element to compare with.\n\n    Returns:\n    bool: True if all items in the list are equal to the element, False otherwise.\n    \"\"\"\n    return all(item == element for item in lst)\n\n# Test the function\nassert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False"}
{"task_id": "Mbpp/285", "solution": "import re\n\ndef text_match_two_three(text):\n    \"\"\"\n    Check whether a string contains the 'a' character followed by two or three 'b' characters.\n\n    Parameters:\n    text (str): The input string to be checked.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"ab{2,3}\"\n    return bool(re.search(pattern, text))\n\n# Test cases\nassert text_match_two_three(\"ac\") == False\nassert text_match_two_three(\"ab\") == False\nassert text_match_two_three(\"abb\") == True\nassert text_match_two_three(\"abbb\") == True\nassert text_match_two_three(\"abbbb\") == False"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, k, n):\n    def kadane(arr):\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    max_sum = float('-inf')\n    for i in range(k):\n        max_sum = max(max_sum, kadane(arr * (i + 1)))\n    return max_sum\n\n# Test cases\nassert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30"}
{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    \"\"\"\n    This function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of squares of the first n even natural numbers.\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += i*i\n    return sum\n\n# Test the function\nassert square_Sum(2) == 20"}
{"task_id": "Mbpp/290", "solution": "def max_length(lst):\n    max_len = 0\n    max_list = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    return max_len, max_list\n\n# Test the function\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"}
{"task_id": "Mbpp/292", "solution": "def find(dividend, divisor):\n    \"\"\"\n    This function takes two numbers as input and returns the quotient of the division, rounded down to the nearest integer.\n\n    Parameters:\n    dividend (int): The number to be divided.\n    divisor (int): The number to divide by.\n\n    Returns:\n    int: The quotient of the division, rounded down to the nearest integer.\n    \"\"\"\n    quotient = dividend // divisor\n    return quotient\n\n# Test the function\nassert find(10, 3) == 3"}
{"task_id": "Mbpp/293", "solution": "import math\n\ndef otherside_rightangle(a, b):\n    \"\"\"\n    Calculates the length of the third side of a right-angled triangle.\n\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n\n    Returns:\n    float: Length of the third side.\n\n    Raises:\n    ValueError: If either a or b is not a positive number.\n\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Both a and b must be positive numbers.\")\n\n    c = math.sqrt(a**2 + b**2)\n    return c\n\n# Test the function\nassert otherside_rightangle(7, 8) == 10.63014581273465"}
{"task_id": "Mbpp/294", "solution": "def max_val(lst):\n    max_value = None\n    for item in lst:\n        if max_value is None or item > max_value:\n            max_value = item\n    return max_value\n\n# Test the function\nassert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions.\n\n    \"\"\"\n    def merge_and_count(left, right):\n        \"\"\"\n        Merges two sorted arrays and counts the number of inversions.\n\n        Parameters:\n        left (list): The left sorted array.\n        right (list): The right sorted array.\n\n        Returns:\n        list: The merged sorted array.\n        int: The number of inversions.\n\n        \"\"\"\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left[i:])\n                j += 1\n\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inversions\n\n    def count_inversions(arr):\n        \"\"\"\n        Recursively counts the number of inversions in an array.\n\n        Parameters:\n        arr (list): The input array.\n\n        Returns:\n        int: The number of inversions.\n\n        \"\"\"\n        if len(arr) <= 1:\n            return 0\n\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        left_inversions = count_inversions(left)\n        right_inversions = count_inversions(right)\n        merge_inversions, _ = merge_and_count(left, right)\n\n        return left_inversions + right_inversions + merge_inversions\n\n    return count_inversions(arr)\n\n# Test the function\nassert get_Inv_Count([1, 20, 6, 4, 5]) == 5"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"\n    Flatten a given nested list structure.\n\n    Parameters:\n    nested_list (list): The nested list to be flattened.\n\n    Returns:\n    list: The flattened list.\n\n    Examples:\n    >>> flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])\n    [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    \"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(item)\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(lst):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    Args:\n    lst (list): A list of tuples where each tuple contains a name and an aggregate.\n\n    Returns:\n    tuple: A tuple containing the name with the maximum aggregate and the maximum aggregate.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])\n    ('Juan Whelan', 212)\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n\n    max_name = lst[0][0]\n    max_aggr = lst[0][1]\n\n    for name, aggr in lst:\n        if aggr > max_aggr:\n            max_name = name\n            max_aggr = aggr\n\n    return (max_name, max_aggr)"}
{"task_id": "Mbpp/300", "solution": "import math\n\ndef count_binary_seq(n):\n    \"\"\"\n    Function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n\n    Parameters:\n    n (int): The length of the binary sequence.\n\n    Returns:\n    float: The count of binary sequences satisfying the condition.\n\n    \"\"\"\n    def count_helper(n, sum_diff, count):\n        if n == 0:\n            return count + 1 if sum_diff == 0 else count\n        return count_helper(n - 1, sum_diff + 1, count) + count_helper(n - 1, sum_diff - 1, count)\n\n    return count_helper(2 * n, 0, 0)\n\n# Test the function\nassert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    \"\"\"\n    Find the depth of a dictionary.\n\n    Parameters:\n    dictionary (dict): The input dictionary.\n\n    Returns:\n    int: The depth of the dictionary.\n\n    \"\"\"\n    def find_depth(dictionary, current_depth):\n        if not isinstance(dictionary, dict) or not dictionary:\n            return current_depth\n        max_depth = current_depth\n        for value in dictionary.values():\n            if isinstance(value, dict):\n                max_depth = max(max_depth, find_depth(value, current_depth + 1))\n        return max_depth\n\n    return find_depth(dictionary, 1)\n\n# Test the function\nassert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4"}
{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    result = []\n    for word in words:\n        if word.startswith('p'):\n            result.append(word)\n    return tuple(result)\n\n# Test the function\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    if i >= n or k >= n:\n        return 0\n\n    max_sum = float('-inf')\n    for j in range(i+1, n):\n        if arr[j] > arr[i]:\n            max_sum = max(max_sum, arr[j] + max_sum_increasing_subseq(arr, n, j, k))\n\n    if k > i:\n        max_sum = max(max_sum, arr[k] + max_sum_increasing_subseq(arr, n, i, k+1))\n\n    return max_sum\n\n# Test the function\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, num):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n    list1 (list): The first list of factors.\n    list2 (list): The second list of factors.\n    num (int): The number of largest products to find.\n\n    Returns:\n    list: A list of the specified number of largest products.\n\n    Raises:\n    ValueError: If num is greater than the length of either list.\n\n    Examples:\n    >>> large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)\n    [60, 54, 50]\n    \"\"\"\n\n    if num > len(list1) or num > len(list2):\n        raise ValueError(\"num is greater than the length of either list\")\n\n    products = []\n    for i in range(num):\n        max_product = max(list1[i] * list2[0], list1[0] * list2[i])\n        max_index1 = 0\n        max_index2 = 0\n\n        for j in range(len(list1)):\n            for k in range(len(list2)):\n                product = list1[j] * list2[k]\n                if product > max_product:\n                    max_product = product\n                    max_index1 = j\n                    max_index2 = k\n\n        products.append(max_product)\n        list1.pop(max_index1)\n        list2.pop(max_index2)\n\n    return products"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the maximum of the two.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The maximum of the two input numbers.\n    \"\"\"\n    return max(a, b)\n\n# Test the function\nassert maximum(5, 10) == 10"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(string):\n    \"\"\"\n    Convert a given string to a tuple of characters.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    tuple: A tuple containing the characters of the input string.\n    \"\"\"\n    return tuple(string)\n\n# Test the function\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(num):\n    \"\"\"\n    This function takes an integer as input and returns the number with the left most unset bit set.\n\n    Parameters:\n    num (int): The input integer.\n\n    Returns:\n    int: The number with the left most unset bit set.\n    \"\"\"\n    # Find the position of the left most unset bit\n    position = 0\n    while num & (1 << position):\n        position += 1\n\n    # Set the left most unset bit\n    num |= (1 << position)\n\n    return num\n\n# Test the function\nassert set_left_most_unset_bit(10) == 14"}
{"task_id": "Mbpp/312", "solution": "import math\n\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    radius (float): The radius of the base of the cone.\n    height (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n\n    Raises:\n    ValueError: If the radius or height is negative.\n\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be non-negative\")\n\n    base_area = math.pi * radius**2\n    volume = (1/3) * base_area * height\n    return volume\n\n# Test the function\nassert math.isclose(volume_cone(5, 12), 314.15926535897927, rel_tol=0.001)"}
{"task_id": "Mbpp/388", "solution": "def highest_power_of_2(n):\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2\n\n# Test the function\nassert highest_power_of_2(10) == 8"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    \"\"\"\n    Find the n'th Lucas number.\n\n    The Lucas numbers are a sequence of numbers in which each number is the sum of the two preceding ones.\n    The sequence starts with 2 and 1, so the 9th Lucas number is 76.\n\n    Parameters:\n    n (int): The index of the Lucas number to find.\n\n    Returns:\n    int: The n'th Lucas number.\n\n    Raises:\n    ValueError: If n is less than 0.\n\n    Examples:\n    >>> find_lucas(9)\n    76\n    >>> find_lucas(0)\n    2\n    >>> find_lucas(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be a non-negative integer.\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        lucas_nums = [2, 1]\n        for i in range(2, n + 1):\n            lucas_nums.append(lucas_nums[i - 1] + lucas_nums[i - 2])\n        return lucas_nums[n]\n\n# Test the function\nassert find_lucas(9) == 76"}
{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n\n    Parameters:\n    lst (list): The list of elements to apply the format string to.\n    format_str (str): The format string to apply.\n\n    Returns:\n    list: A new list with the format string applied to each element.\n\n    Examples:\n    >>> add_string([1,2,3,4],'temp{0}')\n    ['temp1', 'temp2', 'temp3', 'temp4']\n    \"\"\"\n    return [format_str.format(elem) for elem in lst]\n\n# Test the function\nassert add_string([1,2,3,4],'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values1, values2):\n    result = []\n    for i in range(len(keys)):\n        nested_dict = {keys[i]: {values1[i]: values2[i]}}\n        result.append(nested_dict)\n    return result\n\n# Test the function\nassert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    return max(get_max_sum(n/2) + get_max_sum(n/3) + get_max_sum(n/4) + get_max_sum(n/5), n)\n\n# Test the function\nassert get_max_sum(60) == 106"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(t):\n    \"\"\"\n    Check if given tuple contains no duplicates.\n\n    Parameters:\n    t (tuple): The input tuple.\n\n    Returns:\n    bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    return len(t) == len(set(t))\n\n# Test cases\nassert check_distinct((1, 4, 5, 6, 1, 4)) == False"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The first non-repeated character in the string, or None if there are no non-repeated characters.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None\n\n# Test cases\nassert first_non_repeating_character(\"abcabc\") == None"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    Find the median of three numbers.\n\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    c (float): The third number.\n\n    Returns:\n    float: The median of the three numbers.\n\n    \"\"\"\n    sorted_numbers = sorted([a, b, c])\n    median = sorted_numbers[1]\n    return median\n\n# Test the function\nassert median_numbers(25, 55, 65) == 55.0"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Compute the sum of digits of each number in a given list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    list: A list of integers representing the sum of digits of each number.\n\n    Examples:\n    >>> sum_of_digits([10, 2, 56])\n    [1, 2, 11]\n    >>> sum_of_digits([123, 456, 789])\n    [6, 15, 24]\n    \"\"\"\n    result = []\n    for number in numbers:\n        digit_sum = sum(int(digit) for digit in str(number))\n        result.append(digit_sum)\n    return result\n\n# Test the function\nassert sum_of_digits([10, 2, 56]) == [1, 2, 11]\nassert sum_of_digits([123, 456, 789]) == [6, 15, 24]"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the minimum of the two.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The minimum of the two input numbers.\n    \"\"\"\n    return min(a, b)\n\n# Test the function\nassert minimum(1, 2) == 1"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The input tuple.\n    element: The element to check for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex\n\n# Test the function\nassert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(num):\n    \"\"\"\n    This function takes a number as input and returns True if the parity of the number is odd, and False otherwise.\n\n    Parameters:\n    num (int): The number to check the parity.\n\n    Returns:\n    bool: True if the parity of the number is odd, False otherwise.\n    \"\"\"\n    return num % 2 != 0\n\n# Test the function\nassert find_Parity(12) == False"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(lst):\n    \"\"\"\n    Finds the minimum product from the pairs of tuples within a given list.\n\n    Parameters:\n    lst (list): A list of tuples.\n\n    Returns:\n    int: The minimum product of the pairs of tuples.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )\n    8\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    min_product = float('inf')\n    for pair in lst:\n        product = pair[0] * pair[1]\n        if product < min_product:\n            min_product = product\n\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    \"\"\"\n    Finds the minimum value in a given heterogeneous list.\n\n    Args:\n    lst (list): The list to search for the minimum value.\n\n    Returns:\n    The minimum value found in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n\n    Examples:\n    >>> min_val(['Python', 3, 2, 4, 5, 'version'])\n    2\n    >>> min_val([])\n    Traceback (most recent call last):\n    ...\n    ValueError: List is empty.\n    \"\"\"\n\n    if not lst:\n        raise ValueError(\"List is empty.\")\n\n    min_value = lst[0]\n    for item in lst:\n        if item < min_value:\n            min_value = item\n\n    return min_value"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(lst):\n    \"\"\"\n    Remove odd numbers from a given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    list: A new list with odd numbers removed.\n    \"\"\"\n    return [x for x in lst if x % 2 == 0]\n\n# Test the function\nassert remove_odd([1, 2, 3]) == [2]"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(lst, n):\n    \"\"\"\n    Extracts the nth element from a given list of tuples.\n\n    Args:\n    lst (list): A list of tuples.\n    n (int): The index of the element to extract.\n\n    Returns:\n    list: A list containing the nth element from each tuple in the input list.\n    \"\"\"\n    return [t[n] for t in lst]\n\n# Test the function\nassert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False\n\n# Test cases\nassert overlapping([1,2,3,4,5],[6,7,8,9]) == False\nassert overlapping([1,2,3,4,5],[5,6,7,8,9]) == True\nassert overlapping([1,2,3,4,5],[5,6,7,8,5]) == True\nassert overlapping([],[1,2,3,4,5]) == False\nassert overlapping([1,2,3,4,5],[]) == False"}
{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    \"\"\"\n    Finds a pair with the highest product from a given array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    tuple: A tuple containing the two integers with the highest product.\n\n    Raises:\n    ValueError: If the input list is empty or contains less than 2 elements.\n\n    Examples:\n    >>> max_Product([1,2,3,4,7,0,8,4])\n    (7, 8)\n    >>> max_Product([-1,-2,-3,-4,-7,0,-8,-4])\n    (-7, -8)\n    >>> max_Product([1,2,3,4,7,0,8,4])\n    (7, 8)\n    \"\"\"\n\n    if len(arr) < 2:\n        raise ValueError(\"Input list must contain at least 2 elements\")\n\n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    if max1 * max2 > min1 * min2:\n        return (max1, max2)\n    else:\n        return (min1, min2)"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    \"\"\"\n    Finds the element of a list with the maximum length.\n\n    Args:\n    lst (list): A list of lists.\n\n    Returns:\n    list: The element of the list with the maximum length.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> Find_Max([['A'],['A','B'],['A','B','C']])\n    ['A', 'B', 'C']\n    >>> Find_Max([])\n    Traceback (most recent call last):\n    ...\n    ValueError: Input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty.\")\n\n    max_length = max(len(sublist) for sublist in lst)\n    max_element = [sublist for sublist in lst if len(sublist) == max_length]\n\n    return max_element[0]"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(rounded_numbers)\n    return result\n\n# Test the function\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]) == 243"}
{"task_id": "Mbpp/420", "solution": "def cube_sum(n):\n    \"\"\"\n    Calculate the cube sum of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The cube sum of the first n even natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> cube_sum(2)\n    72\n    >>> cube_sum(3)\n    216\n    >>> cube_sum(0)\n    0\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return sum(i**3 for i in range(2, 2*n+1, 2))"}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string using a delimiter.\n\n    Parameters:\n    t (tuple): The input tuple.\n    delimiter (str, optional): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n    str: The concatenated string.\n\n    Examples:\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") )\n    'ID-is-4-UTS'\n    >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"), delimiter='_')\n    'ID_is_4_UTS'\n    \"\"\"\n    return delimiter.join(str(x) for x in t)\n\n# Test the function\nassert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of the cubes of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    float: The average of the cubes of the first n natural numbers.\n    \"\"\"\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    average = sum_of_cubes / n\n    return average\n\n# Test the function\nassert find_Average_Of_Cube(2) == 4.5"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Parameters:\n    tup (tuple): The input tuple containing strings.\n\n    Returns:\n    list: A list containing the rear index elements of the strings in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]\n\n# Test the function\nassert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in a list that contain a particular element.\n\n    Args:\n    lst (list): The input list.\n    element: The element to count.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n\n# Test the function\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    \"\"\"\n    Filter odd numbers from a list of numbers.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    list: A new list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]\n\n# Test the function\nassert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date):\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Parameters:\n    date (str): The date in yyyy-mm-dd format.\n\n    Returns:\n    str: The date in dd-mm-yyyy format.\n    \"\"\"\n    year, month, day = date.split('-')\n    return f\"{day}-{month}-{year}\"\n\n# Test the function\nassert change_date_format(\"2026-01-02\") == '02-01-2026'"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using shell sort algorithm.\n\n    Parameters:\n    arr (list): The array to be sorted.\n\n    Returns:\n    list: The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr\n\n# Test the function\nassert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    Extracts the elementwise and tuples from the given two tuples.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple containing the elementwise and of the input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> and_tuples((10, 4, 6, 9), (5, 2, 3, 3))\n        (0, 0, 2, 1)\n        >>> and_tuples((1, 2, 3), (4, 5, 6))\n        (0, 0, 2)\n        >>> and_tuples((1, 2, 3), (4, 5))\n        Traceback (most recent call last):\n        ...\n        ValueError: Input tuples must have the same length.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    return tuple(a & b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Find the directrix of a parabola.\n\n    Parameters:\n    a (float): The coefficient of x^2.\n    b (float): The coefficient of x.\n    c (float): The constant term.\n\n    Returns:\n    float: The y-coordinate of the directrix.\n\n    Raises:\n    ValueError: If the parabola does not have a directrix.\n\n    Examples:\n    >>> parabola_directrix(5, 3, 2)\n    -198.0\n    \"\"\"\n    if b**2 - 4*a*c < 0:\n        raise ValueError(\"The parabola does not have a directrix.\")\n    return -b**2 / (4*a)\n\n# Test the function\nassert parabola_directrix(5, 3, 2) == -198"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    \"\"\"\n    Calculate the median length of a trapezium.\n\n    Parameters:\n    a (float): Length of the parallel sides of the trapezium.\n    b (float): Length of the parallel sides of the trapezium.\n    c (float): Length of the non-parallel side of the trapezium.\n\n    Returns:\n    float: Median length of the trapezium.\n\n    Raises:\n    ValueError: If the given lengths do not form a valid trapezium.\n\n    \"\"\"\n    if a + b <= c or a + c <= b or b + c <= a:\n        raise ValueError(\"The given lengths do not form a valid trapezium.\")\n\n    median = (a + b - c) / 2\n    return median\n\n# Test the function\nassert median_trapezium(15, 25, 35) == 20"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if the number is greater than all the elements of the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True\n\n# Test cases\nassert check_greater([1, 2, 3, 4, 5], 4) == False\nassert check_greater([1, 2, 3, 4, 5], 6) == True\nassert check_greater([1, 2, 3, 4, 5], 0) == False\nassert check_greater([1, 2, 3, 4, 5], 5) == False\nassert check_greater([1, 2, 3, 4, 5], 10) == True"}
{"task_id": "Mbpp/435", "solution": "def last_digit(number):\n    \"\"\"\n    This function takes a number as input and returns the last digit of that number.\n\n    Parameters:\n    number (int): The input number.\n\n    Returns:\n    int: The last digit of the input number.\n    \"\"\"\n    return int(str(number)[-1])\n\n# Test the function\nassert last_digit(123) == 3"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    \"\"\"\n    Returns a list containing only the negative numbers from the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    list: A list containing only the negative numbers from the input list.\n    \"\"\"\n    return [num for num in lst if num < 0]\n\n# Test the function\nassert neg_nos([-1, 4, 5, -6]) == [-1, -6]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The string with odd characters removed.\n    \"\"\"\n    return ''.join([string[i] for i in range(len(string)) if i % 2 == 0])\n\n# Test the function\nassert remove_odd(\"python\") == \"yhn\""}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The joined integer.\n\n    Example:\n    >>> multiple_to_single([11, 33, 50])\n    113350\n    \"\"\"\n    return int(''.join(map(str, numbers)))\n\n# Test the function\nassert multiple_to_single([11, 33, 50]) == 113350"}
{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):\n    \"\"\"\n    Find the first adverb and their positions in a given sentence.\n\n    Parameters:\n    sentence (str): The input sentence.\n\n    Returns:\n    tuple: A tuple containing the start position, end position, and the adverb found.\n\n    Raises:\n    ValueError: If no adverb is found in the sentence.\n\n    Examples:\n    >>> find_adverb_position(\"clearly!! we can see the sky\")\n    (0, 7, 'clearly')\n    >>> find_adverb_position(\"I am walking on the street\")\n    (4, 11, 'walking')\n    >>> find_adverb_position(\"I have a big house\")\n    Traceback (most recent call last):\n        ...\n    ValueError: No adverb found in the sentence.\n    \"\"\"\n\n    adverbs = [\"very\", \"extremely\", \"quite\", \"fairly\", \"hardly\", \"rarely\", \"seldom\", \"occasionally\", \"often\", \"usually\", \"always\", \"never\", \"still\", \"yet\", \"just\", \"just about\", \"just enough\", \"just now\", \"just then\", \"just there\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just then\", \"just"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(size):\n    \"\"\"\n    Calculate the surface area of a cube of a given size.\n\n    Parameters:\n    size (int): The size of the cube.\n\n    Returns:\n    int: The surface area of the cube.\n\n    Raises:\n    ValueError: If the size is not a positive integer.\n\n    Examples:\n    >>> surfacearea_cube(5)\n    150\n    >>> surfacearea_cube(0)\n    0\n    >>> surfacearea_cube(-3)\n    Traceback (most recent call last):\n    ...\n    ValueError: Size must be a positive integer.\n    \"\"\"\n\n    if not isinstance(size, int) or size <= 0:\n        raise ValueError(\"Size must be a positive integer.\")\n\n    return 6 * size ** 2\n\n# Test the function\nassert surfacearea_cube(5) == 150"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    \"\"\"\n    Function to perform index wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A new tuple with the element-wise multiplication of the input tuples.\n\n    Raises:\n    ValueError: If the input tuples have different lengths.\n\n    Examples:\n    >>> index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) )\n    ((6, 21), (12, 45), (2, 9), (7, 30))\n    \"\"\"\n\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = []\n    for i in range(len(tuple1)):\n        result.append((tuple1[i][0] * tuple2[i][0], tuple1[i][1] * tuple2[i][1]))\n\n    return tuple(result)\n\n# Test the function\nassert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tuple_data, list_elements):\n    count = 0\n    for element in list_elements:\n        count += tuple_data.count(element)\n    return count\n\n# Test the function\nassert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b']) == 3"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    \"\"\"\n    Function to find cubes of individual elements in a list.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    list: A new list with cubes of individual elements.\n\n    \"\"\"\n    return [num ** 3 for num in nums]\n\n# Test the function\nassert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of the first n Perrin numbers.\n\n    Parameters:\n    n (int): The number of Perrin numbers to sum.\n\n    Returns:\n    int: The sum of the first n Perrin numbers.\n\n    Raises:\n    ValueError: If n is less than 0.\n\n    Examples:\n    >>> cal_sum(9)\n    49\n    >>> cal_sum(0)\n    0\n    >>> cal_sum(-5)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be a non-negative integer.\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    perrin_numbers = [3, 0, 2]\n    if n <= 2:\n        return sum(perrin_numbers[:n])\n\n    for i in range(3, n):\n        perrin_numbers.append(perrin_numbers[i-2] + perrin_numbers[i-3])\n\n    return sum(perrin_numbers)"}
{"task_id": "Mbpp/450", "solution": "def extract_string(string_list, size):\n    \"\"\"\n    Extracts strings of a specified size from a given list of string values.\n\n    Args:\n    string_list (list): A list of string values.\n    size (int): The desired size of the extracted strings.\n\n    Returns:\n    list: A list of strings of the specified size.\n\n    \"\"\"\n    return [s for s in string_list if len(s) == size]\n\n# Test the function\nassert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8) == ['practice', 'solution']"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return string.replace(\" \", \"\")\n\n# Test the function\nassert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"}
{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    \"\"\"\n    This function takes a number as input and returns the sum of all the even factors of that number.\n\n    Parameters:\n    n (int): The number for which the sum of even factors is to be calculated.\n\n    Returns:\n    int: The sum of all the even factors of the input number.\n    \"\"\"\n    sum_of_factors = 0\n    for i in range(1, n+1):\n        if n % i == 0 and i % 2 == 0:\n            sum_of_factors += i\n    return sum_of_factors\n\n# Test the function\nassert sumofFactors(18) == 26"}
{"task_id": "Mbpp/454", "solution": "import re\n\ndef text_match_wordz(text):\n    \"\"\"\n    Function to match a word containing 'z'.\n\n    Parameters:\n    text (str): The input text to be checked.\n\n    Returns:\n    bool: True if the word contains 'z', False otherwise.\n    \"\"\"\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n\n# Test the function\nassert text_match_wordz(\"pythonz.\")==True"}
{"task_id": "Mbpp/455", "solution": "def check_month_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 31 days or not.\n\n    Parameters:\n    month_number (int): The number of the month to be checked.\n\n    Returns:\n    bool: True if the month contains 31 days, False otherwise.\n    \"\"\"\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    elif month_number in [4, 6, 9, 11]:\n        return False\n    elif month_number == 2:\n        return False  # Assuming February does not have 31 days\n    else:\n        raise ValueError(\"Invalid month number\")\n\n# Test cases\nassert check_month_number(5) == True\nassert check_month_number(6) == False\nassert check_month_number(9) == False\nassert check_month_number(12) == True\nassert check_month_number(2) == False"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Parameters:\n    string_list (list): A list of string values.\n\n    Returns:\n    list: A new list with each string reversed.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\n\n# Test the function\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    \"\"\"\n    Finds the sublist with the minimum length in a given list of sublists.\n\n    Parameters:\n    lst (list): A list of sublists.\n\n    Returns:\n    list: The sublist with the minimum length.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> Find_Min([[1],[1,2],[1,2,3]])\n    [1]\n    >>> Find_Min([])\n    Traceback (most recent call last):\n    ...\n    ValueError: Input list cannot be empty.\n    \"\"\"\n\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    min_length = min(len(sublist) for sublist in lst)\n    return [sublist for sublist in lst if len(sublist) == min_length]"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    return length * width\n\n# Test the function\nassert rectangle_area(10, 20) == 200"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    \"\"\"\n    Removes uppercase substrings from a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with uppercase substrings removed.\n    \"\"\"\n    modified_string = \"\"\n    current_substring = \"\"\n\n    for char in string:\n        if char.isupper():\n            current_substring += char\n        else:\n            if current_substring.isupper():\n                current_substring = \"\"\n            else:\n                modified_string += current_substring\n                current_substring = \"\"\n                modified_string += char\n\n    modified_string += current_substring\n\n    return modified_string\n\n# Test the function\nassert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"}
{"task_id": "Mbpp/460", "solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]\n\ndef test_Extract():\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n"}
{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    def backtrack(start, path):\n        result.append(path)\n        for i in range(start, len(lst)):\n            backtrack(i + 1, path + [lst[i]])\n\n    result = []\n    backtrack(0, [])\n    return result\n\n# Test the function\nassert combinations_list(['orange', 'red', 'green', 'blue']) == [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    \"\"\"\n    Finds the maximum product subarray of the given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum product of a subarray.\n\n    Examples:\n    >>> max_subarray_product([1, -2, -3, 0, 7, -8, -2])\n    112\n    \"\"\"\n\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n\n    for num in arr[1:]:\n        if num < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n\n        max_so_far = max(num, max_so_far * num)\n        min_so_far = min(num, min_so_far * num)\n\n        max_product = max(max_product, max_so_far)\n\n    return max_product"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    \"\"\"\n    Drop empty items from a given dictionary.\n\n    Args:\n    dictionary (dict): The input dictionary.\n\n    Returns:\n    dict: The modified dictionary with empty items removed.\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}\n\n# Test the function\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}"}
{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    \"\"\"\n    Finds the maximum product formed by multiplying numbers of an increasing subsequence of the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum product.\n\n    Raises:\n    ValueError: If the input array is empty.\n\n    Examples:\n    >>> max_product([3, 100, 4, 5, 150, 6])\n    3000\n    >>> max_product([1, 2, 3, 4, 5])\n    60\n    >>> max_product([5, 4, 3, 2, 1])\n    60\n    >>> max_product([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input array cannot be empty.\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n\n    max_prod = arr[0]\n    curr_prod = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            curr_prod *= arr[i]\n        else:\n            curr_prod = arr[i]\n\n        max_prod = max(max_prod, curr_prod)\n\n    return max_prod"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(t):\n    \"\"\"\n    Function to find the pairwise addition of neighboring elements of the given tuple.\n\n    Parameters:\n    t (tuple): The input tuple.\n\n    Returns:\n    tuple: The tuple with pairwise addition of neighboring elements.\n\n    Raises:\n    ValueError: If the input is not a tuple.\n\n    Examples:\n    >>> add_pairwise((1, 5, 7, 8, 10))\n    (6, 12, 15, 18)\n    >>> add_pairwise(())\n    ()\n    >>> add_pairwise((1,))\n    Traceback (most recent call last):\n    ...\n    ValueError: Input tuple must have at least 2 elements.\n    \"\"\"\n\n    if not isinstance(t, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    if len(t) < 2:\n        raise ValueError(\"Input tuple must have at least 2 elements.\")\n\n    return tuple(t[i] + t[i+1] for i in range(len(t)-1))"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    Finds the product of the array multiplication modulo n.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The modulo value.\n\n    Returns:\n    int: The product of the array multiplication modulo n.\n\n    Raises:\n    ValueError: If the modulo value is 0 or negative.\n\n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([1, 2, 3, 4, 5], 10)\n    0\n    >>> find_remainder([], 7)\n    1\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"Modulo value should be positive.\")\n\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n\n    return product"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    \"\"\"\n    Check whether the given list contains consecutive numbers or not.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    sorted_lst = sorted(lst)\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i+1] - sorted_lst[i] != 1:\n            return False\n    return True\n\n# Test the function\nassert check_Consecutive([1,2,3,4,5]) == True"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(tuple_list1, tuple_list2):\n    intersection = set()\n    for tuple1 in tuple_list1:\n        for tuple2 in tuple_list2:\n            if set(tuple1) == set(tuple2):\n                intersection.add(tuple1)\n    return intersection\n\n# Test the function\nassert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}"}
{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a given character in a string with a new character.\n\n    Parameters:\n    string (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return string.replace(old_char, new_char)\n\n# Test the function\nassert replace_char(\"polygon\",'y','l')==(\"pollgon\")"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    \"\"\"\n    Sorts a dictionary by value in descending order and returns a list of key-value pairs.\n\n    Args:\n    dictionary (dict): The dictionary to be sorted.\n\n    Returns:\n    list: A list of tuples, where each tuple contains a key-value pair from the dictionary, sorted in descending order by value.\n    \"\"\"\n    sorted_list = sorted(dictionary.items(), key=lambda x: x[1], reverse=True)\n    return sorted_list\n\n# Test the function\nassert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([-1, 0, 1])\n    0\n    >>> big_sum([])\n    Traceback (most recent call last):\n    ...\n    ValueError: Input array cannot be empty.\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n\n    min_val = min(arr)\n    max_val = max(arr)\n    return min_val + max_val"}
{"task_id": "Mbpp/477", "solution": "def convert_to_lower(string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    string (str): The string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return string.lower()\n\n# Test the function\ndef test_convert_to_lower():\n    assert convert_to_lower(\"InValid\") == \"invalid\"\n\n# Run the tests\ntest_convert_to_lower()"}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    \"\"\"\n    Remove lowercase substrings from a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with lowercase substrings removed.\n    \"\"\"\n    result = \"\"\n    i = 0\n    while i < len(string):\n        if string[i].islower():\n            i += 1\n        else:\n            result += string[i]\n            i += 1\n    return result\n\n# Test the function\nassert remove_lowercase(\"PYTHon\") == \"PYTH\""}
{"task_id": "Mbpp/479", "solution": "def first_digit(number):\n    \"\"\"\n    This function takes a number as input and returns the first digit of that number.\n\n    Parameters:\n    number (int): The input number.\n\n    Returns:\n    int: The first digit of the input number.\n    \"\"\"\n    # Convert the number to a string to access its first character\n    number_str = str(number)\n\n    # Return the first character as an integer\n    return int(number_str[0])\n\n# Test the function\nassert first_digit(123) == 1"}
{"task_id": "Mbpp/554", "solution": "def split_odd(lst):\n    \"\"\"\n    This function takes a list of integers and returns a new list containing only the odd numbers from the original list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    list: A new list containing only the odd numbers from the original list.\n    \"\"\"\n    return [num for num in lst if num % 2 != 0]\n\n# Test the function\nassert split_odd([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    \"\"\"\n    Calculate the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    int: The difference between the sum of cubes and the sum of the first n natural numbers.\n    \"\"\"\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(i for i in range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n\n# Test the function\nassert difference(3) == 30"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] ^ arr[j]) % 2 != 0:\n                count += 1\n    return count\n\n# Test the function\nassert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    \"\"\"\n    Toggle the case of all characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The string with toggled case.\n    \"\"\"\n    toggled_string = \"\"\n    for char in string:\n        if char.islower():\n            toggled_string += char.upper()\n        else:\n            toggled_string += char.lower()\n    return toggled_string\n\n# Test the function\nassert toggle_string(\"Python\") == \"pYTHON\""}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculates the sum of the per-digit difference between two integers.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    int: The sum of the per-digit difference between num1 and num2.\n    \"\"\"\n    # Convert the integers to strings to access their digits\n    str1 = str(num1)\n    str2 = str(num2)\n\n    # Find the length of the longer string\n    length = max(len(str1), len(str2))\n\n    # Pad the shorter string with leading zeros to match the length of the longer string\n    str1 = str1.zfill(length)\n    str2 = str2.zfill(length)\n\n    # Calculate the sum of the per-digit difference\n    diff_sum = 0\n    for i in range(length):\n        diff_sum += abs(int(str1[i]) - int(str2[i]))\n\n    return diff_sum\n\n# Test the function\nassert digit_distance_nums(1, 2) == 1"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for i in range(n):\n        curr_sum += arr[i]\n\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum\n\n# Test the function\nassert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    \"\"\"\n    Finds the union of the elements of two given tuples and outputs them in sorted order.\n\n    Args:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A new tuple containing the union of elements from tuple1 and tuple2, sorted in ascending order.\n    \"\"\"\n    union = tuple1 + tuple2  # Concatenate the two input tuples\n    union = tuple(sorted(set(union)))  # Remove duplicates and sort the elements\n    return union\n\n# Test the function\nassert union_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 4, 5, 6, 7, 10)"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(sublists):\n    \"\"\"\n    Finds the length of the longest sublist in a list of sublists.\n\n    Args:\n    sublists (list): A list of sublists.\n\n    Returns:\n    int: The length of the longest sublist.\n\n    \"\"\"\n    max_length = 0\n    for sublist in sublists:\n        max_length = max(max_length, len(sublist))\n    return max_length\n\n# Test the function\nassert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4"}
{"task_id": "Mbpp/563", "solution": "def extract_values(string):\n    values = []\n    start = 0\n    while start < len(string):\n        if string[start] == '\"':\n            end = start + 1\n            while end < len(string) and string[end] != '\"':\n                end += 1\n            values.append(string[start+1:end])\n            start = end + 1\n        else:\n            start += 1\n    return values\n\n# Test the function\nassert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"}
{"task_id": "Mbpp/564", "solution": "def count_Pairs(lst, n):\n    \"\"\"\n    This function takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\n    Parameters:\n    lst (list): A list of integers.\n    n (int): The length of the list.\n\n    Returns:\n    int: The number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i] != lst[j]:\n                count += 1\n    return count\n\n# Test the function\nassert count_Pairs([1, 2, 1], 3) == 2"}
{"task_id": "Mbpp/565", "solution": "def split(string):\n    \"\"\"\n    Split a string into characters.\n\n    Parameters:\n    string (str): The input string to be split.\n\n    Returns:\n    list: A list containing the characters of the input string.\n    \"\"\"\n    return list(string)\n\n# Test the function\nassert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): The non-negative integer.\n\n    Returns:\n    int: The sum of the digits.\n\n    Raises:\n    ValueError: If the input is a negative integer.\n\n    Examples:\n    >>> sum_digits(345)\n    12\n    >>> sum_digits(0)\n    0\n    >>> sum_digits(12345)\n    15\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    return sum(int(digit) for digit in str(n))"}
{"task_id": "Mbpp/567", "solution": "def is_sorted_list(lst):\n    \"\"\"\n    Check whether a specified list is sorted or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\n# Test the function\nassert is_sorted_list([1,2,4,6,8,10,12,14,16,17]) == True"}
{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Parameters:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(n)]\n\n# Test the function\nassert empty_list(5) == [{}, {}, {}, {}, {}]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n    lst (list): A list of lists, where each sublist contains strings.\n\n    Returns:\n    list: A new list with each sublist sorted in alphabetical order.\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]\n\n# Test the function\nassert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"}
{"task_id": "Mbpp/572", "solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums\n\n# Test the function\nassert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]"}
{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    unique_numbers = set(numbers)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product\n\n# Test the function\nassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"}
{"task_id": "Mbpp/576", "solution": "def is_sub_array(arr, sub_arr):\n    \"\"\"\n    Check whether a list is a sublist of another.\n\n    Parameters:\n    arr (list): The main list.\n    sub_arr (list): The sublist to check.\n\n    Returns:\n    bool: True if sub_arr is a sublist of arr, False otherwise.\n    \"\"\"\n    if len(sub_arr) > len(arr):\n        return False\n\n    for i in range(len(arr) - len(sub_arr) + 1):\n        if arr[i:i+len(sub_arr)] == sub_arr:\n            return True\n\n    return False\n\n# Test cases\nassert is_sub_array([1, 4, 3, 5], [1, 2]) == False\nassert is_sub_array([1, 2, 3, 4, 5], [2, 3]) == True\nassert is_sub_array([1, 2, 3, 4, 5], [6, 7]) == False\nassert is_sub_array([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == True\nassert is_sub_array([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]) == False"}
{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    Calculate the last digit in the factorial of a given number.\n\n    Parameters:\n    n (int): The number for which to calculate the last digit in the factorial.\n\n    Returns:\n    int: The last digit in the factorial of the given number.\n\n    Raises:\n    ValueError: If the input number is negative.\n\n    Examples:\n    >>> last_digit_factorial(4)\n    4\n    >>> last_digit_factorial(10)\n    4\n    >>> last_digit_factorial(0)\n    1\n    >>> last_digit_factorial(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input number cannot be negative.\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"Input number cannot be negative.\")\n\n    if n == 0:\n        return 1\n\n    last_digit = 1\n    for i in range(1, n + 1):\n        last_digit = (last_digit * i) % 10\n\n    return last_digit"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves 3 lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n\n    Returns:\n    list: A flat list containing the elements of the input lists interleaved.\n\n    Raises:\n    ValueError: If the input lists are not of the same length.\n\n    Examples:\n    >>> interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])\n    [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    \"\"\"\n\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n\n    Parameters:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A tuple containing the dissimilar elements from both input tuples.\n\n    Examples:\n    >>> find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10))\n    (3, 6, 7, 10)\n    \"\"\"\n    dissimilar_elements = []\n    for element in tuple1:\n        if element not in tuple2:\n            dissimilar_elements.append(element)\n    for element in tuple2:\n        if element not in tuple1:\n            dissimilar_elements.append(element)\n    return tuple(dissimilar_elements)\n\n# Test the function\nassert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"}
{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    \"\"\"\n    Extracts even elements from a nested mixed tuple.\n\n    Args:\n        nested_tuple (tuple): The nested mixed tuple.\n\n    Returns:\n        tuple: The nested mixed tuple with uneven elements removed.\n    \"\"\"\n    def is_even(num):\n        return num % 2 == 0\n\n    def extract_even_helper(nested_tuple):\n        result = []\n        for item in nested_tuple:\n            if isinstance(item, tuple):\n                result.append(extract_even_helper(item))\n            elif is_even(item):\n                result.append(item)\n        return tuple(result)\n\n    return extract_even_helper(nested_tuple)\n\n# Test the function\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"}
{"task_id": "Mbpp/581", "solution": "def surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    Parameters:\n    base_edge (float): The length of the base edge of the square pyramid.\n    height (float): The height of the square pyramid.\n\n    Returns:\n    float: The surface area of the square pyramid.\n\n    Raises:\n    ValueError: If base_edge or height is not a positive number.\n\n    Examples:\n    >>> surface_area(3, 4)\n    33.0\n    >>> surface_area(5, 0)\n    10.0\n    >>> surface_area(0, 5)\n    0.0\n    >>> surface_area(-3, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Base edge and height must be positive numbers.\n    >>> surface_area(3, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Base edge and height must be positive numbers.\n    \"\"\"\n    if base_edge <= 0 or height <= 0:\n        raise ValueError(\"Base edge and height must be positive numbers.\")\n\n    base_area = base_edge ** 2\n    lateral_area = 4 * (base_edge ** 2) / (2 * base_edge)\n    surface_area = base_area + lateral_area\n    return surface_area"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Returns the nth Catalan number.\n\n    Parameters:\n    n (int): The index of the Catalan number to be calculated.\n\n    Returns:\n    int: The nth Catalan number.\n\n    Raises:\n    ValueError: If n is a negative integer.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n\n    for i in range(1, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\n# Test the function\nassert catalan_number(10) == 16796"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(dataset, n):\n    sorted_dataset = sorted(dataset, key=lambda x: x['price'], reverse=True)\n    return sorted_dataset[:n]\n\n# Test the function\nassert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The input list to be split.\n    n (int): The index at which the list should be split.\n\n    Returns:\n    list: The modified list with the first part added to the end.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36],2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    return arr[n:] + arr[:n]\n\n# Testing the function\nassert split_Arr([12,10,5,6,52,36],2) == [5,6,52,36,12,10]"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)\n\n# Test the function\nassert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(numbers):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not numbers:\n        return 0\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return max_num - min_num\n\n# Test cases\nassert big_diff([1, 2, 3, 4]) == 3\nassert big_diff([10, 20, 30, 40]) == 30\nassert big_diff([5, 5, 5, 5]) == 0\nassert big_diff([-1, 10, 5, 15]) == 20\nassert big_diff([-5, -10, -15, -20]) == -15"}
{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    \"\"\"\n    Finds perfect squares between two given numbers.\n\n    Parameters:\n    start (int): The starting number.\n    end (int): The ending number.\n\n    Returns:\n    list: A list of perfect squares between the given numbers.\n    \"\"\"\n    perfect_squares_list = []\n    for num in range(start, end+1):\n        if is_perfect_square(num):\n            perfect_squares_list.append(num)\n    return perfect_squares_list\n\ndef is_perfect_square(num):\n    \"\"\"\n    Checks if a number is a perfect square.\n\n    Parameters:\n    num (int): The number to check.\n\n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    square_root = int(num ** 0.5)\n    return square_root ** 2 == num\n\n# Test the function\nassert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"}
{"task_id": "Mbpp/590", "solution": "import math\n\ndef polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y), (r, math.cos(theta) + 1j * math.sin(theta))\n\n# Test the function\nassert polar_rect(3, 4) == ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))"}
{"task_id": "Mbpp/591", "solution": "def swap_list(lst):\n    \"\"\"\n    Swaps the first and last elements in a list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: The modified list with the first and last elements swapped.\n    \"\"\"\n    if len(lst) < 2:\n        return lst\n    else:\n        lst[0], lst[-1] = lst[-1], lst[0]\n        return lst\n\n# Test the function\nassert swap_list([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"}
{"task_id": "Mbpp/592", "solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The number of terms in the sum.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> sum_Of_product(3)\n    15\n    >>> sum_Of_product(5)\n    125\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    if n == 1:\n        return 1\n\n    result = 1\n    for i in range(1, n):\n        result += i * (i + 1)\n\n    return result"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    \"\"\"\n    Remove leading zeroes from an IP address.\n\n    Parameters:\n    ip_address (str): The IP address to remove leading zeroes from.\n\n    Returns:\n    str: The IP address with leading zeroes removed.\n    \"\"\"\n    octets = ip_address.split('.')\n    new_octets = [str(int(octet)) for octet in octets]\n    return '.'.join(new_octets)\n\n# Test the function\nassert removezero_ip(\"216.08.094.196\") == '216.8.94.196'"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    \"\"\"\n    Finds the difference of the first even and first odd number of a given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The difference between the first even and first odd number.\n\n    Raises:\n    ValueError: If the list does not contain any even or odd numbers.\n\n    Examples:\n    >>> diff_even_odd([1,3,5,7,4,1,6,8])\n    3\n    >>> diff_even_odd([2,4,6,8])\n    0\n    >>> diff_even_odd([1,3,5,7])\n    Traceback (most recent call last):\n        ...\n    ValueError: List does not contain any even or odd numbers.\n    \"\"\"\n\n    even_num = None\n    odd_num = None\n\n    for num in lst:\n        if num % 2 == 0:\n            even_num = num\n            break\n        elif num % 2 != 0:\n            odd_num = num\n            break\n\n    if even_num is None or odd_num is None:\n        raise ValueError(\"List does not contain any even or odd numbers.\")\n\n    return even_num - odd_num"}
{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(t):\n    return sys.getsizeof(t)\n\n# Test the function\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n\n    Parameters:\n    arr1 (list): The first sorted array.\n    arr2 (list): The second sorted array.\n    k (int): The index of the element to find.\n\n    Returns:\n    int: The kth element from the merged sorted array.\n\n    Raises:\n    ValueError: If k is out of range for the given arrays.\n\n    Examples:\n    >>> find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5)\n    6\n    >>> find_kth([1, 2, 3], [4, 5, 6], 2)\n    3\n    >>> find_kth([1, 2, 3], [4, 5, 6], 7)\n    Traceback (most recent call last):\n        ...\n    ValueError: k is out of range for the given arrays.\n    \"\"\"\n\n    merged_arr = sorted(arr1 + arr2)\n\n    if k < 1 or k > len(merged_arr):\n        raise ValueError(\"k is out of range for the given arrays.\")\n\n    return merged_arr[k - 1]"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\n    \"\"\"\n    Check whether the given number is an Armstrong number.\n\n    An Armstrong number is a number that is equal to the sum of its digits raised to the power of the number of digits.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is an Armstrong number, False otherwise.\n    \"\"\"\n    # Convert the number to a string to count the number of digits\n    num_str = str(num)\n    num_digits = len(num_str)\n\n    # Calculate the sum of the digits raised to the power of the number of digits\n    digit_sum = sum(int(digit) ** num_digits for digit in num_str)\n\n    # Check if the sum is equal to the original number\n    return digit_sum == num\n\n# Test the function\nassert armstrong_number(153) == True"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> sum_average(10)\n    (55, 5.5)\n    >>> sum_average(0)\n    (0, 0.0)\n    >>> sum_average(-5)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    sum_of_numbers = n * (n + 1) // 2\n    average = sum_of_numbers / n\n    return sum_of_numbers, average"}
{"task_id": "Mbpp/600", "solution": "def is_Even(num):\n    \"\"\"\n    Check whether the given number is even or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is even, False otherwise.\n    \"\"\"\n    return num % 2 == 0\n\n# Test cases\nassert is_Even(1) == False"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(string):\n    \"\"\"\n    Find the first repeated character in a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The first repeated character in the string, or None if no repeated character is found.\n    \"\"\"\n    char_set = set()\n    for char in string:\n        if char in char_set:\n            return char\n        char_set.add(char)\n    return None\n\n# Test the function\nassert first_repeated_char(\"abcabc\") == \"a\""}
{"task_id": "Mbpp/603", "solution": "def get_lucid(n):\n    \"\"\"\n    Get all lucid numbers smaller than or equal to a given integer.\n\n    Parameters:\n    n (int): The given integer.\n\n    Returns:\n    list: A list of all lucid numbers smaller than or equal to n.\n    \"\"\"\n    def is_lucid(num):\n        \"\"\"\n        Check if a number is a lucid number.\n\n        Parameters:\n        num (int): The number to check.\n\n        Returns:\n        bool: True if the number is a lucid number, False otherwise.\n        \"\"\"\n        if num == 1:\n            return True\n        if num % 2 == 0:\n            return False\n        while num > 1:\n            if num % 2 == 0:\n                return False\n            num = (num - 1) / 2\n        return True\n\n    lucid_numbers = []\n    for i in range(1, n+1):\n        if is_lucid(i):\n            lucid_numbers.append(i)\n    return lucid_numbers\n\n# Test the function\nassert get_lucid(10) == [1, 2, 3, 5, 7]"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    \"\"\"\n    Reverse the order of words in a given string.\n\n    Parameters:\n    string (str): The input string containing words seperated by spaces.\n\n    Returns:\n    str: The string with the words in reverse order.\n    \"\"\"\n    words = string.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\n# Test the function\nassert reverse_words(\"python program\") == \"program python\""}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    \"\"\"\n    Check if the given integer is a prime number.\n\n    Parameters:\n    n (int): The integer to be checked.\n\n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n# Test the function\nassert prime_num(13) == True"}
{"task_id": "Mbpp/606", "solution": "import math\n\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n\n    Parameters:\n    degrees (float): The angle in degrees.\n\n    Returns:\n    float: The angle in radians.\n    \"\"\"\n    return degrees * math.pi / 180\n\n# Test the function\nassert radian_degree(90) == 1.5707963267948966"}
{"task_id": "Mbpp/607", "solution": "import re\n\ndef find_literals(string, pattern):\n    match = re.search(pattern, string)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None, None, None\n\n# Test the function\nassert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    \"\"\"\n    This function calculates the nth Bell number.\n\n    Parameters:\n    n (int): The index of the Bell number to calculate.\n\n    Returns:\n    int: The nth Bell number.\n\n    Raises:\n    ValueError: If n is less than 0.\n\n    Examples:\n    >>> bell_Number(2)\n    2\n    >>> bell_Number(5)\n    15\n    >>> bell_Number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a non-negative integer.\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n\n    return bell[n][0]"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    This function takes a list and returns a list with the same elements, but the k'th element removed.\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The index of the element to be removed.\n\n    Returns:\n    list: The modified list with the k'th element removed.\n    \"\"\"\n    return lst[:k] + lst[k+1:]\n\n# Test the function\nassert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n'th column of a matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column to find the maximum value in.\n\n    Returns:\n    int or float: The maximum value in the n'th column of the matrix.\n\n    Raises:\n    ValueError: If the matrix is empty or if n is out of range.\n\n    Examples:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    >>> max_of_nth([[1, 2, 3], [4, 5, 6]], 0)\n    4\n    >>> max_of_nth([[1, 2, 3], [4, 5, 6]], 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Column index is out of range\n    >>> max_of_nth([], 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Matrix is empty\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"Matrix is empty\")\n\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n\n    if n < 0 or n >= num_cols:\n        raise ValueError(\"Column index is out of range\")\n\n    max_value = float('-inf')\n    for row in matrix:\n        max_value = max(max_value, row[n])\n\n    return max_value"}
{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    \"\"\"\n    Merge a list of lists into two lists where the first list contains the first element of each sublist, and the second list contains the second element.\n\n    Args:\n    lst (list): A list of lists, where each sublist has two elements.\n\n    Returns:\n    list: A list of two lists where the first list contains the first element of each sublist, and the second list contains the second element.\n    \"\"\"\n    first_list = [sublist[0] for sublist in lst]\n    second_list = [sublist[1] for sublist in lst]\n    return [first_list, second_list]\n\n# Test the function\nassert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    total_sum = 0\n    for tup in tuple_list:\n        total_sum += sum(tup)\n    return total_sum\n\n# Test the function\nassert cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    averages = []\n    for tuple_ in tuples:\n        average = sum(tuple_) / len(tuple_)\n        averages.append(average)\n    return averages\n\n# Test the function\nassert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(t1, t2):\n    \"\"\"\n    This function takes two tuples of the same length and performs the element wise modulo.\n\n    Parameters:\n    t1 (tuple): The first input tuple.\n    t2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A new tuple containing the element-wise modulo of t1 and t2.\n\n    Raises:\n    ValueError: If the input tuples have different lengths.\n\n    Examples:\n    >>> tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5))\n    (0, 4, 5, 1)\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    return tuple(a % b for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divides two lists element-wise.\n\n    Args:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n\n    Returns:\n    list: A new list containing the element-wise division of list1 by list2.\n\n    Raises:\n    ValueError: If the lengths of list1 and list2 are not equal.\n\n    Examples:\n    >>> div_list([4,5,6],[1, 2, 3])\n    [4.0, 2.5, 2.0]\n    >>> div_list([1,2,3],[0, 0, 0])\n    [0.0, 0.0, 0.0]\n    >>> div_list([1,2,3],[2, 0, 4])\n    [0.5, 0.0, 0.75]\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"The lengths of list1 and list2 must be equal.\")\n\n    return [x / y for x, y in zip(list1, list2)]"}
{"task_id": "Mbpp/619", "solution": "def move_num(string):\n    num_string = ''\n    char_string = ''\n    for char in string:\n        if char.isdigit():\n            num_string += char\n        else:\n            char_string += char\n    return char_string + num_string\n\n# Test the function\nassert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    \"\"\"\n    Finds the size of the largest subset of a list of numbers where every pair is divisible.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The size of the largest subset where every pair is divisible.\n\n    \"\"\"\n\n    def is_divisible(a, b):\n        \"\"\"\n        Checks if two numbers are divisible.\n\n        Parameters:\n        a (int): The first number.\n        b (int): The second number.\n\n        Returns:\n        bool: True if the numbers are divisible, False otherwise.\n\n        \"\"\"\n        return a % b == 0 or b % a == 0\n\n    def find_subset(start, subset):\n        \"\"\"\n        Recursive function to find the largest subset where every pair is divisible.\n\n        Parameters:\n        start (int): The index to start the recursion.\n        subset (list): The current subset being considered.\n\n        Returns:\n        int: The size of the largest subset where every pair is divisible.\n\n        \"\"\"\n        max_subset_size = len(subset)\n\n        for i in range(start, len(numbers)):\n            if all(is_divisible(numbers[i], num) for num in subset):\n                max_subset_size = max(max_subset_size, find_subset(i + 1, subset + [numbers[i]]))\n\n        return max_subset_size\n\n    return find_subset(0, [])\n\n# Test the function\nassert largest_subset([1, 3, 6, 13, 17, 18]) == 4"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, n):\n    \"\"\"\n    Finds the median of two sorted lists of same size.\n\n    Parameters:\n    list1 (list): The first sorted list.\n    list2 (list): The second sorted list.\n    n (int): The size of the lists.\n\n    Returns:\n    float: The median of the two sorted lists.\n\n    Raises:\n    ValueError: If the size of the lists is not the same.\n\n    Examples:\n    >>> get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5)\n    16.0\n    \"\"\"\n    if len(list1) != n or len(list2) != n:\n        raise ValueError(\"The size of the lists is not the same.\")\n\n    merged_list = sorted(list1 + list2)\n    mid = n // 2\n\n    if n % 2 == 0:\n        median = (merged_list[mid - 1] + merged_list[mid]) / 2\n    else:\n        median = merged_list[mid]\n\n    return median"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(numbers, n):\n    \"\"\"\n    Compute the n-th power of each number in a list.\n\n    Parameters:\n    numbers (list): A list of numbers.\n    n (int): The power to raise each number to.\n\n    Returns:\n    list: A new list with the n-th power of each number.\n\n    \"\"\"\n    return [num ** n for num in numbers]\n\n# Test the function\nassert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "Mbpp/624", "solution": "def convert_to_uppercase(string):\n    \"\"\"\n    Convert a given string to uppercase.\n\n    Parameters:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The uppercase version of the input string.\n    \"\"\"\n    return string.upper()\n\n# Test the function\ndef test_convert_to_uppercase():\n    assert convert_to_uppercase(\"person\") == \"PERSON\"\n\n# Run the tests\ntest_convert_to_uppercase()"}
{"task_id": "Mbpp/626", "solution": "import math\n\ndef triangle_area(radius):\n    if radius < 0:\n        return None\n    else:\n        base = 2 * radius\n        height = math.sqrt(radius**2 - (base/2)**2)\n        area = 0.5 * base * height\n        return area\n\n# Test cases\nassert triangle_area(-1) == None\nassert triangle_area(0) == 0\nassert triangle_area(1) == 1.5707963267948966\nassert triangle_area(2) == 6.283185307179586\nassert triangle_area(3) == 12.566370614359172"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces all spaces in the given string with '%20'.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with spaces replaced by '%20'.\n    \"\"\"\n    return string.replace(' ', '%20')\n\n# Test the function\nassert replace_spaces(\"My Name is Dawood\") == 'My%20Name%20is%20Dawood'"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    Find even numbers from a list of numbers.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    list: A list of even numbers.\n    \"\"\"\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return even_numbers\n\n# Test the function\nassert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coordinate):\n    x, y = coordinate\n    adjacent_coordinates = []\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            if (i, j) != coordinate:\n                adjacent_coordinates.append([i, j])\n    return adjacent_coordinates\n\n# Test the function\nassert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with whitespaces replaced.\n    \"\"\"\n    modified_string = string.replace(\" \", \"_\")\n    return modified_string\n\n# Test the function\nassert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"}
{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list to store the non-zero elements\n    new_lst = [num for num in lst if num != 0]\n\n    # Append the required number of zeroes to the new list\n    new_lst.extend([0] * lst.count(0))\n\n    return new_lst\n\n# Test the function\nassert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n\n    Parameters:\n    nums (list): A list of integers.\n    n (int): The length of the list.\n\n    Returns:\n    int: The sum of XOR of all pairs of numbers.\n\n    Examples:\n    >>> pair_xor_Sum([5,9,7,6],4)\n    47\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum\n\n# Test the function\nassert pair_xor_Sum([5,9,7,6],4) == 47"}
{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < n and arr[i] < arr[l]:\n            largest = l\n\n        if r < n and arr[largest] < arr[r]:\n            largest = r\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr\n\n# Test the function\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(amount, expected_amount):\n    \"\"\"\n    Check whether the given amount has no profit and no loss.\n\n    Parameters:\n    amount (float): The actual amount.\n    expected_amount (float): The expected amount.\n\n    Returns:\n    bool: True if the amount has no profit and no loss, False otherwise.\n    \"\"\"\n    return amount == expected_amount\n\n# Test the function\nassert noprofit_noloss(1500, 1200) == False"}
{"task_id": "Mbpp/638", "solution": "def wind_chill(wind_velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Parameters:\n    wind_velocity (float): The wind velocity in km/h.\n    temperature (float): The temperature in celsius.\n\n    Returns:\n    int: The wind chill index rounded to the next integer.\n\n    Raises:\n    ValueError: If the wind velocity is greater than 150 km/h or the temperature is less than -40\u00b0C or greater than 50\u00b0C.\n\n    \"\"\"\n\n    if wind_velocity > 150 or temperature < -40 or temperature > 50:\n        raise ValueError(\"Invalid input. Wind velocity must be less than or equal to 150 km/h and temperature must be between -40\u00b0C and 50\u00b0C.\")\n\n    wind_chill_index = 13.12 + (0.6215 * temperature) - (11.37 * (wind_velocity ** 0.16)) + (0.3965 * temperature * (wind_velocity ** 0.16))\n    return round(wind_chill_index)\n\n# Test the function\nassert wind_chill(120, 35) == 40"}
{"task_id": "Mbpp/639", "solution": "def sum_name_lengths(names):\n    \"\"\"\n    Sum the length of the names in the given list after removing the names that start with a lowercase letter.\n\n    Args:\n    names (list): A list of names.\n\n    Returns:\n    int: The sum of the lengths of the remaining names.\n    \"\"\"\n    # Filter out names that start with a lowercase letter\n    filtered_names = [name for name in names if not name[0].islower()]\n\n    # Calculate the sum of the lengths of the remaining names\n    sum_lengths = sum(len(name) for name in filtered_names)\n\n    return sum_lengths\n\n# Test the function\nassert sum_name_lengths(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Find the nth nonagonal number.\n\n    Parameters:\n    n (int): The position of the nonagonal number to find.\n\n    Returns:\n    int: The nth nonagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> is_nonagonal(1)\n    1\n    >>> is_nonagonal(2)\n    11\n    >>> is_nonagonal(3)\n    32\n    >>> is_nonagonal(4)\n    66\n    >>> is_nonagonal(5)\n    115\n    >>> is_nonagonal(6)\n    181\n    >>> is_nonagonal(7)\n    266\n    >>> is_nonagonal(8)\n    372\n    >>> is_nonagonal(9)\n    501\n    >>> is_nonagonal(10)\n    655\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return n * (7 * n - 5) // 2\n\n# Test the function\nassert is_nonagonal(1) == 1\nassert is_nonagonal(2) == 11\nassert is_nonagonal(3) == 32\nassert is_nonagonal(4) == 66\nassert is_nonagonal(5) == 115\nassert is_nonagonal(6) == 181\nassert is_nonagonal(7) == 266\nassert is_nonagonal(8) == 372\nassert is_nonagonal(9) == 501\nassert is_nonagonal(10) == 655"}
{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(text):\n    \"\"\"\n    Check if a string contains 'z' except at the start and end of the word.\n\n    Parameters:\n    text (str): The input string to check.\n\n    Returns:\n    bool: True if the string contains 'z' except at the start and end of the word, False otherwise.\n    \"\"\"\n    words = text.split()\n    for word in words:\n        if len(word) > 1 and word[0] != 'z' and word[-1] != 'z' and 'z' in word[1:-1]:\n            return True\n    return False\n\n# Test cases\nassert text_match_wordz_middle(\"pythonzabc.\")==True"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array upto a given position.\n\n    Parameters:\n    arr (list): The input list of integers.\n    k (int): The position upto which the array should be reversed.\n\n    Returns:\n    list: The modified list with the elements reversed upto the given position.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\n\n# Testing the function\nassert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4) == [4, 3, 2, 1, 5, 6]"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Parameters:\n    t (tuple): The input tuple.\n    d (dict): The input dictionary.\n\n    Returns:\n    tuple: The resulting tuple with the dictionary added.\n    \"\"\"\n    return t + (d,)\n\n# Test the function\nassert add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} ) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    max_average = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            average = dp[i][j] / ((i+1) * (j+1))\n            max_average = max(max_average, average)\n\n    return max_average\n\n# Test cases\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2"}
{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    filtered_students = {}\n    for student, (height, weight) in students.items():\n        if height > min_height and weight > min_weight:\n            filtered_students[student] = (height, weight)\n    return filtered_students\n\n# Test the function\nstudents = {'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}\nmin_height = 6.0\nmin_weight = 70\nexpected_output = {'Cierra Vega': (6.2, 70)}\nassert filter_data(students, min_height, min_weight) == expected_output"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    Counts the number of indices where the given lists have the same values.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n\n    Returns:\n    int: The number of indices where the lists have the same values.\n\n    Raises:\n    ValueError: If the input lists are not of the same length.\n\n    Examples:\n    >>> count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])\n    4\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must be of the same length\")\n\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    \"\"\"\n    Calculate the sum of all digits of a number raised to a specified power.\n\n    Parameters:\n    base (int): The base number.\n    power (int): The power to which the base is raised.\n\n    Returns:\n    int: The sum of all digits of the result.\n\n    Examples:\n    >>> power_base_sum(2, 100)\n    115\n    >>> power_base_sum(3, 4)\n    7\n    \"\"\"\n    result = base ** power\n    digit_sum = sum(int(digit) for digit in str(result))\n    return digit_sum\n\n# Test the function\nassert power_base_sum(2, 100) == 115\nassert power_base_sum(3, 4) == 7"}
{"task_id": "Mbpp/725", "solution": "import re\n\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    list: A list of values between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches\n\n# Test the function\nassert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))\n\n# Test the function\nassert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    This function takes two lists as input and returns a new list where each element is the sum of the corresponding elements from the input lists.\n\n    Parameters:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n\n    Returns:\n    list: A new list where each element is the sum of the corresponding elements from list1 and list2.\n\n    Raises:\n    ValueError: If the input lists have different lengths.\n\n    Examples:\n    >>> sum_list([10, 20, 30], [15, 25, 35])\n    [25, 45, 65]\n    >>> sum_list([1, 2, 3], [4, 5])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input lists must have the same length.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    \"\"\"\n    Removes consecutive duplicates from a given list.\n\n    Args:\n    lst (list): The input list.\n\n    Returns:\n    list: The list with consecutive duplicates removed.\n    \"\"\"\n    result = []\n    prev = None\n    for item in lst:\n        if item != prev:\n            result.append(item)\n        prev = item\n    return result\n\n# Test the function\nassert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4 ]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"}
{"task_id": "Mbpp/731", "solution": "import math\n\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone given its radius and height.\n\n    Parameters:\n    r (float): The radius of the base of the cone.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The lateral surface area of the cone.\n\n    Raises:\n    ValueError: If either r or h is negative.\n\n    Examples:\n    >>> lateralsurface_cone(5, 12)\n    204.20352248333654\n    \"\"\"\n    if r < 0 or h < 0:\n        raise ValueError(\"Radius and height must be non-negative\")\n\n    # Calculate the slant height of the cone\n    s = math.sqrt(r**2 + h**2)\n\n    # Calculate the lateral surface area using the formula:\n    # LSA = \u03c0 * r * s\n    lsa = math.pi * r * s\n\n    return lsa\n\n# Test the function\nassert lateralsurface_cone(5, 12) == 204.20352248333654"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')\n\n# Test the function\nassert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    target (int): The number to find the first occurrence of.\n\n    Returns:\n    int: The index of the first occurrence of the target number in the array.\n        Returns -1 if the target number is not found.\n\n    Examples:\n    >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5)\n    1\n    >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 6)\n    4\n    >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 10)\n    -1\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(lst):\n    \"\"\"\n    Calculate the sum of products of all possible sublists of a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int: The sum of products of all possible sublists.\n\n    Examples:\n    >>> sum_Of_Subarray_Prod([1, 2, 3])\n    20\n    >>> sum_Of_Subarray_Prod([1, 2, 3, 4])\n    70\n    >>> sum_Of_Subarray_Prod([1, 2, 3, 4, 5])\n    154\n    \"\"\"\n\n    def sublists(lst):\n        \"\"\"\n        Generate all possible sublists of a given list.\n\n        Parameters:\n        lst (list): The input list.\n\n        Yields:\n        list: The next sublist.\n        \"\"\"\n        for i in range(len(lst)):\n            for j in range(i, len(lst)):\n                yield lst[i:j+1]\n\n    def product(lst):\n        \"\"\"\n        Calculate the product of a list.\n\n        Parameters:\n        lst (list): The input list.\n\n        Returns:\n        int: The product of the list.\n        \"\"\"\n        result = 1\n        for num in lst:\n            result *= num\n        return result\n\n    result = 0\n    for sublist in sublists(lst):\n        result += product(sublist)\n    return result"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(num):\n    if num < 3:\n        return num\n\n    # Count the number of bits in the given number\n    num_bits = num.bit_length()\n\n    # Create a mask with all bits set except the first and last bit\n    mask = (1 << (num_bits - 1)) - 1\n\n    # Toggle the middle bits using the mask\n    toggled_num = num ^ mask\n\n    return toggled_num\n\n# Test the function\nassert toggle_middle_bits(9) == 15"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, value):\n    \"\"\"\n    Find the left insertion point for a specified value in sorted order.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    value (int): The value to find the left insertion point for.\n\n    Returns:\n    int: The index of the left insertion point.\n\n    Examples:\n    >>> left_insertion([1,2,4,5],6)\n    4\n    >>> left_insertion([1,2,4,5],3)\n    2\n    >>> left_insertion([1,2,4,5],1)\n    0\n    \"\"\"\n\n    left = 0\n    right = len(arr)\n\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left"}
{"task_id": "Mbpp/737", "solution": "import re\n\ndef check_str(string):\n    \"\"\"\n    Check whether the given string is starting with a vowel or not using regex.\n\n    Parameters:\n    string (str): The string to be checked.\n\n    Returns:\n    bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU]'\n    return bool(re.match(pattern, string))\n\n# Test the function\nassert check_str(\"annie\")"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Finds the index of the smallest triangular number with n digits.\n\n    Parameters:\n    n (int): The number of digits.\n\n    Returns:\n    int: The index of the smallest triangular number with n digits.\n    \"\"\"\n    index = 1\n    triangular_number = 1\n\n    while True:\n        digits = len(str(triangular_number))\n        if digits >= n:\n            return index\n        index += 1\n        triangular_number += index\n\n# Test the function\nassert find_Index(2) == 4"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n    t (tuple): The input tuple.\n\n    Returns:\n    dict: The resulting key-value dictionary.\n\n    Raises:\n    ValueError: If the input tuple has an odd length.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    >>> tuple_to_dict(())\n    {}\n    >>> tuple_to_dict((1, 2, 3, 4))\n    {1: 2, 3: 4}\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even length.\")\n\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}\n\n# Test the function\nassert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(string):\n    \"\"\"\n    Check whether all the characters in a given string are the same or not.\n\n    Parameters:\n    string (str): The input string to be checked.\n\n    Returns:\n    bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    if len(string) < 2:\n        return True\n    first_char = string[0]\n    for char in string:\n        if char != first_char:\n            return False\n    return True\n\n# Test cases\nassert all_Characters_Same(\"python\") == False\nassert all_Characters_Same(\"aaaaa\") == True\nassert all_Characters_Same(\"\") == True\nassert all_Characters_Same(\"a\") == True"}
{"task_id": "Mbpp/742", "solution": "import math\n\ndef area_tetrahedron(a):\n    \"\"\"\n    Calculate the area of a regular tetrahedron with side length 'a'.\n\n    Parameters:\n    a (float): The side length of the tetrahedron.\n\n    Returns:\n    float: The area of the tetrahedron.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    \"\"\"\n    if a <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    # Calculate the area of a square with side length 'a'\n    square_area = a ** 2\n\n    # Calculate the area of a triangle with base 'a' and height 'h'\n    triangle_area = (a ** 2) * (math.sqrt(3) / 4)\n\n    # Calculate the total area of the tetrahedron\n    total_area = 4 * triangle_area + square_area\n\n    return total_area\n\n# Test the function\nassert area_tetrahedron(3) == 15.588457268119894"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, num_items):\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n\n    Parameters:\n    lst (list): The list to be rotated.\n    num_items (int): The number of items to rotate by.\n\n    Returns:\n    list: The rotated list.\n\n    Examples:\n    >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n    [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    if num_items == 0:\n        return lst\n\n    num_items = num_items % len(lst)  # Adjust num_items if greater than list length\n    return lst[-num_items:] + lst[:-num_items]\n\n# Test the function\nassert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]"}
{"task_id": "Mbpp/744", "solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any none value or not.\n\n    Parameters:\n    t (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if the tuple has any none value, False otherwise.\n    \"\"\"\n    return any(x is None for x in t)\n\n# Test the function\nassert check_none((10, 4, 5, 6, None)) == True"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        digits = [int(d) for d in str(num)]\n        if all(num % d == 0 for d in digits):\n            result.append(num)\n    return result\n\n# Test the function\nassert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(string):\n    \"\"\"\n    Function to put spaces between words starting with capital letters in a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The modified string with spaces between words starting with capital letters.\n    \"\"\"\n    words = string.split()\n    modified_string = words[0]\n\n    for word in words[1:]:\n        if word[0].isupper():\n            modified_string += \" \" + word\n        else:\n            modified_string += word\n\n    return modified_string\n\n# Test the function\nassert capital_words_spaces(\"Python\") == 'Python'"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(lst):\n    \"\"\"\n    Sorts a given list of strings of numbers numerically.\n\n    Parameters:\n    lst (list): A list of strings representing numbers.\n\n    Returns:\n    list: A new list with the numbers sorted in ascending order.\n\n    Examples:\n    >>> sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500'])\n    [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n    \"\"\"\n    return sorted(lst, key=lambda x: int(x))\n\n# Test the function\nassert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple is to be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The updated list with the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst\n\n# Test the function\nassert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The input array to be checked.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    def is_min_heap(arr, i):\n        n = len(arr)\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n\n        if left_child < n and arr[i] > arr[left_child]:\n            return False\n\n        if right_child < n and arr[i] > arr[right_child]:\n            return False\n\n        if left_child < n:\n            if not is_min_heap(arr, left_child):\n                return False\n\n        if right_child < n:\n            if not is_min_heap(arr, right_child):\n                return False\n\n        return True\n\n    return is_min_heap(arr, 0)\n\n# Test cases\nassert check_min_heap([1, 2, 3, 4, 5, 6]) == True\nassert check_min_heap([1, 2, 3, 4, 5, 6, 7]) == False\nassert check_min_heap([7, 6, 5, 4, 3, 2, 1]) == False\nassert check_min_heap([1, 3, 2, 4, 5, 6]) == False\nassert check_min_heap([1, 2, 3, 1, 5, 6]) == False"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + 2 * jacobsthal_num(n-2)\n\n# Test the function\nassert jacobsthal_num(5) == 11"}
{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n    records (list): A list of tuples, where each tuple contains a name and a value.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list: A list of the minimum k records, sorted in ascending order based on the values.\n\n    \"\"\"\n    sorted_records = sorted(records, key=lambda x: x[1])  # Sort the records based on values\n    return sorted_records[:k]  # Return the first k records\n\n# Test cases\nassert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements\n\n# Test the function\nassert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7]) == [1, 7]"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int or float: The second smallest number in the list.\n\n    Raises:\n    ValueError: If the list has less than 2 elements.\n\n    Examples:\n    >>> second_smallest([1, 2, -8, -2, 0, -2])\n    -2\n    >>> second_smallest([10, 5, 8, 12, 15])\n    8\n    >>> second_smallest([10, 10, 10])\n    Traceback (most recent call last):\n        ...\n    ValueError: List must have at least 2 elements.\n    \"\"\"\n\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least 2 elements.\")\n\n    smallest = min(numbers)\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num > smallest and num < second_smallest:\n            second_smallest = num\n\n    return second_smallest"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count\n\n# Test the function\nassert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == 2"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count\n\n# Test the function\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(string):\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n\n    Parameters:\n    string (str): The string to be checked.\n\n    Returns:\n    bool: True if the string is a decimal number with a precision of 2, False otherwise.\n    \"\"\"\n    try:\n        float(string)\n        parts = string.split('.')\n        if len(parts) == 2 and len(parts[1]) <= 2:\n            return True\n        else:\n            return False\n    except ValueError:\n        return False\n\n# Test cases\nassert is_decimal('123.11') == True\nassert is_decimal('123.111') == False\nassert is_decimal('123') == False\nassert is_decimal('abc') == False"}
{"task_id": "Mbpp/760", "solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1\n\n# Test cases\nassert unique_Element([1, 1, 1]) == True\nassert unique_Element([1, 2, 3]) == False\nassert unique_Element([]) == True\nassert unique_Element([1]) == True\nassert unique_Element([1, 1, 2]) == False\nassert unique_Element([1, 2, 1]) == False"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n\n    Parameters:\n    month_number (int): The month number to be checked.\n\n    Returns:\n    bool: True if the month number contains 30 days, False otherwise.\n    \"\"\"\n    thirty_day_months = {4, 6, 9, 11}  # Months with 30 days\n\n    if month_number in thirty_day_months:\n        return True\n    else:\n        return False\n\n# Test the function\nassert check_monthnumber_number(6) == True"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    \"\"\"\n    Finds the minimum difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): The input array of integers.\n    n (int): The size of the array.\n\n    Returns:\n    int: The minimum difference between any two elements in the array.\n\n    Raises:\n    ValueError: If the array is empty or has only one element.\n\n    Examples:\n    >>> find_min_diff((1, 5, 3, 19, 18, 25), 6)\n    1\n    >>> find_min_diff((10, 20, 30, 40, 50), 5)\n    10\n    >>> find_min_diff((100, 200, 300, 400, 500), 5)\n    100\n    \"\"\"\n\n    if n < 2:\n        raise ValueError(\"Array must have at least two elements\")\n\n    arr = sorted(arr)\n    min_diff = float('inf')\n\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count\n\n# Test the function\nassert number_ctr('program2bedone') == 1"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n\n    A polite number is a positive integer that is not divisible by the sum of its digits.\n\n    Parameters:\n    n (int): The index of the polite number to find.\n\n    Returns:\n    int: The nth polite number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> is_polite(7)\n    11\n    >>> is_polite(10)\n    101\n    >>> is_polite(15)\n    1011\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    count = 0\n    num = 1\n    while count < n:\n        digits_sum = sum(int(digit) for digit in str(num))\n        if num % digits_sum != 0:\n            count += 1\n        num += 1\n\n    return num - 1\n\n# Test the function\nassert is_polite(7) == 11"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: A list of tuples, where each tuple contains consecutive elements from the input list.\n    \"\"\"\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i+1]))\n    return pairs\n\n# Test the function\nassert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, target_sum):\n    \"\"\"\n    Counts the number of pairs in a list of numbers whose sum is equal to the given target sum.\n\n    Parameters:\n    numbers (list): A list of numbers.\n    target_sum (int): The target sum.\n\n    Returns:\n    int: The number of pairs whose sum is equal to the target sum.\n    \"\"\"\n    count = 0\n    pairs = {}\n\n    for num in numbers:\n        complement = target_sum - num\n        if complement in pairs:\n            count += pairs[complement]\n        if num in pairs:\n            pairs[num] += 1\n        else:\n            pairs[num] = 1\n\n    return count\n\n# Test cases\nassert get_pairs_count([1, 1, 1, 1], 2) == 6\nassert get_pairs_count([1, 5, 2, 3, 4], 6) == 2\nassert get_pairs_count([1, 2, 3, 4, 5], 10) == 0"}
{"task_id": "Mbpp/769", "solution": "def Diff(li1, li2):\n    return [i for i in li1 + li2 if i not in li1 or i not in li2]\n\n# Test the function\nassert Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the fourth power of the first n odd natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> odd_num_sum(2)\n    82\n    >>> odd_num_sum(3)\n    202\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return sum(i**4 for i in range(1, 2*n, 2))"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    \"\"\"\n    Check if the given expression is balanced or not.\n\n    Parameters:\n    expression (str): The expression to be checked.\n\n    Returns:\n    bool: True if the expression is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            opening_bracket = stack.pop()\n            if opening_brackets.index(opening_bracket) != closing_brackets.index(char):\n                return False\n\n    return len(stack) == 0\n\n# Test cases\nassert check_expression(\"{()}[{}]\") == True\nassert check_expression(\"({[}])\") == False\nassert check_expression(\"({[]})\") == True\nassert check_expression(\"({[}])\") == False\nassert check_expression(\"({[}])\") == False"}
{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    \"\"\"\n    Remove all the words with length k in the given string.\n\n    Args:\n    string (str): The input string.\n    k (int): The length of words to be removed.\n\n    Returns:\n    str: The modified string with words of length k removed.\n    \"\"\"\n    words = string.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)\n\n# Test the function\nassert remove_length('The person is most value tet', 3) == 'person is most value'"}
{"task_id": "Mbpp/773", "solution": "def occurance_substring(string, substring):\n    \"\"\"\n    Find the occurrence and position of the substrings within a string. Return None if there is no match.\n\n    Parameters:\n    string (str): The input string.\n    substring (str): The substring to find within the string.\n\n    Returns:\n    tuple or None: If a match is found, returns a tuple containing the substring, its starting position, and ending position.\n                    If no match is found, returns None.\n    \"\"\"\n    start_pos = string.find(substring)\n    if start_pos != -1:\n        end_pos = start_pos + len(substring) - 1\n        return substring, start_pos, end_pos\n    else:\n        return None\n\n# Test the function\nassert occurance_substring('python programming, python language','python') == ('python', 0, 6)"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True\n\n# Test cases\nassert odd_position([2,1,4,3,6,7,6,3]) == True\nassert odd_position([2,1,4,3,6,7,6,4]) == False\nassert odd_position([1,3,5,7,9]) == True\nassert odd_position([2,4,6,8,10]) == False"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of non-repeated elements in the list.\n\n    Examples:\n    >>> find_sum([1,2,3,1,1,4,5,6])\n    21\n    \"\"\"\n    unique_elements = set()\n    total_sum = 0\n\n    for num in lst:\n        if num not in unique_elements:\n            unique_elements.add(num)\n            total_sum += num\n\n    return total_sum\n\n# Test the function\nassert find_sum([1,2,3,1,1,4,5,6]) == 21"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n\n    result = [[lst[0]]]\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            result[-1].append(lst[i])\n        else:\n            result.append([lst[i]])\n\n    return result\n\n# Test the function\nassert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"}
{"task_id": "Mbpp/780", "solution": "def find_combinations(tuples):\n    combinations = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            combinations.append((tuples[i][0] + tuples[j][0], tuples[i][1] + tuples[j][1]))\n            combinations.append((tuples[i][0] + tuples[j][1], tuples[i][1] + tuples[j][0]))\n    return combinations\n\n# Test the function\nassert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0\n\n# Test the function\nassert count_divisors(10)"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    \"\"\"\n    Calculate the sum of all odd length subarrays in the given array.\n\n    Parameters:\n    arr (list): The input list of integers.\n\n    Returns:\n    int: The sum of all odd length subarrays.\n\n    Examples:\n    >>> odd_length_sum([1,2,4])\n    14\n    >>> odd_length_sum([1,2,3,4,5])\n    29\n    >>> odd_length_sum([1,2,3,4,5,6])\n    35\n    \"\"\"\n\n    n = len(arr)\n    result = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            subarray = arr[i:j+1]\n            if len(subarray) % 2 != 0:\n                result += sum(subarray)\n\n    return result"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    even_product = 1\n    odd_product = 1\n    for num in lst:\n        if num % 2 == 0:\n            even_product *= num\n        else:\n            odd_product *= num\n    return even_product * odd_product\n\n# Test the function\nassert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    \"\"\"\n    Convert a string representation of a tuple to an integer tuple.\n\n    Parameters:\n    tuple_str (str): A string representation of a tuple.\n\n    Returns:\n    tuple: An integer tuple.\n\n    Raises:\n    ValueError: If the input string is not a valid tuple representation.\n\n    Examples:\n    >>> tuple_str_int(\"(7, 8, 9)\")\n    (7, 8, 9)\n    >>> tuple_str_int(\"(10, '20', 30)\")\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '20'\n    \"\"\"\n    try:\n        return eval(tuple_str)\n    except (SyntaxError, ValueError):\n        raise ValueError(\"Invalid tuple string\")\n\n# Test the function\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, value):\n    \"\"\"\n    Find the right insertion point for a specified value in sorted order.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    value (int): The value to find the right insertion point for.\n\n    Returns:\n    int: The index where the value should be inserted to maintain sorted order.\n\n    Examples:\n    >>> right_insertion([1,2,4,5],6)\n    4\n    >>> right_insertion([1,2,4,5],3)\n    2\n    \"\"\"\n\n    # Initialize the left and right pointers\n    left = 0\n    right = len(arr) - 1\n\n    # Binary search for the right insertion point\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left"}
{"task_id": "Mbpp/787", "solution": "import re\n\ndef text_match_three(text):\n    \"\"\"\n    Function to match a string that has an 'a' followed by three 'b'.\n\n    Parameters:\n    text (str): The input string to be matched.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'ab{3}'\n    return bool(re.search(pattern, text))\n\n# Test cases\nassert not text_match_three(\"ac\")"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(string_list, string):\n    \"\"\"\n    Create a new tuple from the given string and list.\n\n    Args:\n    string_list (list): A list of strings.\n    string (str): A string.\n\n    Returns:\n    tuple: A new tuple containing the elements of the string_list and the string.\n    \"\"\"\n    new_tuple = tuple(string_list) + (string,)\n    return new_tuple\n\n# Test the function\nassert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best')"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    \"\"\"\n    Check whether every even index contains even numbers of a given list.\n\n    Parameters:\n    lst (list): The input list to be checked.\n\n    Returns:\n    bool: True if every even index contains even numbers, False otherwise.\n    \"\"\"\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True\n\n# Test cases\nassert even_position([3,2,1]) == False\nassert even_position([2,4,6,8]) == True\nassert even_position([2,4,5,6,8]) == False\nassert even_position([2,4,6,8,10]) == True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(t):\n    \"\"\"\n    Remove tuples from the given tuple.\n\n    Args:\n    t (tuple): The input tuple.\n\n    Returns:\n    tuple: The modified tuple with tuples removed.\n    \"\"\"\n    return tuple(x for x in t if not isinstance(x, tuple))\n\n# Test the function\nassert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)"}
{"task_id": "Mbpp/792", "solution": "def count_list(lists):\n    \"\"\"\n    Counts the number of lists in a given list of lists.\n\n    Parameters:\n    lists (list): A list of lists.\n\n    Returns:\n    int: The number of lists in the given list of lists.\n    \"\"\"\n    count = 0\n    for lst in lists:\n        if isinstance(lst, list):\n            count += 1\n    return count\n\n# Test the function\nassert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"}
{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    \"\"\"\n    Find the last position of an element in a sorted array.\n\n    Parameters:\n    arr (list): The sorted array.\n    target: The element to find the last position of.\n\n    Returns:\n    int: The last position of the element in the array, or -1 if the element is not found.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] > target:\n            high = mid - 1\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            if mid == len(arr) - 1 or arr[mid + 1] != target:\n                return mid\n            else:\n                low = mid + 1\n\n    return -1\n\n# Test cases\nassert last([1,2,3], 1) == 0"}
{"task_id": "Mbpp/794", "solution": "import re\n\ndef text_starta_endb(text):\n    \"\"\"\n    Function to check if a string starts with 'a' and ends with 'b'.\n\n    Parameters:\n    text (str): The string to be checked.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, text))\n\n# Test the function\nassert text_starta_endb(\"aabbbb\")"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    Calculate the sum of all values in the given dictionary.\n\n    Parameters:\n    dictionary (dict): A dictionary containing key-value pairs.\n\n    Returns:\n    int or float: The sum of all values in the dictionary.\n    \"\"\"\n    return sum(dictionary.values())\n\n# Test the function\nassert return_sum({'a': 100, 'b':200, 'c':300}) == 600"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    Calculate the sum of all odd natural numbers within the range l and r.\n\n    Parameters:\n    l (int): The lower limit of the range.\n    r (int): The upper limit of the range.\n\n    Returns:\n    int: The sum of all odd natural numbers within the range.\n\n    Raises:\n    ValueError: If l is greater than r.\n\n    Examples:\n    >>> sum_in_range(2, 5)\n    8\n    >>> sum_in_range(1, 10)\n    25\n    >>> sum_in_range(10, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Lower limit must be less than or equal to the upper limit.\n    \"\"\"\n\n    if l > r:\n        raise ValueError(\"Lower limit must be less than or equal to the upper limit.\")\n\n    sum_odd = 0\n    for i in range(l, r+1):\n        if i % 2 != 0:\n            sum_odd += i\n\n    return sum_odd"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"\n    Calculate the sum of an array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the numbers in the array.\n    \"\"\"\n    return sum(arr)\n\n# Test the function\nassert _sum([1, 2, 3]) == 6"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(num, d):\n    \"\"\"\n    Rotate left bits by d bits in a given number.\n\n    Parameters:\n    num (int): The number to be rotated.\n    d (int): The number of bits to rotate.\n\n    Returns:\n    int: The rotated number.\n\n    Examples:\n    >>> left_rotate(16, 2)\n    64\n    >>> left_rotate(15, 3)\n    60\n    \"\"\"\n    # Check if d is greater than 32\n    if d > 32:\n        d = d % 32\n\n    # Shift the bits to the left by d positions\n    rotated_num = (num << d) | (num >> (32 - d))\n\n    return rotated_num"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(string):\n    \"\"\"\n    Removes all whitespaces from a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return string.replace(\" \", \"\")\n\n# Test the function\nassert remove_all_spaces('python  program') == 'pythonprogram'"}
{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    Counts the number of equal numbers from three given integers.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    c (int): The third integer.\n\n    Returns:\n    int: The number of equal integers.\n\n    \"\"\"\n    if a == b == c:\n        return 3\n    elif a == b or a == c or b == c:\n        return 2\n    else:\n        return 0\n\n# Test cases\nassert test_three_equal(1, 1, 1) == 3\nassert test_three_equal(1, 2, 1) == 2\nassert test_three_equal(1, 2, 3) == 0"}
{"task_id": "Mbpp/803", "solution": "import math\n\ndef is_perfect_square(num):\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    square_root = math.isqrt(num)\n    return square_root * square_root == num\n\n# Test the function\nassert not is_perfect_square(10)"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if the product is even, False otherwise.\n    \"\"\"\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0\n\n# Test the function\nassert is_product_even([1, 2, 3]) == False\nassert is_product_even([2, 4, 6]) == True\nassert is_product_even([-1, -2, -3]) == False\nassert is_product_even([-2, -4, -6]) == True"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lst):\n    max_sum = float('-inf')\n    max_sum_list = []\n    for sublist in lst:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_sum_list = sublist\n    return max_sum_list\n\n# Test the function\nassert max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]]) == [10, 11, 12]"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(string):\n    \"\"\"\n    Finds the maximum run of uppercase characters in the given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The length of the maximum run of uppercase characters.\n\n    Examples:\n    >>> max_run_uppercase('GeMKSForGERksISBESt')\n    5\n    \"\"\"\n\n    max_run = 0  # Initialize the maximum run length\n    current_run = 0  # Initialize the current run length\n\n    for char in string:\n        if char.isupper():\n            current_run += 1  # Increment the current run length\n        else:\n            current_run = 0  # Reset the current run length\n\n        max_run = max(max_run, current_run)  # Update the maximum run length\n\n    return max_run"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The first odd number found in the list, or None if no odd number is found.\n    \"\"\"\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None\n\n# Test cases\nassert first_odd([1, 3, 5]) == 1\nassert first_odd([2, 4, 6]) == None\nassert first_odd([4, 6, 8, 10]) == 4\nassert first_odd([2, 4, 6, 8, 10]) == None"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuples contain the k or not.\n\n    Parameters:\n    tup (tuple): The input tuple.\n    k (int): The value to check for.\n\n    Returns:\n    bool: True if the tuple contains the k, False otherwise.\n    \"\"\"\n    return k in tup\n\n# Test the function\nassert check_K((10, 4, 5, 6, 8), 6) == True"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    Check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\n    Args:\n    tuple1 (tuple): The first tuple.\n    tuple2 (tuple): The second tuple.\n\n    Returns:\n    bool: True if each element of tuple2 is smaller than its corresponding element in tuple1, False otherwise.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        return False\n\n    for i in range(len(tuple1)):\n        if tuple2[i] >= tuple1[i]:\n            return False\n\n    return True\n\n# Test the function\nassert check_smaller((1, 2, 3), (2, 3, 4)) == False"}
