{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    \"\"\"\n    Find the shared elements from the given two lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list containing the shared elements.\n\n    Examples:\n        >>> similar_elements((3, 4, 5, 6), (5, 7, 4, 10))\n        [4, 5]\n    \"\"\"\n    return list(set(list1) & set(list2))"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(num):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    num (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if num < 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    numbers (list): A list of numbers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use a min-heap to store the smallest numbers\n    heap = []\n    for num in numbers:\n        heapq.heappush(heap, num)\n        if len(heap) > n:\n            heapq.heappop(heap)\n\n    # Return the n largest integers in descending order\n    return sorted(heap, reverse=True)"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check whether the two numbers differ at one bit position only.\n\n    Args:\n    num1 (int): The first number.\n    num2 (int): The second number.\n\n    Returns:\n    bool: True if the two numbers differ at one bit position only, False otherwise.\n    \"\"\"\n    xor_result = num1 ^ num2\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(string):\n    words = string.split()\n    result = [word for word in words if len(word) >= 4]\n    return result"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "def find_Rotations(string):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n\n    Raises:\n    ValueError: If the input is not a string.\n\n    Examples:\n    >>> find_Rotations(\"aaaa\")\n    1\n    >>> find_Rotations(\"abcd\")\n    4\n    >>> find_Rotations(\"\")\n    0\n    \"\"\"\n\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n\n    if len(string) == 0:\n        return 0\n\n    rotations = 1\n    while string[1:] + string[0] != string:\n        string = string[1:] + string[0]\n        rotations += 1\n\n    return rotations"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    # Find the first and last occurrence of the character\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n\n    # Remove the first and last occurrence of the character from the string\n    if first_occurrence != -1 and last_occurrence != -1:\n        return string[:first_occurrence] + string[first_occurrence+1:last_occurrence] + string[last_occurrence+1:]\n    else:\n        return string"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (list): A 2D list representing the matrix.\n\n    Returns:\n    list: The sorted matrix.\n\n    \"\"\"\n    # Calculate the sum of each row in the matrix\n    row_sums = [sum(row) for row in matrix]\n\n    # Create a list of tuples containing the row sums and the corresponding rows\n    rows_with_sums = list(zip(row_sums, matrix))\n\n    # Sort the rows based on the row sums\n    sorted_rows = sorted(rows_with_sums, key=lambda x: x[0])\n\n    # Extract the sorted rows from the sorted_rows list\n    sorted_matrix = [row[1] for row in sorted_rows]\n\n    return sorted_matrix"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    This function calculates the volume of a triangular prism.\n\n    Parameters:\n    base (float): The base of the triangular prism.\n    height (float): The height of the triangular prism.\n    length (float): The length of the triangular prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n\n    Raises:\n    ValueError: If any of the input values are negative.\n\n    \"\"\"\n    if base < 0 or height < 0 or length < 0:\n        raise ValueError(\"Input values cannot be negative\")\n\n    base_area = 0.5 * base * height\n    volume = base_area * length\n    return volume"}
{"task_id": "Mbpp/16", "solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, and False otherwise.\n\n    Parameters:\n    input_string (str): The input string to be checked.\n\n    Returns:\n    bool: True if the input string contains lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'[a-z]+_[a-z]+'\n    return bool(re.search(pattern, input_string))"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    This function calculates the perimeter of a square given its side length as input.\n\n    Parameters:\n    side_length (int or float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> square_perimeter(10)\n    40.0\n    >>> square_perimeter(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 4 * side_length"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(first_string, second_string):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Args:\n        first_string (str): The string from which characters will be removed.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified first string with characters removed.\n\n    Examples:\n        >>> remove_dirty_chars(\"probasscurve\", \"pros\")\n        'bacuve'\n    \"\"\"\n    clean_string = ''.join(char for char in first_string if char not in second_string)\n    return clean_string"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): The input array of integers.\n\n    Returns:\n    bool: True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is woodball or not.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is woodball, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 == 1:\n            return False\n        n //= 2\n    return True"}
{"task_id": "Mbpp/56", "solution": "def check(num):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    def reverse_number(n):\n        \"\"\"\n        Reverse the digits of a number.\n\n        Parameters:\n        n (int): The number to be reversed.\n\n        Returns:\n        int: The reversed number.\n        \"\"\"\n        return int(str(n)[::-1])\n\n    reversed_num = reverse_number(num)\n    return num == 2 * reversed_num + 1"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    \"\"\"\n    Finds the largest number that can be formed with the given list of digits.\n\n    Args:\n        digits (list): A list of non-negative integers.\n\n    Returns:\n        int: The largest number that can be formed with the given digits.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> find_Max_Num([1, 2, 3])\n        321\n        >>> find_Max_Num([9, 8, 7, 6, 5])\n        98765\n        >>> find_Max_Num([])\n        Traceback (most recent call last):\n            ...\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not digits:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    # Convert the list of digits to a string and sort it in descending order\n    sorted_digits = sorted(map(str, digits), reverse=True)\n\n    # Join the sorted digits to form the largest number\n    max_num = int(''.join(sorted_digits))\n\n    return max_num"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(num1, num2):\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    bool: True if the two integers have opposite signs, False otherwise.\n    \"\"\"\n    return (num1 ^ num2) < 0"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    Function to find the nth octagonal number.\n\n    Parameters:\n    n (int): The position of the octagonal number to find.\n\n    Returns:\n    int: The nth octagonal number.\n\n    \"\"\"\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/61", "solution": "def count_Substrings(string):\n    count = 0\n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            substring = string[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> smallest_num([10, 20, 1, 45, 99])\n        1\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    return min(numbers)"}
{"task_id": "Mbpp/63", "solution": "def max_difference(tuples):\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        tuples (list): A list of tuples, where each tuple contains two integers.\n\n    Returns:\n        int: The maximum difference between available pairs.\n\n    Raises:\n        ValueError: If the input list is empty or any tuple in the list has less than two elements.\n\n    Examples:\n        >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n        7\n    \"\"\"\n    if not tuples:\n        raise ValueError(\"Input list cannot be empty\")\n\n    max_diff = float('-inf')\n    for i in range(len(tuples)):\n        if len(tuples[i]) < 2:\n            raise ValueError(\"Each tuple in the list must contain at least two elements\")\n        for j in range(i+1, len(tuples)):\n            diff = abs(tuples[i][0] - tuples[j][0])\n            if diff > max_diff:\n                max_diff = diff\n            diff = abs(tuples[i][0] - tuples[j][1])\n            if diff > max_diff:\n                max_diff = diff\n            diff = abs(tuples[i][1] - tuples[j][0])\n            if diff > max_diff:\n                max_diff = diff\n            diff = abs(tuples[i][1] - tuples[j][1])\n            if diff > max_diff:\n                max_diff = diff\n\n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def subject_marks(lst):\n    return sorted(lst, key=lambda x: x[1])"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total"}
{"task_id": "Mbpp/66", "solution": "def pos_count(nums):\n    \"\"\"\n    Count the number of positive numbers in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The count of positive numbers in the list.\n\n    Examples:\n        >>> pos_count([1,-2,3,-4])\n        2\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Function to find the number of ways to partition a set of Bell numbers.\n\n    Parameters:\n    n (int): The number of Bell numbers to partition.\n\n    Returns:\n    int: The number of ways to partition the set of Bell numbers.\n\n    Examples:\n    >>> bell_number(2)\n    2\n    \"\"\"\n\n    # Base case: 1 Bell number can be partitioned in only 1 way\n    if n == 1:\n        return 1\n\n    # Initialize the list to store the Bell numbers\n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    bell[0][0] = 1\n\n    # Compute the Bell numbers using dynamic programming\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n\n    # Return the number of ways to partition the set of Bell numbers\n    return bell[n][0]"}
{"task_id": "Mbpp/68", "solution": "def is_monotonic(arr):\n    \"\"\"\n    Check whether the given array is monotonic or not.\n\n    Parameters:\n    arr (list): The input list of integers.\n\n    Returns:\n    bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    if len(arr) <= 2:\n        return True\n\n    increasing = decreasing = True\n\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n\n    return increasing or decreasing\n\n# Test cases\nassert is_monotonic([6, 5, 4, 4]) == True\nassert is_monotonic([1, 2, 3, 4]) == True\nassert is_monotonic([4, 3, 2, 1]) == True\nassert is_monotonic([1, 2, 2, 4]) == False\nassert is_monotonic([1, 3, 2, 4]) == False"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(lst, sublst):\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n\n    Args:\n    lst (list): The main list to be checked.\n    sublst (list): The sublist to be searched for.\n\n    Returns:\n    bool: True if the sublist is found in the list, False otherwise.\n    \"\"\"\n    return sublst in lst"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    \"\"\"\n    Function to find whether all the given tuples have equal length or not.\n\n    Parameters:\n    tuples (list): A list of tuples.\n\n    Returns:\n    bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    lengths = set(len(t) for t in tuples)\n    return len(lengths) == 1"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(lst):\n    gap = len(lst)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(lst):\n            if lst[i] > lst[i + gap]:\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                sorted = False\n            i += 1\n\n    return lst"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(num):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    for i in range(int(num**0.5) + 1):\n        j = int((num - i**2)**0.5)\n        if i**2 + j**2 == num:\n            return True\n    return False"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(sequence, patterns):\n    \"\"\"\n    Check whether the given sequence follows the patterns array.\n\n    Args:\n    sequence (list): The sequence to be checked.\n    patterns (list): The patterns to be followed.\n\n    Returns:\n    bool: True if the sequence follows the patterns, False otherwise.\n    \"\"\"\n    if len(sequence) != len(patterns):\n        return False\n\n    for i in range(len(sequence)):\n        if sequence[i] != patterns[i]:\n            return False\n\n    return True"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuples (list): A list of tuples.\n    k (int): The divisor.\n\n    Returns:\n    list: A list of tuples that have all elements divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples:\n        if all(elem % k == 0 for elem in t):\n            result.append(t)\n    return result"}
{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(number):\n    \"\"\"\n    Function to check if a number is divisible by 11.\n\n    Parameters:\n    number (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    return number % 11 == 0\n\n# Test the function\nassert is_divisible_by_11(12345) == False"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    Check whether the length of the word is odd or not.\n\n    Parameters:\n    word (str): The word to check.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The nth tetrahedral number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> tetrahedral_number(5)\n    35\n    >>> tetrahedral_number(1)\n    1\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return (n * (n + 1) * (n + 2)) // 6"}
{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    return (4/3) * math.pi * radius**3"}
{"task_id": "Mbpp/84", "solution": "def newman_conway(n):\n    \"\"\"\n    Find the nth number in the Newman Conway sequence.\n\n    Parameters:\n    n (int): The position of the number to find in the sequence.\n\n    Returns:\n    int: The nth number in the Newman Conway sequence.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    sequence = [0, 1, 1]\n\n    for i in range(3, n + 1):\n        sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n\n    return sequence[n]\n\n# Test the function\ndef test_sequence():\n    assert newman_conway(10) == 6\n\ntest_sequence()"}
{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    return 4 * math.pi * radius**2"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Function to find the nth centered hexagonal number.\n\n    Parameters:\n    n (int): The position of the centered hexagonal number to find.\n\n    Returns:\n    int: The nth centered hexagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> centered_hexagonal_number(10)\n    271\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    for d in (dict1, dict2, dict3):\n        merged_dict.update(d)\n    return merged_dict"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    Find the closest smaller number than n.\n\n    Args:\n    n (int): The number to find the closest smaller number for.\n\n    Returns:\n    int: The closest smaller number than n.\n\n    Raises:\n    ValueError: If n is less than or equal to 0.\n\n    Examples:\n    >>> closest_num(11)\n    10\n    >>> closest_num(10)\n    9\n    >>> closest_num(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be greater than 0.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0.\")\n    return n - 1"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        int: The length of the longest word.\n\n    Raises:\n        ValueError: If the input is not a list or if the list is empty.\n\n    Examples:\n        >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n        7\n        >>> len_log([\"hello\", \"world\"])\n        5\n        >>> len_log([])\n        Traceback (most recent call last):\n            ...\n        ValueError: Input list is empty.\n    \"\"\"\n    if not isinstance(words, list):\n        raise ValueError(\"Input is not a list.\")\n    if not words:\n        raise ValueError(\"Input list is empty.\")\n\n    return max(len(word) for word in words)"}
{"task_id": "Mbpp/91", "solution": "def find_substring(lst, substring):\n    \"\"\"\n    Check if a string is present as a substring in a given list of string values.\n\n    Args:\n        lst (list): A list of string values.\n        substring (str): The substring to check.\n\n    Returns:\n        bool: True if the substring is found in any of the string values in the list, False otherwise.\n    \"\"\"\n    for value in lst:\n        if substring in value:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(num):\n    \"\"\"\n    Check whether the given number is undulating or not.\n\n    An undulating number is a number that has alternating odd and even digits.\n    For example, 1212121 is an undulating number since it has alternating odd and even digits (1, 2, 1, 2, 1, 2, 1).\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    num_str = str(num)\n    for i in range(len(num_str) - 2):\n        if (int(num_str[i]) % 2) == (int(num_str[i+1]) % 2) or (int(num_str[i+1]) % 2) == (int(num_str[i+2]) % 2):\n            return False\n    return True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Parameters:\n    a (int or float): The base number.\n    b (int): The exponent.\n\n    Returns:\n    int or float: The result of 'a' raised to the power 'b'.\n    \"\"\"\n    return a ** b"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        str: The first value of the tuple with the smallest second value.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n        'Varsha'\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return min(lst, key=lambda x: x[1])[0]"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns the length of the smallest list.\n\n    Parameters:\n    lst (list): A list of lists.\n\n    Returns:\n    int: The length of the smallest list.\n\n    Example:\n    >>> Find_Min_Length([[1],[1,2]])\n    1\n    \"\"\"\n    min_length = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    \"\"\"\n    This function takes an integer n as input and returns the number of divisors of n.\n\n    Parameters:\n    n (int): The integer for which the number of divisors is to be calculated.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, abs(n) + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lst):\n    freq_dict = {}\n    for sublist in lst:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict"}
{"task_id": "Mbpp/98", "solution": "import math\ndef multiply_num(numbers):\n    \"\"\"\n    Multiply all the numbers in a list and divide with the length of the list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The result of multiplying all the numbers and dividing by the length of the list.\n\n    Raises:\n        ValueError: If the input is not a list.\n\n    Examples:\n        >>> multiply_num([8, 2, 3, -1, 7])\n        -67.2\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list\")\n\n    if len(numbers) == 0:\n        return 0\n\n    result = 1\n    for num in numbers:\n        result *= num\n\n    return result / len(numbers)"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]  # Convert decimal to binary using built-in bin() function\n    return binary"}
{"task_id": "Mbpp/100", "solution": "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\ndef next_smallest_palindrome(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if n <= 10:\n        return n\n    if is_palindrome(n):\n        return n\n    while True:\n        n += 1\n        if is_palindrome(n):\n            return n"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The index of the element to find (1-based indexing).\n\n    Returns:\n    int: The kth element in the array.\n\n    Raises:\n    ValueError: If the index k is out of range.\n\n    Examples:\n    >>> kth_element([12,3,5,7,19], 2)\n    3\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"Index out of range\")\n    return sorted(arr)[k-1]"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    \"\"\"\n    Converts a snake case string to camel case string.\n\n    Parameters:\n    snake_str (str): The snake case string to be converted.\n\n    Returns:\n    str: The camel case string.\n\n    Examples:\n    >>> snake_to_camel('python_program')\n    'PythonProgram'\n    \"\"\"\n    words = snake_str.split('_')\n    camel_str = ''.join(word.capitalize() if word else '' for word in words)\n    return camel_str[0].lower() + camel_str[1:]"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    The Eulerian number a(n, m) represents the number of permutations of m objects taken n at a time.\n\n    Parameters:\n    n (int): The number of objects taken at a time.\n    m (int): The number of objects to be permuted.\n\n    Returns:\n    int: The Eulerian number a(n, m).\n\n    Raises:\n    ValueError: If n or m is negative.\n\n    Examples:\n    >>> eulerian_num(3, 1)\n    4\n    >>> eulerian_num(5, 4)\n    5\n    >>> eulerian_num(0, 0)\n    1\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"n and m must be non-negative\")\n\n    if n == 0:\n        return 1\n\n    result = 1\n    for i in range(1, n + 1):\n        result = (m - i + 1) * result // i\n\n    return result"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        lst (list): A list of lists of strings.\n\n    Returns:\n        list: A new list of lists with each sublist sorted in lexicographical order.\n\n    Examples:\n        >>> sort_sublists([[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]])\n        [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/105", "solution": "def count(lst):\n    \"\"\"\n    Counts the number of True booleans in the given list.\n\n    Args:\n        lst (list): A list of booleans.\n\n    Returns:\n        int: The count of True booleans in the list.\n\n    Examples:\n        >>> count([True, False, True])\n        2\n    \"\"\"\n    return lst.count(True)"}
{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list"}
{"task_id": "Mbpp/109", "solution": "def rotate_binary_string(binary_str, num_rotations):\n    binary_str = binary_str * num_rotations  # Repeat the binary string num_rotations times\n    count = 0\n    for i in range(len(binary_str)):\n        rotated_str = binary_str[i:] + binary_str[:i]  # Rotate the binary string\n        if int(rotated_str, 2) % 2 != 0:  # Check if the rotated string represents an odd number\n            count += 1\n    return count\ndef odd_Equivalent(binary_str, num_rotations):\n    return rotate_binary_string(binary_str, num_rotations)"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n        nested_lists (list): A list of lists containing elements.\n\n    Returns:\n        list: A list of common elements found in the nested lists.\n\n    Examples:\n        >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n        [18, 12]\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements = common_elements.intersection(set(lst))\n\n    return list(common_elements)"}
{"task_id": "Mbpp/113", "solution": "def check_integer(string):\n    \"\"\"\n    Check if a string represents an integer or not.\n\n    Parameters:\n    string (str): The string to be checked.\n\n    Returns:\n    bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(t):\n    \"\"\"\n    Converts a given tuple of positive integers into a single integer.\n\n    Parameters:\n    t (tuple): The tuple of positive integers to be converted.\n\n    Returns:\n    int: The converted single integer.\n\n    Examples:\n    >>> tuple_to_int((1, 2, 3))\n    123\n    >>> tuple_to_int((4, 5, 6))\n    456\n    >>> tuple_to_int((7, 8, 9))\n    789\n    \"\"\"\n    return int(''.join(map(str, t)))"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    return string.split()"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if mid % 2 == 1:\n            mid -= 1\n\n        if arr[mid] != arr[mid + 1]:\n            right = mid\n        else:\n            left = mid + 2\n\n    return arr[left]"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(lst):\n    \"\"\"\n    Find the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Args:\n    lst (list): A list of tuples containing two integers.\n\n    Returns:\n    int: The maximum absolute product between numbers in pairs of tuples.\n\n    Example:\n    >>> max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )\n    36\n    \"\"\"\n    max_product = 0\n    for tup in lst:\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    def divisor_sum(num):\n        div_sum = 0\n        for i in range(1, num):\n            if num % i == 0:\n                div_sum += i\n        return div_sum\n\n    amicable_sum = 0\n    for num in range(1, n+1):\n        if num == divisor_sum(divisor_sum(num)) and num != divisor_sum(num):\n            amicable_sum += num\n    return amicable_sum"}
{"task_id": "Mbpp/124", "solution": "import math\ndef angle_complex(z):\n    \"\"\"\n    Returns the angle of a complex number in radians.\n\n    Parameters:\n    z (complex): The complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n\n    Raises:\n    TypeError: If the input is not a complex number.\n\n    \"\"\"\n    if not isinstance(z, complex):\n        raise TypeError(\"Input must be a complex number\")\n\n    return math.atan2(z.imag, z.real)"}
{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    max_diff = 0\n    count_zeroes = 0\n    count_ones = 0\n\n    for char in binary_string:\n        if char == '0':\n            count_zeroes += 1\n        else:\n            count_ones += 1\n\n        diff = count_ones - count_zeroes\n        max_diff = max(max_diff, diff)\n\n    return max_diff"}
{"task_id": "Mbpp/126", "solution": "def sum_of_common_divisors(a, b):\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n\n    Returns:\n    int: The sum of common divisors of a and b.\n    \"\"\"\n    def gcd(x, y):\n        \"\"\"\n        Find the greatest common divisor (GCD) of two numbers.\n\n        Parameters:\n        x (int): First number.\n        y (int): Second number.\n\n        Returns:\n        int: The GCD of x and y.\n        \"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    def sum_of_divisors(n):\n        \"\"\"\n        Find the sum of divisors of a given number.\n\n        Parameters:\n        n (int): The number.\n\n        Returns:\n        int: The sum of divisors of n.\n        \"\"\"\n        result = 0\n        i = 1\n        while i * i <= n:\n            if n % i == 0:\n                if i * i == n:\n                    result += i\n                else:\n                    result += i\n                    result += n // i\n            i += 1\n        return result\n\n    gcd_ab = gcd(a, b)\n    return sum_of_divisors(gcd_ab)\n\n# Test the function\nassert sum_of_common_divisors(10, 15) == 6"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Function to multiply two integers.\n\n    Parameters:\n    a (int): First integer.\n    b (int): Second integer.\n\n    Returns:\n    int: The product of the two integers.\n    \"\"\"\n    return a * b"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n        n (int): The minimum length of words to be considered long.\n        sentence (str): The input sentence containing words.\n\n    Returns:\n        list: A list of words that are longer than n characters.\n\n    \"\"\"\n    words = sentence.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_row = [sum(row) for row in matrix]\n    sum_col = [sum(col) for col in zip(*matrix)]\n    sum_diag = sum(matrix[i][i] for i in range(n))\n    sum_rev_diag = sum(matrix[i][n-i-1] for i in range(n))\n    \n    if len(set(sum_row)) == 1 and len(set(sum_col)) == 1 and len(set([sum_diag, sum_rev_diag])) == 1:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The item with maximum frequency.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n        2\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n\n    frequency = {}\n    max_item = lst[0]\n    max_count = 1\n\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n        if frequency[item] > max_count:\n            max_item = item\n            max_count = frequency[item]\n\n    return max_item"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(string):\n    vowels = [char for char in string if char.lower() in 'aeiou']\n    vowels.reverse()\n    result = ''\n    vowel_index = 0\n    for char in string:\n        if char.lower() in 'aeiou':\n            result += vowels[vowel_index]\n            vowel_index += 1\n        else:\n            result += char\n    return result"}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    \"\"\"\n    Converts a tuple to a string.\n\n    Parameters:\n    tup (tuple): The input tuple to be converted.\n\n    Returns:\n    str: The converted string.\n\n    Examples:\n    >>> tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))\n    'exercises'\n    \"\"\"\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers in a given list of numbers.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The sum of the negative numbers.\n\n    \"\"\"\n    negatives = [num for num in numbers if num < 0]\n    return sum(negatives)"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Function to find the nth hexagonal number.\n\n    Parameters:\n    n (int): The position of the hexagonal number to be found.\n\n    Returns:\n    int: The nth hexagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (2*n - 1)"}
{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    \n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    if non_zero_count == 0:\n        return 0\n    \n    return zero_count / non_zero_count"}
{"task_id": "Mbpp/138", "solution": "def is_sum_of_powers_of_two(n):\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n > 0:\n        if n % 2 == 1:\n            n = n // 2\n        else:\n            return False\n    return True\n\n# Test the function\nassert is_sum_of_powers_of_two(10) == True"}
{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    float: The circumference of the circle.\n    \"\"\"\n    circumference = 2 * math.pi * radius\n    return circumference"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(lst):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n    \"\"\"\n    flattened = []\n    for sublist in lst:\n        for num in sublist:\n            flattened.append(num)\n    return flattened"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Parameters:\n    lst (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list of elements.\n\n    Examples:\n    >>> pancake_sort([15, 79, 25, 38, 69])\n    [15, 25, 38, 69, 79]\n    \"\"\"\n\n    def flip(lst, i):\n        \"\"\"\n        Flips the list from index 0 to i.\n\n        Parameters:\n        lst (list): The list to be flipped.\n        i (int): The index up to which the list should be flipped.\n\n        Returns:\n        list: The flipped list.\n        \"\"\"\n        start = 0\n        while start < i:\n            lst[start], lst[i] = lst[i], lst[start]\n            start += 1\n            i -= 1\n        return lst\n\n    def find_max(lst, n):\n        \"\"\"\n        Finds the index of the maximum element in the list.\n\n        Parameters:\n        lst (list): The list to be searched.\n        n (int): The index up to which the list should be searched.\n\n        Returns:\n        int: The index of the maximum element.\n        \"\"\"\n        max_idx = 0\n        for i in range(1, n):\n            if lst[i] > lst[max_idx]:\n                max_idx = i\n        return max_idx\n\n    n = len(lst)\n    current_size = n\n    while current_size > 1:\n        max_idx = find_max(lst, current_size)\n        if max_idx != current_size - 1:\n            lst = flip(lst, max_idx)\n            lst = flip(lst, current_size - 1)\n        current_size -= 1\n    return lst"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the number of items that are identical in the same position of three given lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        int: The number of items that are identical in the same position of the three lists.\n\n    Raises:\n        ValueError: If the input lists have different lengths.\n\n    Examples:\n        >>> count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])\n        3\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"Input lists must have the same length\")\n\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): The input array of numbers.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n\n    Examples:\n    >>> max_Abs_Diff((2,1,5,3))\n    4\n    >>> max_Abs_Diff((-2,-1,-5,-3))\n    4\n    >>> max_Abs_Diff((1, 1, 1, 1))\n    0\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"Input array cannot be empty\")\n\n    min_val = float('inf')\n    max_val = float('-inf')\n\n    for num in arr:\n        min_val = min(min_val, num)\n        max_val = max(max_val, num)\n\n    return max_val - min_val"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    for x in range(n+1):\n        y = (n - a*x) / b\n        if y % 1 == 0 and y >= 0:\n            return x, int(y)\n    return None"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(lst1, lst2):\n    \"\"\"\n    Remove all elements from a given list present in another list.\n\n    Args:\n        lst1 (list): The first list.\n        lst2 (list): The second list.\n\n    Returns:\n        list: A new list with elements from lst1 that are not present in lst2.\n\n    Examples:\n        >>> remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8])\n        [1, 3, 5, 7, 9, 10]\n    \"\"\"\n    return [x for x in lst1 if x not in lst2]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    total_sum = 0\n    for i in range(0, n // 2 + 1):\n        total_sum += n - 2 * i\n    return total_sum"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    \"\"\"\n    Count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The count of characters that occur at the same position in the string as in the English alphabet.\n    \"\"\"\n    count = 0\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    string = string.lower()\n    for i, char in enumerate(string):\n        if char == alphabet[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(lst):\n    count = 0\n    seen = set()\n    for num in lst:\n        complement = num ^ 1\n        if complement in seen:\n            count += 1\n        seen.add(num)\n    return count"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    else:\n        return 2 ** (len(bin(n)) - 2)"}
{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n\n    Args:\n        lst (list): The list to search for occurrences of the number.\n        num (int): The number to count occurrences of.\n\n    Returns:\n        int: The number of occurrences of the number in the list.\n    \"\"\"\n    return lst.count(num)"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n        lst (list): The input list of numbers.\n        start (int): The starting index of the range (inclusive).\n        end (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of numbers in the specified range.\n\n    Raises:\n        ValueError: If the start or end index is out of range.\n\n    Examples:\n        >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10)\n        29\n    \"\"\"\n    if start < 0 or end < 0:\n        raise ValueError(\"Indices cannot be negative\")\n    if start >= len(lst) or end >= len(lst):\n        raise ValueError(\"Indices out of range\")\n    if start > end:\n        raise ValueError(\"Start index cannot be greater than end index\")\n\n    return sum(lst[start:end+1])"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of its sides.\n\n    Parameters:\n    side_length (float or int): The length of the sides of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> perimeter_pentagon(5)\n    25.0\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    perimeter = 5 * side_length\n    return perimeter"}
{"task_id": "Mbpp/172", "solution": "def count_occurrence(string):\n    \"\"\"\n    Count the number of occurence of the string 'std' in a given string.\n\n    Args:\n        string (str): The input string to search for 'std' occurrences.\n\n    Returns:\n        int: The number of times 'std' occurs in the input string.\n    \"\"\"\n    count = 0\n    index = 0\n    while index < len(string):\n        if string[index:index+3] == 'std':\n            count += 1\n            index += 3\n        else:\n            index += 1\n    return count\n\n# Test the function\nassert count_occurrence(\"letstdlenstdporstd\") == 3"}
{"task_id": "Mbpp/222", "solution": "def check_type(t):\n    \"\"\"\n    Check if all elements in a tuple have the same data type.\n\n    Parameters:\n    t (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    data_types = set(type(element) for element in t)\n    return len(data_types) == 1"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    count = 0\n    for i in range(n):\n        if arr[i] == element:\n            count += 1\n    return count > n/2"}
{"task_id": "Mbpp/224", "solution": "def count_set_bits(num):\n    \"\"\"\n    Count the number of set bits (binary digits with value 1) in a given number.\n\n    Args:\n        num (int): The number to count the set bits in.\n\n    Returns:\n        int: The number of set bits in the given number.\n\n    Examples:\n        >>> count_set_bits(2)\n        1\n        >>> count_set_bits(7)\n        3\n        >>> count_set_bits(0)\n        0\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\n# Test the function\nassert count_set_bits(2) == 1\nassert count_set_bits(7) == 3\nassert count_set_bits(0) == 0"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with odd index values removed.\n\n    Examples:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return string[::2]"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Find the minimum of three numbers.\n\n    Parameters:\n    a (int or float): First number.\n    b (int or float): Second number.\n    c (int or float): Third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    return string.replace(' ', character)"}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    \"\"\"\n    This function takes in a list and an integer n and returns a list containing the n largest items from the list.\n\n    Parameters:\n    lst (list): The input list.\n    n (int): The number of largest items to return.\n\n    Returns:\n    list: A list containing the n largest items from the input list.\n\n    Example:\n    >>> larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2)\n    [100, 90]\n    \"\"\"\n    # Sort the list in descending order\n    sorted_lst = sorted(lst, reverse=True)\n\n    # Return the first n items from the sorted list\n    return sorted_lst[:n]"}
{"task_id": "Mbpp/233", "solution": "import math"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Parameters:\n    side_length (float or int): The length of one side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> volume_cube(3)\n    27\n    >>> volume_cube(0)\n    0\n    >>> volume_cube(-2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(num):\n    \"\"\"\n    This function sets all even bits of a given number.\n\n    Parameters:\n    num (int): The input number.\n\n    Returns:\n    int: The number with even bits set.\n\n    Examples:\n    >>> even_bit_set_number(10)\n    10\n    >>> even_bit_set_number(15)\n    14\n    \"\"\"\n    # Create a mask with all even bits set\n    mask = int('10101010101010101010101010101010', 2)\n\n    # Use bitwise AND operation to set even bits\n    return num | mask"}
{"task_id": "Mbpp/237", "solution": "def check_occurences(lst):\n    \"\"\"\n    Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for tup in lst:\n        if tup in result:\n            result[tup] += 1\n        else:\n            result[tup] = 1\n    return result"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(string):\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The number of non-empty substrings.\n\n    Examples:\n    >>> number_of_substrings(\"abc\")\n    6\n    \"\"\"\n    count = 0\n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            if string[i:j]:  # Check if the substring is not empty\n                count += 1\n    return count"}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Parameters:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The number of possible sequences.\n\n    Examples:\n    >>> get_total_number_of_sequences(10, 4)\n    4\n    \"\"\"\n\n    # Initialize a list to store the number of sequences for each length\n    sequences = [0] * (n + 1)\n\n    # Base case: There is only one sequence of length 1\n    sequences[1] = 1\n\n    # Iterate through each length from 2 to n\n    for length in range(2, n + 1):\n        # Calculate the number of sequences for the current length\n        for i in range(1, length):\n            sequences[length] += sequences[i]\n\n        # Add m - 2 * (length - 1) to account for the additional sequences that can be formed\n        sequences[length] += m - 2 * (length - 1)\n\n    # Return the number of sequences for length n\n    return sequences[n]"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n\n    Returns:\n    list: The modified first list with the last element replaced by the elements of the second list.\n    \"\"\"\n    list1[-1] = list2\n    return list1"}
{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    \"\"\"\n    This function counts the total number of characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    return len(string)"}
{"task_id": "Mbpp/244", "solution": "import math\ndef next_Perfect_Square(num):\n    \"\"\"\n    Find the next perfect square greater than a given number.\n\n    Parameters:\n    num (int): The given number.\n\n    Returns:\n    int: The next perfect square greater than num.\n\n    Examples:\n    >>> next_Perfect_Square(35)\n    36\n    >>> next_Perfect_Square(12)\n    16\n    \"\"\"\n    # Find the square root of the given number\n    sqrt = int(math.sqrt(num))\n\n    # Check if the square root is a perfect square\n    if sqrt * sqrt == num:\n        # If it is, increment the square root by 1 and square it to get the next perfect square\n        return (sqrt + 1) ** 2\n    else:\n        # If it's not, increment the square root by 1 and square it to get the next perfect square\n        return (sqrt + 1) ** 2"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n\n    # Find the peak element\n    peak = -1\n    for i in range(1, n-1):\n        if arr[i-1] < arr[i] and arr[i] > arr[i+1]:\n            peak = i\n            break\n\n    if peak == -1:  # Array is already bitonic\n        return sum(arr)\n\n    # Calculate the maximum sum of increasing subsequence up to the peak\n    max_sum_inc = 0\n    current_sum = 0\n    for i in range(peak):\n        current_sum += arr[i]\n        max_sum_inc = max(max_sum_inc, current_sum)\n\n    # Calculate the maximum sum of decreasing subsequence after the peak\n    max_sum_dec = 0\n    current_sum = 0\n    for i in range(n-1, peak, -1):\n        current_sum += arr[i]\n        max_sum_dec = max(max_sum_dec, current_sum)\n\n    return max_sum_inc + max_sum_dec + arr[peak]"}
{"task_id": "Mbpp/247", "solution": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 2 and s[i] == s[j]:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][n - 1]"}
{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    return tup.count(element)"}
{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result"}
{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(num):\n    \"\"\"\n    Convert complex numbers to polar coordinates.\n\n    Parameters:\n    num (complex): The complex number to be converted.\n\n    Returns:\n    tuple: A tuple containing the magnitude and angle of the polar coordinates in radians.\n\n    Examples:\n    >>> convert(1)\n    (1.0, 0.0)\n    >>> convert(1+1j)\n    (1.4142135623730951, 0.7853981633974483)\n    >>> convert(-1)\n    (1.0, 3.141592653589793)\n    \"\"\"\n    magnitude = abs(num)\n    angle = cmath.phase(num)\n    return (magnitude, angle)"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    \"\"\"\n    Returns the number of integer elements in a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int: The number of integer elements in the list.\n    \"\"\"\n    count = 0\n    for element in lst:\n        if isinstance(element, int):\n            count += 1\n    return count"}
{"task_id": "Mbpp/255", "solution": "from itertools import product\ndef combinations_colors(lst, n):\n    \"\"\"\n    Generate all combinations (with repetition) of the elements of a list and return a list with a tuple for each combination.\n\n    Args:\n    lst (list): The input list.\n    n (int): The length of the combinations.\n\n    Returns:\n    list: A list with tuples representing all combinations (with repetition) of the elements of the input list.\n    \"\"\"\n    combinations = list(product(lst, repeat=n))\n    return combinations"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for num in range(n):\n        if is_prime(num):\n            count += 1\n    return count"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    return b, a"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    # Check if the lengths of the tuples are equal\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must have the same length\")\n\n    # Initialize an empty list to store the maximized elements\n    maximized_elements = []\n\n    # Iterate over the elements of the tuples simultaneously\n    for element1, element2 in zip(tuple1, tuple2):\n        # Check if the elements are tuples of length 2\n        if len(element1) != 2 or len(element2) != 2:\n            raise ValueError(\"Elements must be tuples of length 2\")\n\n        # Find the maximum value for each element in the tuple\n        max_value = max(element1[0], element2[0]), max(element1[1], element2[1])\n\n        # Append the maximized element to the list\n        maximized_elements.append(max_value)\n\n    return tuple(maximized_elements)"}
{"task_id": "Mbpp/260", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef newman_prime(n):\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num):\n            count += 1\n        num += 1\n    return num - 1"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Function to perform mathematical division operation element-wise across the given tuples.\n\n    Args:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A new tuple with the division operation element-wise across the given tuples.\n\n    Raises:\n    ValueError: If the lengths of the input tuples are not equal.\n\n    Examples:\n    >>> division_elements((10, 4, 6, 9), (5, 2, 3, 3))\n    (2, 2, 2, 3)\n    \"\"\"\n\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    result = tuple(a / b for a, b in zip(tuple1, tuple2))\n    return result"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits the given list into two parts where the length of the first part is L, and returns the resulting lists in a tuple.\n\n    Args:\n    lst (list): The input list to be split.\n    L (int): The length of the first part of the list.\n\n    Returns:\n    tuple: A tuple containing the two resulting lists.\n\n    Raises:\n    ValueError: If L is greater than the length of the input list.\n\n    Examples:\n    >>> split_two_parts([1,1,2,3,4,4,5,1],3)\n    ([1, 1, 2], [3, 4, 4, 5, 1])\n    \"\"\"\n    if L > len(lst):\n        raise ValueError(\"Length L cannot be greater than the length of the input list.\")\n\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/264", "solution": "def dog_age(human_age):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    Parameters:\n    human_age (int): The age of the dog in human years.\n\n    Returns:\n    int: The age of the dog in dog years.\n\n    Raises:\n    ValueError: If the input is not a positive integer.\n\n    \"\"\"\n    if not isinstance(human_age, int) or human_age <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n\n    Parameters:\n    side_length (int or float): The length of one side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> lateralsurface_cube(5)\n    100\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 4 * side_length ** 2"}
{"task_id": "Mbpp/267", "solution": "def square_sum(n):\n    \"\"\"\n    This function takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n\n    Examples:\n    >>> square_sum(2)\n    10\n    \"\"\"\n    odd_numbers = [2 * i + 1 for i in range(n)]  # Generate the first n odd natural numbers\n    sum_of_squares = sum(num ** 2 for num in odd_numbers)  # Calculate the sum of squares\n    return sum_of_squares\n\n# Test the function\nassert square_sum(2) == 10"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Find the n'th star number.\n\n    A star number is a triangular number that is also a square number.\n\n    Parameters:\n    n (int): The position of the star number to find.\n\n    Returns:\n    int: The n'th star number.\n\n    Examples:\n    >>> find_star_num(3)\n    37\n    \"\"\"\n    # Generate triangular numbers\n    triangular_numbers = [(i * (i + 1)) // 2 for i in range(1, n + 1)]\n\n    # Generate square numbers\n    square_numbers = [i ** 2 for i in range(1, n + 1)]\n\n    # Find the intersection of triangular and square numbers\n    star_numbers = list(set(triangular_numbers) & set(square_numbers))\n\n    # Return the n'th star number\n    return star_numbers[n - 1]"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    This function takes a character as input and returns its ASCII value.\n\n    Parameters:\n    char (str): The character for which the ASCII value needs to be determined.\n\n    Returns:\n    int: The ASCII value of the input character.\n    \"\"\"\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    \"\"\"\n    This function takes a list as input and returns the sum of even numbers at even positions in the list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The sum of even numbers at even positions in the list.\n    \"\"\"\n    even_index_even_nums = [lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 == 0]\n    return sum(even_index_even_nums)"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    \"\"\"\n    This function takes in an integer n and finds the sum of the first n even natural numbers raised to the fifth power.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of the first n even natural numbers raised to the fifth power.\n\n    Examples:\n    >>> even_Power_Sum(2)\n    1056\n    \"\"\"\n    sum_of_powers = sum(i**5 for i in range(2, 2*n+1, 2))\n    return sum_of_powers"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples):\n    return [t[-1] for t in tuples]"}
{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must have the same length\")\n    \n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple1[i] - tuple2[i])\n    \n    return tuple(result)"}
{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function takes in a positive integer n and finds the sum of even index binomial coefficients.\n\n    Parameters:\n    n (int): The positive integer for which to find the sum of even index binomial coefficients.\n\n    Returns:\n    int: The sum of even index binomial coefficients.\n\n    Examples:\n    >>> even_binomial_Coeff_Sum(4)\n    8\n    \"\"\"\n    # Initialize the sum to 0\n    sum_of_coeffs = 0\n\n    # Iterate through the even indices\n    for i in range(0, n+1, 2):\n        # Calculate the binomial coefficient using the formula C(n, k) = nappa / (kappan)\n        coeff = factorial(n) // (factorial(i) * factorial(n - i))\n        # Add the coefficient to the sum\n        sum_of_coeffs += coeff\n\n    return sum_of_coeffs\ndef factorial(n):\n    \"\"\"\n    This function calculates the factorial of a number.\n\n    Parameters:\n    n (int): The number for which to calculate the factorial.\n\n    Returns:\n    int: The factorial of the given number.\n\n    Examples:\n    >>> factorial(5)\n    120\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)"}
{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be non-negative\")\n    return math.pi * radius**2 * height"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    filtered_dict = {key: value for key, value in dictionary.items() if value >= n}\n    return filtered_dict"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    count = 0\n    for element in tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Function to find the nth decagonal number.\n\n    Parameters:\n    n (int): The position of the decagonal number to find.\n\n    Returns:\n    int: The nth decagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if the elements of a given list are unique or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "def sub_list(lst1, lst2):\n    \"\"\"\n    Subtracts two lists element-wise.\n\n    Args:\n        lst1 (list): The first list.\n        lst2 (list): The second list.\n\n    Returns:\n        list: A new list with elements obtained by subtracting the corresponding elements of lst2 from lst1.\n\n    Raises:\n        ValueError: If the input lists have different lengths.\n\n    Examples:\n        >>> sub_list([1, 2, 3], [4, 5, 6])\n        [-3, -3, -3]\n    \"\"\"\n    if len(lst1) != len(lst2):\n        raise ValueError(\"Input lists must have the same length\")\n\n    return [x - y for x, y in zip(lst1, lst2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(num):\n    num_str = str(num)\n    for digit in num_str:\n        if num_str.count(digit) > int(digit):\n            return False\n    return True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    \"\"\"\n    Check if all items in the list are equal to the given element.\n\n    Args:\n        lst (list): The input list.\n        element: The element to check.\n\n    Returns:\n        bool: True if all items in the list are equal to the given element, False otherwise.\n    \"\"\"\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "solution": "import re\ndef text_match_two_three(text):\n    \"\"\"\n    Checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string contains 'a' followed by two or three 'b' characters, False otherwise.\n    \"\"\"\n    pattern = r\"ab{2,3}\"\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, k, n):\n    \"\"\"\n    Finds the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The number of times the array is repeated.\n    n (int): The length of the modified array.\n\n    Returns:\n    int: The largest sum of a contiguous array in the modified array.\n\n    Examples:\n    >>> max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3)\n    30\n    \"\"\"\n\n    # Calculate the sum of the original array\n    original_sum = sum(arr)\n\n    # Calculate the maximum sum subarray for the original array\n    max_sum = max_sub_array_sum(arr)\n\n    # If the original array is already positive, return the maximum sum\n    if max_sum > 0:\n        return max_sum\n\n    # If the original array is negative, calculate the maximum sum subarray in the modified array\n    modified_sum = max_sum * (k - 2) + original_sum\n\n    # If the modified sum is positive, return it\n    if modified_sum > 0:\n        return modified_sum\n\n    # If the modified sum is negative, return the maximum sum subarray in the original array\n    return max_sub_array_sum(arr * (n // len(arr)))\ndef max_sub_array_sum(arr):\n    \"\"\"\n    Finds the maximum sum of a contiguous subarray in the given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum sum of a contiguous subarray.\n\n    Examples:\n    >>> max_sub_array_sum([10, 20, -30, -1])\n    30\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"}
{"task_id": "Mbpp/287", "solution": "def square_sum(n):\n    \"\"\"\n    This function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of squares of the first n even natural numbers.\n\n    Examples:\n    >>> square_sum(2)\n    20\n    \"\"\"\n    sum_of_squares = 0\n    for i in range(2, 2*n+1, 2):\n        sum_of_squares += i**2\n    return sum_of_squares\n\n# Test the function\nassert square_sum(2) == 20"}
{"task_id": "Mbpp/290", "solution": "def max_length(lst):\n    max_len = 0\n    max_list = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    return max_len, max_list"}
{"task_id": "Mbpp/292", "solution": "def find(dividend, divisor):\n    \"\"\"\n    This function takes two numbers as input and returns the quotient of the division of the first number by the second number (rounded down to the nearest integer).\n\n    Parameters:\n    dividend (int): The dividend number.\n    divisor (int): The divisor number.\n\n    Returns:\n    int: The quotient of the division.\n\n    Raises:\n    ZeroDivisionError: If the divisor is zero.\n\n    Examples:\n    >>> find(10, 3)\n    3\n    >>> find(10, 4)\n    2\n    >>> find(10, 0)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: division by zero\n    \"\"\"\n    if divisor == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    return dividend // divisor"}
{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(side1, side2):\n    \"\"\"\n    This function takes two sides of a right-angled triangle as input and returns the length of the third side.\n\n    Parameters:\n    side1 (float): The length of the first side of the triangle.\n    side2 (float): The length of the second side of the triangle.\n\n    Returns:\n    float: The length of the third side of the triangle.\n\n    Raises:\n    ValueError: If either side1 or side2 is negative or if the triangle is not a right-angled triangle.\n\n    \"\"\"\n    if side1 < 0 or side2 < 0:\n        raise ValueError(\"Sides cannot be negative.\")\n\n    hypotenuse = math.sqrt(side1**2 + side2**2)\n    return hypotenuse"}
{"task_id": "Mbpp/294", "solution": "def max_val(lst):\n    max_value = None\n    for item in lst:\n        if max_value is None or item > max_value:\n            max_value = item\n    return max_value"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n\n    Parameters:\n    arr (list): The input list of integers.\n\n    Returns:\n    int: The number of inversions in the array.\n\n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    flattened = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened.extend(flatten_list(item))\n        else:\n            flattened.append(item)\n    return flattened"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(scores):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    Args:\n    scores (list): A list of tuples containing names and scores.\n\n    Returns:\n    tuple: A tuple containing the name and the maximum aggregate.\n\n    \"\"\"\n    aggregates = {}\n    for name, score in scores:\n        if name in aggregates:\n            aggregates[name] += score\n        else:\n            aggregates[name] = score\n\n    max_name = max(aggregates, key=aggregates.get)\n    max_aggregate = aggregates[max_name]\n\n    return (max_name, max_aggregate)"}
{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    \"\"\"\n    Function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n\n    Parameters:\n    n (int): The length of the binary sequence (n bits for first and last n bits)\n\n    Returns:\n    float: The count of binary sequences satisfying the condition\n\n    \"\"\"\n    # Base case for n = 1\n    if n == 1:\n        return 2.0\n\n    # Recursive case\n    count = 0\n    for i in range(2):\n        count += count_binary_seq(n-1) * 0.5\n\n    return count"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    \"\"\"\n    Function to find the depth of a dictionary.\n\n    Parameters:\n    dictionary (dict): The input dictionary.\n\n    Returns:\n    int: The depth of the dictionary.\n\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        return 0\n\n    depths = [1 + dict_depth(value) for value in dictionary.values()]\n    return max(depths) if depths else 1"}
{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    for word in words:\n        if word.startswith('p'):\n            return word.split()\n    return None"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    max_sum = float('-inf')\n    for j in range(i, n):\n        if arr[j] > arr[k]:\n            max_sum = max(max_sum, arr[j])\n    return max_sum"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, num):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n    list1 (list): The first list of numbers.\n    list2 (list): The second list of numbers.\n    num (int): The number of largest products to find.\n\n    Returns:\n    list: A list of the specified number of largest products.\n\n    Raises:\n    ValueError: If num is greater than the number of elements in either list.\n\n    Examples:\n    >>> large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)\n    [60, 54, 50]\n    \"\"\"\n\n    if num > len(list1) or num > len(list2):\n        raise ValueError(\"num cannot be greater than the number of elements in either list.\")\n\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n\n    products.sort(reverse=True)\n    return products[:num]"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the maximum of the two.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The maximum of the two input numbers.\n    \"\"\"\n    return max(a, b)"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(string):\n    return tuple(string)"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(num):\n    \"\"\"\n    This function takes an integer `num` as input and returns the result of setting the left most unset bit in `num`.\n\n    Parameters:\n    num (int): The input integer.\n\n    Returns:\n    int: The result of setting the left most unset bit in `num`.\n    \"\"\"\n    if num == 0:\n        return 1\n    bit_length = num.bit_length()\n    mask = 1 << (bit_length - 1)\n    return num | mask"}
{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    radius (float): The radius of the cone.\n    height (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n\n    Raises:\n    ValueError: If the radius or height is negative.\n\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be non-negative.\")\n\n    base_area = math.pi * radius**2\n    volume = (base_area * height) / 3\n    return volume"}
{"task_id": "Mbpp/388", "solution": "def highest_power_of_2(n):\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The highest power of 2 that is less than or equal to n.\n\n    Examples:\n    >>> highest_power_of_2(10)\n    8\n    >>> highest_power_of_2(16)\n    16\n    >>> highest_power_of_2(0)\n    0\n    \"\"\"\n    if n <= 0:\n        return 0\n    else:\n        return 2 ** (n.bit_length() - 1)\n\n# Testing the function\nassert highest_power_of_2(10) == 8\nassert highest_power_of_2(16) == 16\nassert highest_power_of_2(0) == 0"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    \"\"\"\n    Find the n'th Lucas number.\n\n    The Lucas numbers are a sequence of numbers in which each term is the sum of the two preceding terms.\n    The sequence starts with 2 and 1, so the first few Lucas numbers are 2, 1, 3, 4, 7, 11, 18, 29, ...\n\n    Parameters:\n    n (int): The index of the Lucas number to find.\n\n    Returns:\n    int: The n'th Lucas number.\n\n    Raises:\n    ValueError: If n is negative.\n\n    Examples:\n    >>> find_lucas(9)\n    76\n    >>> find_lucas(0)\n    2\n    >>> find_lucas(1)\n    1\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n\n    lucas_nums = [2, 1]\n    for i in range(2, n + 1):\n        lucas_nums.append(lucas_nums[i - 1] + lucas_nums[i - 2])\n\n    return lucas_nums[n]"}
{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n\n    Args:\n        lst (list): The input list of elements.\n        format_str (str): The format string to apply.\n\n    Returns:\n        list: A new list with the format string applied to each element.\n\n    Examples:\n        >>> add_string([1, 2, 3, 4], 'temp{0}')\n        ['temp1', 'temp2', 'temp3', 'temp4']\n    \"\"\"\n    return [format_str.format(item) for item in lst]"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values1, values2):\n    result = []\n    for i in range(len(keys)):\n        nested_dict = {keys[i]: {values1[i]: values2[i]}}\n        result.append(nested_dict)\n    return result"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(t):\n    \"\"\"\n    Check if given tuple contains no duplicates.\n\n    Parameters:\n    t (tuple): The input tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    return len(t) == len(set(t))"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    return None"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    This function takes three numbers as input and returns their median.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    float: The median of the three numbers.\n\n    Examples:\n    >>> median_numbers(25, 55, 65)\n    55.0\n    >>> median_numbers(10, 20, 30)\n    20.0\n    >>> median_numbers(5, 10, 15)\n    10.0\n    \"\"\"\n    return sorted([a, b, c])[1]"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Compute the sum of digits of each number in a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A list of sums of digits for each number in the input list.\n\n    Examples:\n        >>> sum_of_digits([10, 2, 56])\n        [1, 2, 11]\n    \"\"\"\n    result = []\n    for number in numbers:\n        digit_sum = 0\n        while number > 0:\n            digit_sum += number % 10\n            number //= 10\n        result.append(digit_sum)\n    return result"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the minimum of the two.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The minimum of the two input numbers.\n    \"\"\"\n    return min(a, b)"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The input tuple to be checked.\n    element: The element to be searched for within the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(num):\n    \"\"\"\n    This function takes an integer as input and returns True if the parity of the number is odd, and False otherwise.\n\n    Parameters:\n    num (int): The number to check parity for.\n\n    Returns:\n    bool: True if the parity of the number is odd, False otherwise.\n    \"\"\"\n    return num % 2 != 0"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(lst):\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        int: The minimum product from the pairs of tuples.\n\n    Raises:\n        ValueError: If the input is not a list of tuples.\n\n    Examples:\n        >>> min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)])\n        8\n    \"\"\"\n    if not all(isinstance(t, tuple) for t in lst):\n        raise ValueError(\"Input must be a list of tuples\")\n\n    min_product = float('inf')\n    for tup in lst:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    \"\"\"\n    Find the minimum value in a given heterogeneous list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        The minimum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> min_val(['Python', 3, 2, 4, 5, 'version'])\n        2\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n\n    min_val = lst[0]\n    for item in lst:\n        if isinstance(item, (int, float)):\n            if item < min_val:\n                min_val = item\n\n    return min_val"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    Remove odd numbers from a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A new list with odd numbers removed.\n\n    Examples:\n        >>> remove_odd([1, 2, 3])\n        [2]\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(lst, n):\n    \"\"\"\n    Extracts the nth element from a given list of tuples.\n\n    Args:\n        lst (list): The list of tuples.\n        n (int): The index of the element to extract.\n\n    Returns:\n        list: A list containing the nth element from each tuple.\n\n    Raises:\n        IndexError: If the index is out of range.\n\n    Examples:\n        >>> extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0)\n        ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n    \"\"\"\n    return [t[n] for t in lst]"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (sequence): The first sequence.\n        seq2 (sequence): The second sequence.\n\n    Returns:\n        bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False"}
{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    max_product = float('-inf')\n    result = None\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                result = (arr[i], arr[j])\n    \n    return result"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    max_length = 0\n    max_element = []\n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n    return max_element"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(rounded_numbers)\n    return result"}
{"task_id": "Mbpp/420", "solution": "def cube_sum(n):\n    \"\"\"\n    This function calculates the cube sum of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The cube sum of the first n even natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> cube_sum(2)\n    72\n    >>> cube_sum(3)\n    216\n    >>> cube_sum(0)\n    0\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_cubes = sum(i**3 for i in range(2, 2*n+1, 2))\n    return sum_of_cubes\n\n# Test cases\nassert cube_sum(2) == 72\nassert cube_sum(3) == 216\nassert cube_sum(0) == 0"}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the given delimiter.\n\n    Args:\n        t (tuple): The input tuple.\n        delimiter (str, optional): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n\n    Examples:\n        >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") )\n        'ID-is-4-UTS'\n    \"\"\"\n    return delimiter.join(map(str, t))"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers.\n\n    Returns:\n    float: The average of cubes of first n natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> find_Average_Of_Cube(2)\n    4.5\n    >>> find_Average_Of_Cube(5)\n    22.5\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    average = sum_of_cubes / n\n    return average"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n        tup (tuple): The input tuple of strings.\n\n    Returns:\n        list: A list containing the rear index elements of the strings in the input tuple.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n\n    Examples:\n        >>> extract_rear(('Mers', 'for', 'Vers') )\n        ['s', 'r', 's']\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple\")\n\n    return [string[-1] for string in tup]"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n        lst (list): The input list of sublists.\n        element: The element to count.\n\n    Returns:\n        int: The number of sublists containing the element.\n\n    Examples:\n        >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n        3\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    \"\"\"\n    This function filters odd numbers from a given list.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    list: A new list containing only the odd numbers.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date):\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Args:\n        date (str): The date in yyyy-mm-dd format.\n\n    Returns:\n        str: The date in dd-mm-yyyy format.\n\n    Raises:\n        ValueError: If the input date is not in the correct format.\n\n    Examples:\n        >>> change_date_format(\"2026-01-02\")\n        '02-01-2026'\n    \"\"\"\n    try:\n        year, month, day = date.split('-')\n        return f\"{day}-{month}-{year}\"\n    except ValueError:\n        raise ValueError(\"Invalid date format. Expected yyyy-mm-dd.\")"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(t1, t2):\n    \"\"\"\n    Extracts the elementwise and tuples from the given two tuples.\n\n    Args:\n        t1 (tuple): The first tuple.\n        t2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A tuple containing the elementwise and tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> and_tuples((10, 4, 6, 9), (5, 2, 3, 3))\n        (0, 0, 2, 1)\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    result = []\n    for i in range(len(t1)):\n        result.append(t1[i] & t2[i])\n\n    return tuple(result)"}
{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    This function finds the directrix of a parabola given its standard form coefficients a, b, and c.\n\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n\n    Returns:\n    float: The directrix of the parabola\n\n    Raises:\n    ValueError: If the parabola has no directrix (vertical line)\n\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"The parabola is not in standard form.\")\n\n    # Calculate the directrix\n    directrix = -b**2 / (4*a)\n\n    return directrix"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    \"\"\"\n    This function calculates the median length of a trapezium given its four sides.\n\n    Parameters:\n    a (int or float): Length of side a of the trapezium.\n    b (int or float): Length of side b of the trapezium.\n    c (int or float): Length of side c of the trapezium.\n\n    Returns:\n    float: The median length of the trapezium.\n\n    Raises:\n    ValueError: If any of the input values are negative or if the trapezium is not valid.\n\n    \"\"\"\n\n    # Check if the trapezium is valid\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"Sides of a trapezium cannot be negative or zero.\")\n\n    # Calculate the median length\n    s = (a + b - c) / 2\n    if s <= 0:\n        raise ValueError(\"Invalid trapezium: Median length cannot be negative or zero.\")\n\n    return s"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers.\n    num (int or float): The number to compare.\n\n    Returns:\n    bool: True if the number is greater than all elements of the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True"}
{"task_id": "Mbpp/435", "solution": "def last_digit(number):\n    \"\"\"\n    This function takes a number as input and returns the last digit of that number.\n\n    Parameters:\n    number (int): The number from which the last digit needs to be extracted.\n\n    Returns:\n    int: The last digit of the given number.\n    \"\"\"\n    return number % 10\n\n# Test the function\nassert last_digit(123) == 3"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    \"\"\"\n    Returns a list of negative numbers from the given input list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    list: A list of negative numbers.\n\n    Examples:\n    >>> neg_nos([-1, 4, 5, -6])\n    [-1, -6]\n    >>> neg_nos([1, 2, 3, 4])\n    []\n    >>> neg_nos([-1, -2, -3, -4])\n    [-1, -2, -3, -4]\n    \"\"\"\n    return [num for num in lst if num < 0]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The string with odd characters removed.\n\n    Examples:\n        >>> remove_odd(\"python\")\n        'yhn'\n    \"\"\"\n    return string[::2]"}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The joined integer.\n\n    Raises:\n        TypeError: If the input is not a list of integers.\n\n    Examples:\n        >>> multiple_to_single([11, 33, 50])\n        113350\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n\n    if not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"Input must be a list of integers\")\n\n    return int(''.join(map(str, numbers)))"}
{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):\n    \"\"\"\n    Find the first adverb and their positions in a given sentence.\n\n    Args:\n        sentence (str): The input sentence.\n\n    Returns:\n        tuple: A tuple containing the start position, end position, and the adverb found.\n\n    Raises:\n        ValueError: If no adverb is found in the sentence.\n\n    Examples:\n        >>> find_adverb_position(\"clearly!! we can see the sky\")\n        (0, 7, 'clearly')\n    \"\"\"\n    adverbs = ['clearly', 'easily', 'often', 'quickly', 'slowly', 'happily', 'sadly', 'always', 'never']\n    words = sentence.split()\n    for i, word in enumerate(words):\n        if word.lower() in adverbs:\n            return i, i + len(word) - 1, word\n    raise ValueError(\"No adverb found in the sentence.\")"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(size):\n    \"\"\"\n    Calculate the surface area of a cube of a given size.\n\n    Parameters:\n    size (int): The size of the cube.\n\n    Returns:\n    int: The surface area of the cube.\n\n    Raises:\n    ValueError: If the size is not a positive integer.\n\n    Examples:\n    >>> surfacearea_cube(5)\n    150\n    \"\"\"\n    if not isinstance(size, int) or size <= 0:\n        raise ValueError(\"Size must be a positive integer\")\n    return 6 * size ** 2"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(t1, t2):\n    result = []\n    for i in range(len(t1)):\n        if len(t1[i]) != len(t2[i]):\n            raise ValueError(\"Tuples must have equal number of elements at each index\")\n        product = tuple(x * y for x, y in zip(t1[i], t2[i]))\n        result.append(product)\n    return tuple(result)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    \"\"\"\n    Function to find cubes of individual elements in a list.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    list: A new list with cubes of individual elements.\n\n    Example:\n    >>> cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    \"\"\"\n    return [num ** 3 for num in nums]"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of the first n Perrin numbers.\n\n    Parameters:\n    n (int): The number of Perrin numbers to consider.\n\n    Returns:\n    int: The sum of the first n Perrin numbers.\n\n    Raises:\n    ValueError: If n is negative.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    perrin_numbers = [3, 0, 2]  # Perrin numbers sequence\n\n    if n <= 3:\n        return sum(perrin_numbers[:n])\n\n    while len(perrin_numbers) < n:\n        next_number = perrin_numbers[-2] + perrin_numbers[-3]\n        perrin_numbers.append(next_number)\n\n    return sum(perrin_numbers)"}
{"task_id": "Mbpp/450", "solution": "def extract_string(lst, size):\n    \"\"\"\n    Extracts strings of specified size from a given list of string values.\n\n    Args:\n        lst (list): A list of string values.\n        size (int): The size of strings to extract.\n\n    Returns:\n        list: A list of strings of the specified size.\n\n    Examples:\n        >>> extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)\n        ['practice', 'solution']\n    \"\"\"\n    return [s for s in lst if len(s) == size]"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    return string.replace(' ', '')"}
{"task_id": "Mbpp/453", "solution": "def sum_of_even_factors(n):\n    \"\"\"\n    This function takes an integer n as input and returns the sum of all even factors of n.\n\n    Parameters:\n    n (int): The number for which to find the sum of even factors.\n\n    Returns:\n    int: The sum of even factors of n.\n\n    Examples:\n    >>> sum_of_even_factors(18)\n    26\n    \"\"\"\n    sum_of_factors = 0\n    for i in range(2, n+1, 2):\n        if n % i == 0:\n            sum_of_factors += i\n    return sum_of_factors\n\n# Test the function\nassert sum_of_even_factors(18) == 26"}
{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    \"\"\"\n    Function to match a word containing 'z'.\n\n    Parameters:\n    text (str): The input text to be checked.\n\n    Returns:\n    bool: True if the word contains 'z', False otherwise.\n    \"\"\"\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/455", "solution": "def check_month_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 31 days or not.\n\n    Parameters:\n    month_number (int): The month number to be checked.\n\n    Returns:\n    bool: True if the month contains 31 days, False otherwise.\n    \"\"\"\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    elif month_number == 2:\n        return False  # Assuming February does not have 31 days\n    elif month_number in [4, 6, 9, 11]:\n        return False\n    else:\n        return False  # Invalid month number\n\n# Test cases\nassert check_month_number(5) == True\nassert check_month_number(2) == False\nassert check_month_number(13) == False"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Parameters:\n    string_list (list): A list of string values.\n\n    Returns:\n    list: A new list with reversed string values.\n\n    Example:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_string = string[::-1]\n        reversed_list.append(reversed_string)\n    return reversed_list"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    \"\"\"\n    Find the sublist with minimum length.\n\n    Args:\n    lst (list): A list of sublists.\n\n    Returns:\n    list: The sublist with minimum length.\n\n    \"\"\"\n    min_length = float('inf')\n    min_sublist = []\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(width, height):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    width (int or float): The width of the rectangle.\n    height (int or float): The height of the rectangle.\n\n    Returns:\n    int or float: The area of the rectangle.\n    \"\"\"\n    if not isinstance(width, (int, float)):\n        raise TypeError(\"Width must be an integer or float.\")\n    if not isinstance(height, (int, float)):\n        raise TypeError(\"Height must be an integer or float.\")\n    if width < 0:\n        raise ValueError(\"Width cannot be negative.\")\n    if height < 0:\n        raise ValueError(\"Height cannot be negative.\")\n\n    return width * height"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    \"\"\"\n    Removes uppercase substrings from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The input string with uppercase substrings removed.\n\n    Examples:\n        >>> remove_uppercase('cAstyoUrFavoRitETVshoWs')\n        'cstyoravoitshos'\n    \"\"\"\n    return ''.join(char for char in string if not char.isupper())"}
{"task_id": "Mbpp/460", "solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]"}
{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    result = [[]]\n    for item in lst:\n        result += [x + [item] for x in result]\n    return result"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    \"\"\"\n    Find the maximum product subarray of the given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum product of any subarray in the input array.\n\n    Examples:\n    >>> max_subarray_product([1, -2, -3, 0, 7, -8, -2])\n    112\n    \"\"\"\n\n    if not arr:\n        return 0\n\n    max_product = float('-inf')\n    current_product = 1\n\n    for num in arr:\n        current_product *= num\n        max_product = max(max_product, current_product)\n        if num == 0:\n            current_product = 1\n\n    return max_product"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    \"\"\"\n    Drop empty items from a given dictionary.\n\n    Args:\n        dictionary (dict): The input dictionary.\n\n    Returns:\n        dict: The dictionary with empty items dropped.\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    \"\"\"\n    Find the maximum product formed by multiplying numbers of an increasing subsequence of the given array.\n\n    Parameters:\n    arr (list): The input list of numbers.\n\n    Returns:\n    int: The maximum product of an increasing subsequence.\n\n    Examples:\n    >>> max_product([3, 100, 4, 5, 150, 6])\n    3000\n    \"\"\"\n\n    # Initialize variables to keep track of the maximum product and the current product\n    max_product = 0\n    current_product = 1\n\n    # Iterate over the array\n    for num in arr:\n        # Update the current product by multiplying it with the current number\n        current_product *= num\n\n        # Update the maximum product if the current product is greater\n        if current_product > max_product:\n            max_product = current_product\n\n        # If the current number is negative, reset the current product to 1\n        if num < 0:\n            current_product = 1\n\n    return max_product"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(t):\n    return tuple(t[i] + t[i+1] for i in range(len(t)-1))"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    Find the product of the array multiplication modulo n.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): A positive integer.\n\n    Returns:\n    int: The product of the array multiplication modulo n.\n\n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    \"\"\"\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    \"\"\"\n    Check whether the given list contains consecutive numbers or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    return sorted(lst) == list(range(min(lst), min(lst) + len(lst)))"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(tuple_list1, tuple_list2):\n    intersection = set()\n    for tuple1 in tuple_list1:\n        for tuple2 in tuple_list2:\n            if set(tuple1) == set(tuple2):\n                intersection.add(tuple1)\n    return intersection"}
{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with a new character.\n\n    Args:\n        string (str): The input string.\n        old_char (str): The character to be replaced.\n        new_char (str): The new character.\n\n    Returns:\n        str: The modified string with replaced characters.\n\n    Examples:\n        >>> replace_char(\"polygon\",'y','l')\n        'pollgon'\n    \"\"\"\n    return string.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    \"\"\"\n    Sorts a dictionary by value in descending order.\n\n    Args:\n        dictionary (dict): The dictionary to be sorted.\n\n    Returns:\n        list: A list of tuples representing the sorted key-value pairs of the dictionary.\n\n    Examples:\n        >>> sort_counter({'Math': 81, 'Physics': 83, 'Chemistry': 87})\n        [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    \"\"\"\n    sorted_items = sorted(dictionary.items(), key=lambda x: x[1], reverse=True)\n    return sorted_items"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int: The sum of the largest and smallest value in the array.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([5, 10, 15])\n    20\n    >>> big_sum([-5, -10, -15])\n    -20\n    \"\"\"\n    if not arr:\n        return 0\n\n    largest = max(arr)\n    smallest = min(arr)\n\n    return largest + smallest"}
{"task_id": "Mbpp/477", "solution": "def convert_to_lower(string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The converted string in lower case.\n    \"\"\"\n    return string.lower()\n\n# Test the function\ndef test_convert_to_lower():\n    assert convert_to_lower(\"InValid\") == \"invalid\"\n\n# Run the test\ntest_convert_to_lower()"}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    \"\"\"\n    Remove lowercase substrings from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The input string with lowercase substrings removed.\n\n    Examples:\n        >>> remove_lowercase(\"PYTHon\")\n        'PYTH'\n    \"\"\"\n    return ''.join(char for char in string if char.isupper())"}
{"task_id": "Mbpp/479", "solution": "def first_digit(number):\n    \"\"\"\n    This function takes a number as input and returns the first digit of that number.\n\n    Parameters:\n    number (int): The input number.\n\n    Returns:\n    int: The first digit of the input number.\n    \"\"\"\n    return int(str(number)[0])\n\n# Test the function\ndef test_first_digit():\n    assert first_digit(123) == 1\n\ntest_first_digit()"}
{"task_id": "Mbpp/554", "solution": "def get_odd_integers(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a new list containing only the odd ones.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    list: A new list containing only the odd integers.\n    \"\"\"\n    odd_integers = [num for num in numbers if num % 2 != 0]\n    return odd_integers\n\n# Test the function\ndef test_get_odd_integers():\n    assert get_odd_integers([1, 2, 3, 4, 5, 6]) == [1, 3, 5]\n\ntest_get_odd_integers()"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] ^ arr[j]) % 2 != 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    \"\"\"\n    Toggle the case of all characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The toggled string.\n    \"\"\"\n    toggled_string = \"\"\n    for char in string:\n        if char.islower():\n            toggled_string += char.upper()\n        else:\n            toggled_string += char.lower()\n    return toggled_string"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    This function takes two integers as input and returns the sum of the per-digit difference between them.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    int: The sum of the per-digit difference between num1 and num2.\n\n    Examples:\n    >>> digit_distance_nums(1, 2)\n    1\n    >>> digit_distance_nums(123, 321)\n    12\n    >>> digit_distance_nums(100, 999)\n    29\n    \"\"\"\n    num1_str = str(num1)\n    num2_str = str(num2)\n    distance = 0\n\n    for digit1, digit2 in zip(num1_str, num2_str):\n        distance += abs(int(digit1) - int(digit2))\n\n    return distance"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"}
{"task_id": "Mbpp/560", "solution": "def union_elements(t1, t2):\n    union = set(t1 + t2)  # Combine the two tuples and convert to a set to remove duplicates\n    return tuple(sorted(union))  # Convert the set back to a tuple and sort the elements"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(sublists):\n    \"\"\"\n    Find the length of the longest sublists.\n\n    Args:\n    sublists (list): A list of sublists.\n\n    Returns:\n    int: The length of the longest sublist.\n\n    \"\"\"\n    max_length = 0\n    for sublist in sublists:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    return max_length"}
{"task_id": "Mbpp/563", "solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of values between quotation marks.\n\n    Examples:\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', string)"}
{"task_id": "Mbpp/564", "solution": "def count_Pairs(lst, target):\n    \"\"\"\n    This function takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\n    Parameters:\n    lst (list): A list of integers.\n    target (int): The target value.\n\n    Returns:\n    int: The number of unordered pairs where both elements are unequal.\n\n    Examples:\n    >>> count_Pairs([1, 2, 1], 3)\n    2\n    >>> count_Pairs([1, 2, 3, 4, 5], 6)\n    4\n    >>> count_Pairs([1, 1, 1, 1], 2)\n    0\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] != lst[j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/565", "solution": "def split(string):\n    return list(string)"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Returns the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): The non-negative integer.\n\n    Returns:\n    int: The sum of the digits of n.\n\n    Raises:\n    ValueError: If n is negative.\n\n    Examples:\n    >>> sum_digits(345)\n    12\n    >>> sum_digits(0)\n    0\n    >>> sum_digits(9999)\n    36\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return sum(int(digit) for digit in str(n))"}
{"task_id": "Mbpp/567", "solution": "def is_sorted_list(lst):\n    \"\"\"\n    Check whether a specified list is sorted or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\n# Test the function\nassert is_sorted_list([1,2,4,6,8,10,12,14,16,17]) == True"}
{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Args:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list of N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(n)]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        lst (list): A list of lists, where each sublist contains strings.\n\n    Returns:\n        list: A new list of lists, where each sublist is sorted in lexicographical order.\n\n    Examples:\n        >>> sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])\n        [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/572", "solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums"}
{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    unique_nums = set(numbers)\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product"}
{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(sub_list, main_list):\n    \"\"\"\n    Check if a list is a sublist of another list.\n\n    Args:\n        sub_list (list): The sublist to be checked.\n        main_list (list): The main list to be checked against.\n\n    Returns:\n        bool: True if sub_list is a sublist of main_list, False otherwise.\n    \"\"\"\n    if len(sub_list) > len(main_list):\n        return False\n\n    for i in range(len(main_list) - len(sub_list) + 1):\n        if main_list[i:i + len(sub_list)] == sub_list:\n            return True\n\n    return False"}
{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    This function calculates the last digit in the factorial of a given number.\n\n    Parameters:\n    n (int): The number for which the factorial is to be calculated.\n\n    Returns:\n    int: The last digit in the factorial of n.\n\n    Examples:\n    >>> last_digit_factorial(4)\n    4\n    >>> last_digit_factorial(10)\n    0\n    >>> last_digit_factorial(12)\n    4\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n            result %= 10  # Keep only the last digit\n        return result"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A tuple containing the dissimilar elements.\n\n    Examples:\n        >>> find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10))\n        (3, 6, 7, 10)\n    \"\"\"\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    dissimilar_elements = set1.symmetric_difference(set2)\n    return tuple(dissimilar_elements)"}
{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    \"\"\"\n    Remove uneven elements in the nested mixed tuple.\n\n    Args:\n        nested_tuple (tuple): The input nested mixed tuple.\n\n    Returns:\n        tuple: The modified nested mixed tuple with uneven elements removed.\n\n    Examples:\n        >>> extract_even((4, 5, (7, 6, (2, 4)), 6, 8))\n        (4, (6, (2, 4)), 6, 8)\n    \"\"\"\n    result = []\n    for item in nested_tuple:\n        if isinstance(item, tuple):\n            result.append(extract_even(item))\n        elif item % 2 == 0:\n            result.append(item)\n    return tuple(result)"}
{"task_id": "Mbpp/581", "solution": "def surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid with a given base edge and height.\n\n    Parameters:\n    base_edge (float or int): The length of the base edge of the square pyramid.\n    height (float or int): The height of the square pyramid.\n\n    Returns:\n    float: The surface area of the square pyramid.\n\n    Raises:\n    ValueError: If base_edge or height is negative.\n\n    Examples:\n    >>> surface_area(3, 4)\n    33.0\n    \"\"\"\n    if base_edge < 0 or height < 0:\n        raise ValueError(\"Base edge and height must be non-negative.\")\n\n    base_area = base_edge ** 2\n    lateral_area = 4 * base_edge * height\n    surface_area = base_area + lateral_area\n    return surface_area\n\n# Test the function\nassert surface_area(3, 4) == 33.0"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Returns the nth Catalan number.\n\n    Parameters:\n    n (int): The index of the Catalan number to be calculated.\n\n    Returns:\n    int: The nth Catalan number.\n\n    Raises:\n    ValueError: If n is negative.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    if n == 0 or n == 1:\n        return 1\n\n    result = 1\n    for i in range(1, n + 1):\n        result = (4 * i + 2) * result // (i + 2)\n\n    return result"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(dataset, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n\n    Args:\n        dataset (list): A list of dictionaries, where each dictionary represents an item with 'name' and 'price' keys.\n        n (int): The number of most expensive items to return.\n\n    Returns:\n        list: A list of dictionaries representing the n most expensive items.\n\n    Raises:\n        ValueError: If the dataset is empty or n is less than or equal to 0.\n\n    Examples:\n        >>> expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}], 1)\n        [{'name': 'Item-2', 'price': 555.22}]\n    \"\"\"\n    if not dataset:\n        raise ValueError(\"Dataset cannot be empty\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sorted_dataset = sorted(dataset, key=lambda x: x['price'], reverse=True)\n    return sorted_dataset[:n]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest values in a given list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not nums:\n        return 0\n\n    min_num = float('inf')\n    max_num = float('-inf')\n\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n\n    return max_num - min_num"}
{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    \"\"\"\n    Finds perfect squares between two given numbers.\n\n    Args:\n        start (int): The starting number.\n        end (int): The ending number.\n\n    Returns:\n        list: A list of perfect squares between start and end (inclusive).\n\n    Raises:\n        ValueError: If start is greater than end.\n\n    Examples:\n        >>> perfect_squares(1, 30)\n        [1, 4, 9, 16, 25]\n    \"\"\"\n    if start > end:\n        raise ValueError(\"start must be less than or equal to end\")\n\n    squares = []\n    for num in range(start, end+1):\n        if int(num**0.5)**2 == num:\n            squares.append(num)\n\n    return squares"}
{"task_id": "Mbpp/590", "solution": "import cmath\ndef polar_rect(r, theta):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n\n    Parameters:\n    r (float): The radial distance from the origin.\n    theta (float): The angle in radians.\n\n    Returns:\n    tuple: A tuple containing the rectangular coordinates (x, y).\n\n    Example:\n    >>> polar_rect(3, 4)\n    ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    return (x, y)"}
{"task_id": "Mbpp/591", "solution": "def swap_list(lst):\n    \"\"\"\n    This function takes a list as input and swaps the first and last elements in the list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: The modified list with the first and last elements swapped.\n    \"\"\"\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n\n# Test the function\nassert swap_list([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"}
{"task_id": "Mbpp/592", "solution": "def sum_of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The number of terms in the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n\n    Examples:\n    >>> sum_of_product(3)\n    15\n    \"\"\"\n    def binomial_coefficient(n, k):\n        \"\"\"\n        Calculate the binomial coefficient (n choose k).\n\n        Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n\n        Returns:\n        int: The binomial coefficient (n choose k).\n\n        Examples:\n        >>> binomial_coefficient(5, 3)\n        10\n        \"\"\"\n        if k == 0 or k == n:\n            return 1\n        else:\n            return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n\n    total_sum = 0\n    for i in range(1, n+1):\n        total_sum += i * binomial_coefficient(n, i)\n\n    return total_sum\n\n# Test the function\nassert sum_of_product(3) == 15"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    \"\"\"\n    Remove leading zeroes from an IP address.\n\n    Args:\n        ip_address (str): The IP address to remove leading zeroes from.\n\n    Returns:\n        str: The IP address with leading zeroes removed.\n\n    Examples:\n        >>> removezero_ip(\"216.08.094.196\")\n        '216.8.94.196'\n    \"\"\"\n    octets = ip_address.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    return '.'.join(cleaned_octets)"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(numbers):\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    odd_numbers = [num for num in numbers if num % 2 != 0]\n    \n    if even_numbers and odd_numbers:\n        return even_numbers[0] - odd_numbers[0]\n    else:\n        return 0"}
{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(t):\n    return sys.getsizeof(t)"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n\n    Args:\n        arr1 (list): The first sorted array.\n        arr2 (list): The second sorted array.\n        k (int): The kth element to find.\n\n    Returns:\n        int: The kth element from the merged sorted array.\n\n    Raises:\n        ValueError: If k is out of range.\n\n    Examples:\n        >>> find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5)\n        6\n    \"\"\"\n    merged = sorted(arr1 + arr2)\n    if k > len(merged):\n        raise ValueError(\"k is out of range\")\n    return merged[k - 1]"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\n    \"\"\"\n    Check if a given number is an Armstrong number.\n\n    An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is an Armstrong number, False otherwise.\n    \"\"\"\n    # Convert the number to string to access its digits\n    num_str = str(num)\n    # Get the number of digits in the number\n    num_digits = len(num_str)\n    # Calculate the sum of the digits raised to the power of the number of digits\n    armstrong_sum = sum(int(digit) ** num_digits for digit in num_str)\n    # Check if the calculated sum is equal to the original number\n    return armstrong_sum == num"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Function to find sum and average of first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n\n    \"\"\"\n    sum_of_numbers = (n * (n + 1)) // 2\n    average = sum_of_numbers / n\n    return sum_of_numbers, average"}
{"task_id": "Mbpp/600", "solution": "def is_even(num):\n    \"\"\"\n    Check if a given number is even or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is even, False otherwise.\n    \"\"\"\n    return num % 2 == 0\n\n# Test the function\nassert is_even(1) == False"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(string):\n    \"\"\"\n    Find the first repeated character in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The first repeated character, or an empty string if no repeated character is found.\n    \"\"\"\n    seen_chars = set()\n    for char in string:\n        if char in seen_chars:\n            return char\n        seen_chars.add(char)\n    return \"\""}
{"task_id": "Mbpp/603", "solution": "def get_lucid(n):\n    \"\"\"\n    Returns a list of all lucid numbers smaller than or equal to the given integer.\n\n    Parameters:\n    n (int): The upper limit for lucid numbers.\n\n    Returns:\n    list: A list of lucid numbers.\n\n    \"\"\"\n    lucid_numbers = []\n    for num in range(1, n+1):\n        if is_lucid(num):\n            lucid_numbers.append(num)\n    return lucid_numbers\n\ndef is_lucid(num):\n    \"\"\"\n    Checks if a number is lucid.\n\n    Parameters:\n    num (int): The number to check.\n\n    Returns:\n    bool: True if the number is lucid, False otherwise.\n\n    \"\"\"\n    if num == 1:\n        return True\n    elif num % 2 == 0:\n        return False\n    else:\n        return is_lucid(num - 2 * (num // 2))\n\n# Test the function\nassert get_lucid(10) == [1, 2, 3, 5, 7]"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    \"\"\"\n    Reverse the order of words seperated by spaces in a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The reversed string with words in reverse order.\n\n    Examples:\n    >>> reverse_words(\"python program\")\n    'program python'\n    \"\"\"\n    words = string.split()\n    reversed_words = \" \".join(reversed(words))\n    return reversed_words"}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    \"\"\"\n    Check if the given integer is a prime number.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n\n    Parameters:\n    degrees (float): The angle in degrees.\n\n    Returns:\n    float: The angle in radians.\n    \"\"\"\n    return math.radians(degrees)"}
{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of a matrix.\n\n    Args:\n        matrix (list): A matrix represented as a list of lists.\n        n (int): The index of the column to find the maximum value in.\n\n    Returns:\n        int: The maximum value in the nth column of the matrix.\n\n    Raises:\n        IndexError: If the column index is out of range.\n\n    Examples:\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n        19\n    \"\"\"\n    if n < 0 or n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n\n    max_value = float('-inf')\n    for row in matrix:\n        max_value = max(max_value, row[n])\n\n    return max_value"}
{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    first_list = [sublist[0] for sublist in lst]\n    second_list = [sublist[1] for sublist in lst]\n    return [first_list, second_list]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    total_sum = 0\n    for tup in tuple_list:\n        total_sum += sum(tup)\n    return total_sum"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    averages = []\n    for tuple_ in tuples:\n        total = sum(tuple_)\n        average = total / len(tuple_)\n        averages.append(average)\n    return averages"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(t1, t2):\n    \"\"\"\n    Perform element-wise modulo operation on two tuples of the same length.\n\n    Args:\n        t1 (tuple): The first tuple.\n        t2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the element-wise modulo results.\n\n    Raises:\n        ValueError: If the input tuples are not of the same length.\n\n    Examples:\n        >>> tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5))\n        (0, 4, 5, 1)\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must be of the same length\")\n\n    return tuple(a % b for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divides two lists element-wise.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list with elements obtained by dividing corresponding elements of list1 and list2.\n\n    Raises:\n        ValueError: If the lengths of list1 and list2 are not equal.\n\n    Examples:\n        >>> div_list([4, 5, 6], [1, 2, 3])\n        [4.0, 2.5, 2.0]\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must have the same length\")\n\n    return [a / b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/619", "solution": "def move_num(string):\n    letters = ''\n    numbers = ''\n    for char in string:\n        if char.isdigit():\n            numbers += char\n        else:\n            letters += char\n    return letters + numbers"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    \"\"\"\n    Find the size of the largest subset of a list of numbers so that every pair is divisible.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The size of the largest subset.\n\n    Examples:\n        >>> largest_subset([1, 3, 6, 13, 17, 18])\n        4\n    \"\"\"\n    def is_divisible(a, b):\n        return a % b == 0 or b % a == 0\n\n    def find_subset(numbers, current_subset, remaining_numbers):\n        if not remaining_numbers:\n            return len(current_subset)\n\n        max_subset_size = 0\n        for i, num in enumerate(remaining_numbers):\n            if all(is_divisible(num, n) for n in current_subset):\n                subset = find_subset(numbers, current_subset + [num], remaining_numbers[:i] + remaining_numbers[i+1:])\n                max_subset_size = max(max_subset_size, subset)\n\n        return max_subset_size\n\n    return find_subset(numbers, [], numbers)"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, n):\n    merged_list = sorted(list1 + list2)\n    if n % 2 == 0:\n        median = (merged_list[n // 2 - 1] + merged_list[n // 2]) / 2\n    else:\n        median = merged_list[n // 2]\n    return median"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "solution": "def convert_to_uppercase(string):\n    \"\"\"\n    Converts a given string to uppercase.\n\n    Parameters:\n    string (str): The input string to be converted to uppercase.\n\n    Returns:\n    str: The input string converted to uppercase.\n    \"\"\"\n    return string.upper()\n\n# Test the function\ndef test_convert_to_uppercase():\n    assert convert_to_uppercase(\"person\") == \"PERSON\"\n\n# Run the test\ntest_convert_to_uppercase()"}
{"task_id": "Mbpp/626", "solution": "import math\ndef triangle_area(radius):\n    if radius < 0:\n        return None\n    else:\n        height = math.sqrt(radius**2 - (radius/2)**2)\n        base = radius / 2\n        area = 0.5 * base * height\n        return area"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    return string.replace(' ', '%20')"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    Find even numbers from a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A list of even numbers.\n\n    Examples:\n        >>> find_even_numbers([1, 2, 3, 4, 5])\n        [2, 4]\n    \"\"\"\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return even_numbers\n\n# Test the function\ndef test_find_even_numbers():\n    assert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]\n\ntest_find_even_numbers()"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    x, y = coord\n    adjacent_coords = []\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            if (i, j) != coord:\n                adjacent_coords.append([i, j])\n    return adjacent_coords"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with spaces replaced.\n\n    Examples:\n        >>> replace_spaces('Jumanji The Jungle')\n        'Jumanji_The_Jungle'\n    \"\"\"\n    return string.replace(' ', '_')"}
{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The modified list with zeroes moved to the end.\n\n    Examples:\n        >>> move_zero([1,0,2,0,3,4])\n        [1,2,3,4,0,0]\n    \"\"\"\n    non_zero = [num for num in lst if num != 0]\n    zeroes = [0] * (len(lst) - len(non_zero))\n    return non_zero + zeroes"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(nums, target):\n    \"\"\"\n    Find the sum of xor of all pairs of numbers in the given list.\n\n    Args:\n    nums (list): A list of numbers.\n    target (int): The target value.\n\n    Returns:\n    int: The sum of xor of all pairs of numbers.\n\n    \"\"\"\n    result = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            result += (nums[i] ^ nums[j])\n    return result"}
{"task_id": "Mbpp/635", "solution": "def heap_sort(lst):\n    def heapify(lst, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and lst[i] < lst[left]:\n            largest = left\n\n        if right < n and lst[largest] < lst[right]:\n            largest = right\n\n        if largest != i:\n            lst[i], lst[largest] = lst[largest], lst[i]\n            heapify(lst, n, largest)\n\n    def build_heap(lst):\n        n = len(lst)\n\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(lst, n, i)\n\n    build_heap(lst)\n\n    for i in range(len(lst) - 1, 0, -1):\n        lst[i], lst[0] = lst[0], lst[i]\n        heapify(lst, i, 0)\n\n    return lst"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(amount, expected_amount):\n    \"\"\"\n    Check whether the given amount has no profit and no loss.\n\n    Args:\n    amount (int or float): The amount to be checked.\n    expected_amount (int or float): The expected amount.\n\n    Returns:\n    bool: True if the amount has no profit and no loss, False otherwise.\n    \"\"\"\n    return amount == expected_amount"}
{"task_id": "Mbpp/638", "solution": "def wind_chill(wind_velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Parameters:\n    wind_velocity (float): Wind velocity in km/h.\n    temperature (float): Temperature in celsius.\n\n    Returns:\n    int: Wind chill index rounded to the next integer.\n\n    Raises:\n    ValueError: If the wind velocity is negative or the temperature is below -273.15 (absolute zero).\n\n    \"\"\"\n\n    if wind_velocity < 0:\n        raise ValueError(\"Wind velocity cannot be negative.\")\n    if temperature < -273.15:\n        raise ValueError(\"Temperature cannot be below absolute zero.\")\n\n    wind_chill_index = 13.12 + (0.6215 * temperature) - (11.37 * (wind_velocity ** 0.16)) + (0.3965 * temperature * (wind_velocity ** 0.16))\n    return round(wind_chill_index)"}
{"task_id": "Mbpp/639", "solution": "def sum_name_lengths(names):\n    total_length = 0\n    for name in names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length\n\n# Test the function\ndef test_sum_name_lengths():\n    assert sum_name_lengths(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n\ntest_sum_name_lengths()"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Function to find the nth nonagonal number.\n\n    Parameters:\n    n (int): The position of the nonagonal number to find.\n\n    Returns:\n    int: The nth nonagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return n * (7 * n - 5) // 2"}
{"task_id": "Mbpp/643", "solution": "import re\ndef text_match_wordz_middle(text):\n    \"\"\"\n    Check if a string contains 'z', except at the start and end of the word.\n\n    Args:\n        text (str): The input string to check.\n\n    Returns:\n        bool: True if the string contains 'z', except at the start and end of the word, False otherwise.\n    \"\"\"\n    pattern = r'\\Bz\\B'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array upto a given position.\n\n    Parameters:\n    arr (list): The input list to be reversed.\n    k (int): The position upto which the array should be reversed.\n\n    Returns:\n    list: The reversed array.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Add a dictionary to the tuple. The output should be a tuple.\n\n    Parameters:\n    t (tuple): The input tuple.\n    d (dict): The input dictionary.\n\n    Returns:\n    tuple: The updated tuple with the dictionary added.\n\n    Examples:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} )\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return t + (d,)"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    total_cost = dp[n-1][n-1]\n    average = total_cost / (n + n - 1)\n    return average"}
{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    filtered_students = {name: (height, weight) for name, (height, weight) in students.items() if height >= min_height and weight >= min_weight}\n    return filtered_students\nstudents = {'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}\nmin_height = 6.0\nmin_weight = 70"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    Counts the number of indices where the two input lists have the same values.\n\n    Args:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n\n    Returns:\n    int: The number of indices where the lists have the same values.\n\n    Raises:\n    ValueError: If the input lists are not of the same length.\n\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must be of the same length\")\n\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    result = base ** power\n    digit_sum = sum(int(digit) for digit in str(result))\n    return digit_sum"}
{"task_id": "Mbpp/725", "solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of values between quotation marks.\n\n    Examples:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', string)"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(nums):\n    return tuple(nums[i] * nums[i+1] for i in range(len(nums)-1))"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    This function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\n    Parameters:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n\n    Returns:\n    list: A new list with the element-wise sum of list1 and list2.\n\n    Raises:\n    ValueError: If the input lists have different lengths.\n\n    Examples:\n    >>> sum_list([10, 20, 30], [15, 25, 35])\n    [25, 45, 65]\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length\")\n\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    if not lst:\n        return lst\n    result = [lst[0]]\n    for item in lst[1:]:\n        if item != result[-1]:\n            result.append(item)\n    return result"}
{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone given its radius r and height h.\n\n    Parameters:\n    r (float): The radius of the cone.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The lateral surface area of the cone.\n\n    Raises:\n    ValueError: If either r or h is negative.\n\n    \"\"\"\n    if r < 0 or h < 0:\n        raise ValueError(\"Radius and height must be non-negative.\")\n\n    # Calculate the lateral surface area using the formula:\n    # A = 2 * pi * r * (r + sqrt(r^2 + h^2))\n    lateral_surface_area = 2 * math.pi * r * (r + math.sqrt(r**2 + h**2))\n\n    return lateral_surface_area"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with special characters replaced.\n    \"\"\"\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n\n    Args:\n    arr (list): The sorted array in which to search for the target.\n    target: The number to find the first occurrence of in the array.\n\n    Returns:\n    int: The index of the first occurrence of the target in the array, or -1 if the target is not found.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(lst):\n    \"\"\"\n    Function to find sum of products of all possible sublists of a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int: The sum of products of all possible sublists.\n\n    Examples:\n    >>> sum_Of_Subarray_Prod([1, 2, 3])\n    20\n    \"\"\"\n    result = 0\n    for i in range(len(lst)):\n        for j in range(i, len(lst)):\n            sublist = lst[i:j+1]\n            product = 1\n            for num in sublist:\n                product *= num\n            result += product\n    return result"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(num):\n    \"\"\"\n    Toggle bits of the number except the first and the last bit.\n\n    Args:\n        num (int): The input number.\n\n    Returns:\n        int: The number with toggled bits.\n\n    Raises:\n        TypeError: If the input is not an integer.\n\n    Examples:\n        >>> toggle_middle_bits(9)\n        15\n    \"\"\"\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer\")\n\n    # Check if the number is 0 or 1\n    if num == 0 or num == 1:\n        return num\n\n    # Find the position of the first and last set bits\n    first_bit_pos = num.bit_length() - 1\n    last_bit_pos = 0\n    while num >> last_bit_pos != 1:\n        last_bit_pos += 1\n\n    # Toggle bits between first and last set bits\n    mask = (1 << (first_bit_pos - last_bit_pos)) - 1\n    toggled_num = num ^ mask\n\n    return toggled_num"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, value):\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    value (int): The value to be inserted.\n\n    Returns:\n    int: The index of the left insertion point.\n\n    Examples:\n    >>> left_insertion([1,2,4,5], 6)\n    4\n    \"\"\"\n    left = 0\n    right = len(arr)\n\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left"}
{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(string):\n    \"\"\"\n    Check if the given string starts with a vowel using regex.\n\n    Args:\n        string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    pattern = r\"^[aeiouAEIOU]\"\n    return bool(re.match(pattern, string))"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Find the index of the smallest triangular number with n digits.\n\n    Parameters:\n    n (int): The number of digits in the triangular number.\n\n    Returns:\n    int: The index of the smallest triangular number with n digits.\n\n    \"\"\"\n    def is_triangular(num):\n        \"\"\"\n        Check if a number is a triangular number.\n\n        Parameters:\n        num (int): The number to check.\n\n        Returns:\n        bool: True if the number is a triangular number, False otherwise.\n\n        \"\"\"\n        triangular_sum = 0\n        i = 1\n        while triangular_sum < num:\n            triangular_sum += i\n            i += 1\n        return triangular_sum == num\n\n    index = 1\n    triangular_number = 1\n    while len(str(triangular_number)) < n:\n        index += 1\n        triangular_number += index\n    return index"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even\")\n\n    d = {}\n    for i in range(0, len(t), 2):\n        d[t[i]] = t[i+1]\n\n    return d"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(string):\n    \"\"\"\n    Check if all characters in a string are the same.\n\n    Parameters:\n    string (str): The input string to be checked.\n\n    Returns:\n    bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    return len(set(string)) == 1"}
{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(side_length):\n    \"\"\"\n    Calculate the area of a tetrahedron.\n\n    Parameters:\n    side_length (float): The length of one of the tetrahedron's sides.\n\n    Returns:\n    float: The area of the tetrahedron.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    # Calculate the area using Heron's formula for a tetrahedron\n    area = math.sqrt(3) * (side_length ** 2)\n    return area"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, num_items):\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n\n    Args:\n        lst (list): The list to be rotated.\n        num_items (int): The number of items to rotate by.\n\n    Returns:\n        list: The rotated list.\n\n    Raises:\n        ValueError: If the number of items to rotate by is negative.\n\n    Examples:\n        >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n        [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    if num_items < 0:\n        raise ValueError(\"Number of items to rotate by cannot be negative.\")\n\n    num_items = num_items % len(lst)  # Adjust num_items if greater than list length\n    return lst[-num_items:] + lst[:-num_items]"}
{"task_id": "Mbpp/744", "solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any none value or not.\n\n    Parameters:\n    t (tuple): The input tuple to be checked.\n\n    Returns:\n    bool: True if the tuple has any none value, False otherwise.\n    \"\"\"\n    return None in t"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        num_str = str(num)\n        divisible = True\n        for digit in num_str:\n            if int(digit) != 0 and num % int(digit) != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(num)\n    return result"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(string):\n    \"\"\"\n    Put spaces between words starting with capital letters in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with spaces between capital words.\n\n    Examples:\n        >>> capital_words_spaces(\"Python\")\n        'Python'\n        >>> capital_words_spaces(\"pythonIsAwesome\")\n        'python Is Awesome'\n        >>> capital_words_spaces(\"helloWorld\")\n        'hello World'\n    \"\"\"\n    words = string.split()\n    modified_words = []\n    for word in words:\n        if word[0].isupper():\n            modified_words.append(' ' + word)\n        else:\n            modified_words.append(word)\n    return ''.join(modified_words).strip()"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(lst):\n    \"\"\"\n    Sorts a given list of strings of numbers numerically.\n\n    Args:\n        lst (list): A list of strings of numbers.\n\n    Returns:\n        list: A sorted list of numbers.\n\n    Raises:\n        ValueError: If the input list contains non-numeric strings.\n\n    Examples:\n        >>> sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500'])\n        [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n    \"\"\"\n    try:\n        return sorted(lst, key=lambda x: int(x))\n    except ValueError:\n        raise ValueError(\"Input list contains non-numeric strings.\")"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The updated list with the tuple added.\n\n    Examples:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    lst.extend(tup)\n    return lst"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    \"\"\"\n    Check if the given array represents a min heap or not.\n\n    Parameters:\n    arr (list): The input array to be checked.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        if not heapify(arr, i, n):\n            return False\n    return True\ndef heapify(arr, i, n):\n    \"\"\"\n    Helper function to check if the subtree rooted at index i is a min heap.\n\n    Parameters:\n    arr (list): The input array.\n    i (int): The index of the root of the subtree.\n    n (int): The size of the heap.\n\n    Returns:\n    bool: True if the subtree is a min heap, False otherwise.\n    \"\"\"\n    smallest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[left] < arr[smallest]:\n        smallest = left\n\n    if right < n and arr[right] < arr[smallest]:\n        smallest = right\n\n    if smallest != i:\n        arr[i], arr[smallest] = arr[smallest], arr[i]\n        return heapify(arr, smallest, n)\n    return True"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return 2 * jacobsthal_num(n-1) + 1"}
{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n\n    Args:\n    records (list): A list of tuples containing records with values.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list: A list of the minimum k records.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The second smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty or contains less than two elements.\n\n    Examples:\n        >>> second_smallest([1, 2, -8, -2, 0, -2])\n        -2\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        raise ValueError(\"All elements in the list are the same\")\n\n    return second_smallest"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for string in string_list:\n        if string == string[::-1]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    sublist_counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    return sublist_counts"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(string):\n    try:\n        float(string)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/760", "solution": "def unique_Element(nums):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n\n    Parameters:\n    month_number (int): The month number to be checked.\n\n    Returns:\n    bool: True if the month contains 30 days, False otherwise.\n    \"\"\"\n    if month_number in [4, 6, 9, 11]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    arr.sort()  # Sort the array in ascending order\n    min_diff = float('inf')  # Initialize minimum difference as infinity\n\n    # Iterate through the sorted array to find the minimum difference\n    for i in range(n-1):\n        diff = arr[i+1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    \"\"\"\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def get_next_polite(num):\n        num += 1\n        while True:\n            if is_prime(num):\n                return num\n            num += 1\n\n    polite_num = 1\n    count = 0\n    while count < n:\n        polite_num = get_next_polite(polite_num)\n        count += 1\n    return polite_num"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i+1]))\n    return pairs"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, target_sum):\n    count = 0\n    seen = {}\n    \n    for num in numbers:\n        complement = target_sum - num\n        if complement in seen:\n            count += seen[complement]\n        if num in seen:\n            seen[num] += 1\n        else:\n            seen[num] = 1\n    \n    return count"}
{"task_id": "Mbpp/769", "solution": "def Diff(li1, li2):\n    return [item for item in li1 if item not in li2]"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the fourth power of the first n odd natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> odd_num_sum(2)\n    82\n    >>> odd_num_sum(3)\n    2002\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_fourth_power = sum(i**4 for i in range(1, 2*n, 2))\n    return sum_of_fourth_power"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    opening = \"({[\"\n    closing = \")}]\"\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if opening.index(stack.pop()) != closing.index(char):\n                return False\n    return not stack"}
{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    \"\"\"\n    Remove all the words with length k in the given string.\n\n    Args:\n        string (str): The input string.\n        k (int): The length of words to be removed.\n\n    Returns:\n        str: The modified string with words of length k removed.\n\n    Examples:\n        >>> remove_length('The person is most value tet', 3)\n        'person is most value'\n    \"\"\"\n    words = string.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)"}
{"task_id": "Mbpp/773", "solution": "def occurrence_substring(string, substring):\n    \"\"\"\n    Find the occurrence and position of the substrings within a string. Return None if there is no match.\n\n    Args:\n        string (str): The main string to search within.\n        substring (str): The substring to search for.\n\n    Returns:\n        tuple or None: A tuple containing the substring, starting position, and ending position if a match is found.\n                        Returns None if there is no match.\n    \"\"\"\n    if substring in string:\n        start_pos = string.index(substring)\n        end_pos = start_pos + len(substring)\n        return substring, start_pos, end_pos\n    else:\n        return None\n\n# Test the function\nassert occurrence_substring('python programming, python language', 'python') == ('python', 0, 6)"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index contains odd numbers in a given list.\n\n    Args:\n    lst (list): The input list to be checked.\n\n    Returns:\n    bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 != 1:\n            return False\n    return True"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    return sum(unique_elements)"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n\n    result = [[lst[0]], ]\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            result[-1].append(lst[i])\n        else:\n            result.append([lst[i]])\n\n    return result"}
{"task_id": "Mbpp/780", "solution": "def find_combinations(tuples):\n    combinations = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            combinations.append((tuples[i][0] + tuples[j][0], tuples[i][1] + tuples[j][1]))\n            combinations.append((tuples[i][0] + tuples[j][1], tuples[i][1] + tuples[j][0]))\n            combinations.append((tuples[i][1] + tuples[j][0], tuples[i][0] + tuples[j][1]))\n            combinations.append((tuples[i][1] + tuples[j][1], tuples[i][0] + tuples[j][0]))\n    return combinations"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    \"\"\"\n    Calculate the sum of all odd length subarrays of a given array.\n\n    Parameters:\n    arr (list): The input list of integers.\n\n    Returns:\n    int: The sum of all odd length subarrays.\n\n    Examples:\n    >>> odd_length_sum([1, 2, 4])\n    14\n    \"\"\"\n    n = len(arr)\n    result = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            subarray_length = j - i + 1\n            if subarray_length % 2 != 0:\n                result += sum(arr[i:j+1])\n\n    return result"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(numbers):\n    even_numbers = []\n    odd_numbers = []\n    \n    for num in numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n        else:\n            odd_numbers.append(num)\n    \n    if len(even_numbers) > 0 and len(odd_numbers) > 0:\n        return even_numbers[0] * odd_numbers[0]\n    else:\n        return 0"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    \"\"\"\n    Converts a string representation of a tuple to an integer tuple.\n\n    Args:\n        tuple_str (str): A string representation of a tuple, e.g., \"(7, 8, 9)\"\n\n    Returns:\n        tuple: An integer tuple, e.g., (7, 8, 9)\n\n    Raises:\n        ValueError: If the input string is not a valid tuple representation\n\n    Examples:\n        >>> tuple_str_int(\"(7, 8, 9)\")\n        (7, 8, 9)\n        >>> tuple_str_int(\"(10, 20)\")\n        (10, 20)\n        >>> tuple_str_int(\"(30, 40, 50, 60)\")\n        (30, 40, 50, 60)\n    \"\"\"\n    try:\n        # Remove leading and trailing parentheses and split by commas\n        elements = tuple_str[1:-1].split(',')\n        # Convert each element to integer and remove leading/trailing whitespaces\n        elements = [int(element.strip()) for element in elements]\n        # Create a tuple from the converted elements\n        result = tuple(elements)\n        return result\n    except:\n        raise ValueError(\"Invalid tuple string\")"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(sorted_list, value):\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n\n    Args:\n        sorted_list (list): A sorted list of integers.\n        value (int): The value to be inserted.\n\n    Returns:\n        int: The index of the right insertion point.\n\n    Raises:\n        ValueError: If the input list is not sorted.\n\n    Examples:\n        >>> right_insertion([1,2,4,5], 6)\n        4\n    \"\"\"\n    if not sorted_list == sorted(sorted_list):\n        raise ValueError(\"Input list must be sorted.\")\n\n    if not sorted_list:\n        return 0\n\n    left = 0\n    right = len(sorted_list)\n\n    while left < right:\n        mid = (left + right) // 2\n        if sorted_list[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left"}
{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    \"\"\"\n    Function to match a string that has an 'a' followed by three 'b'.\n\n    Args:\n    text (str): The input string to be matched.\n\n    Returns:\n    bool: True if the pattern is found, False otherwise.\n    \"\"\"\n    pattern = r\"ab{3}\"\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    \"\"\"\n    Create a new tuple from the given string and list.\n\n    Args:\n        lst (list): The list of strings.\n        string (str): The string to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple containing the elements of the list and the string.\n\n    Examples:\n        >>> new_tuple([\"WEB\", \"is\"], \"best\")\n        ('WEB', 'is', 'best')\n    \"\"\"\n    return tuple(lst + [string])"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    \"\"\"\n    Check whether every even index contains even numbers of a given list.\n\n    Args:\n        lst (list): The input list to be checked.\n\n    Returns:\n        bool: True if every even index contains even numbers, False otherwise.\n    \"\"\"\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(tup):\n    \"\"\"\n    Remove tuples from the given tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        tuple: The input tuple with tuples removed.\n\n    Examples:\n        >>> remove_nested((1, 5, 7, (4, 6), 10))\n        (1, 5, 7, 10)\n    \"\"\"\n    return tuple(item for item in tup if not isinstance(item, tuple))"}
{"task_id": "Mbpp/792", "solution": "def count_list(lists):\n    \"\"\"\n    Count the number of lists in a given number of lists.\n\n    Args:\n        lists (list): A list of lists.\n\n    Returns:\n        int: The number of lists in the given number of lists.\n\n    Examples:\n        >>> count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]])\n        4\n    \"\"\"\n    count = 0\n    for lst in lists:\n        count += 1\n    return count"}
{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    \"\"\"\n    Find the last position of an element in a sorted array.\n\n    Parameters:\n    arr (list): The sorted array.\n    target: The element to find the last position of.\n\n    Returns:\n    int: The index of the last position of the target element in the array, or -1 if the target is not found.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            if mid == len(arr) - 1 or arr[mid + 1] != target:\n                return mid\n            else:\n                left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1"}
{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(text):\n    \"\"\"\n    Matches a string that has an 'a' followed by anything, ending in 'b'.\n\n    Args:\n        text (str): The input string to be matched.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"a.*b$\"\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    This function takes a dictionary as input and returns the sum of all its values.\n\n    Parameters:\n    dictionary (dict): A dictionary containing key-value pairs.\n\n    Returns:\n    int: The sum of all values in the dictionary.\n    \"\"\"\n    return sum(dictionary.values())"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    This function finds the sum of all odd natural numbers within the range l and r.\n\n    Parameters:\n    l (int): The lower bound of the range.\n    r (int): The upper bound of the range.\n\n    Returns:\n    int: The sum of all odd natural numbers within the range.\n\n    Raises:\n    ValueError: If l or r is not a positive integer or if l is greater than r.\n\n    Examples:\n    >>> sum_in_range(2, 5)\n    8\n    >>> sum_in_range(1, 10)\n    25\n    >>> sum_in_range(5, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid range: l should be less than or equal to r.\n    \"\"\"\n\n    if not isinstance(l, int) or not isinstance(r, int) or l <= 0 or r <= 0:\n        raise ValueError(\"Invalid range: l and r should be positive integers.\")\n\n    if l > r:\n        raise ValueError(\"Invalid range: l should be less than or equal to r.\")\n\n    odd_sum = 0\n    for num in range(l, r+1):\n        if num % 2 != 0:\n            odd_sum += num\n\n    return odd_sum"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"\n    This function takes an array as input and returns the sum of all its elements.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The sum of all elements in the array.\n    \"\"\"\n    total = 0\n    for num in arr:\n        total += num\n    return total"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(num, d):\n    \"\"\"\n    Function to rotate left bits by d bits a given number.\n\n    Parameters:\n    num (int): The number to be rotated.\n    d (int): The number of bits to rotate.\n\n    Returns:\n    int: The rotated number.\n\n    Example:\n    >>> left_rotate(16, 2)\n    64\n    \"\"\"\n    # Convert the number to binary string\n    binary_str = bin(num)[2:]\n\n    # Pad the binary string with leading zeros if necessary\n    binary_str = binary_str.zfill(32)\n\n    # Perform left rotation\n    rotated_binary_str = binary_str[d:] + binary_str[:d]\n\n    # Convert the rotated binary string back to decimal\n    rotated_num = int(rotated_binary_str, 2)\n\n    return rotated_num"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(string):\n    \"\"\"\n    Remove all whitespaces from a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return string.replace(' ', '')"}
{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n        c (int): The third integer.\n\n    Returns:\n        int: The count of equal numbers.\n\n    Examples:\n        >>> test_three_equal(1, 1, 1)\n        3\n        >>> test_three_equal(2, 2, 1)\n        2\n        >>> test_three_equal(3, 2, 1)\n        0\n    \"\"\"\n    if a == b and b == c:\n        return 3\n    elif a == b or b == c or a == c:\n        return 2\n    else:\n        return 0"}
{"task_id": "Mbpp/803", "solution": "import math\ndef is_perfect_square(num):\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    square_root = int(math.sqrt(num))\n    return square_root * square_root == num"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if the product is even, False otherwise.\n    \"\"\"\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lst):\n    max_sum = float('-inf')\n    max_sum_list = None\n    for sublist in lst:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_sum_list = sublist\n    return max_sum_list"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(string):\n    \"\"\"\n    Find the maximum run of uppercase characters in the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The length of the maximum run of uppercase characters.\n\n    Examples:\n        >>> max_run_uppercase('GeMKSForGERksISBESt')\n        5\n    \"\"\"\n    max_run = 0\n    current_run = 0\n\n    for char in string:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n\n    return max_run"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The first odd number found, or None if no odd number is found.\n    \"\"\"\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuples contain the k or not.\n\n    Args:\n    tup (tuple): The input tuple to be checked.\n    k (int): The value to be checked for in the tuple.\n\n    Returns:\n    bool: True if the tuple contains the k, False otherwise.\n    \"\"\"\n    return k in tup"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    Check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\n    Args:\n    tuple1 (tuple): The first tuple.\n    tuple2 (tuple): The second tuple.\n\n    Returns:\n    bool: True if each element of tuple2 is smaller than its corresponding element in tuple1, False otherwise.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        return False\n\n    for i in range(len(tuple1)):\n        if tuple2[i] >= tuple1[i]:\n            return False\n\n    return True"}
