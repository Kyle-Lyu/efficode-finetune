{"date": "2025-01-17 12:14", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long(string):\n    words = string.split()\n    return [word for word in words if len(word) >= 4]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        numbers (list): A list of numbers.\n        n (int): The number of largest integers to find.\n    \n    Returns:\n        list: A list of the n largest integers, in descending order.\n    \"\"\"\n    # Use a min-heap to store the largest n integers\n    heap = []\n    \n    # Iterate through the numbers\n    for num in numbers:\n        # Add the negative of the number to the heap\n        # Since a min-heap returns the smallest element first, we negate the number to get the largest\n        heapq.heappush(heap, -num)\n        \n        # If the heap size exceeds n, remove the smallest element\n        if len(heap) > n:\n            heapq.heappop(heap)\n    \n    # Return the n largest integers in descending order\n    return sorted([-num for num in heap], reverse=True)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[25, 35, 22, 85, 14, 65, 75, 22, 58], 3]], "plus_fail_tests": [[[9, 8, 7, 6, 5, 4, 3, 2, 1], 3]]}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    # Find the first and last occurrence of the character in the string\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    \n    # If the character is not present in the string, return the original string\n    if first_index == -1 or last_index == -1:\n        return string\n    \n    # Remove the first and last occurrence of the character from the string\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    else:\n        return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    \"\"\"\n    Function to find squares of individual elements in a list.\n    \n    Parameters:\n    nums (list): A list of numbers.\n    \n    Returns:\n    list: A list of squares of the input numbers.\n    \"\"\"\n    return [num**2 for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    - matrix: A 2D list representing the matrix.\n\n    Returns:\n    - The sorted matrix.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Sort the matrix based on the row sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n\n    return sorted_matrix", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(input_string):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    # Split the input string by underscores and check if each part is lowercase\n    parts = input_string.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    total_sum = 0\n    for item in lst:\n        if isinstance(item, list):\n            total_sum += recursive_list_sum(item)\n        else:\n            total_sum += item\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base (float): The length of the base of the triangular prism.\n    height (float): The height of the triangular prism.\n    length (float): The length of the triangular prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n\n    Raises:\n    ValueError: If any of the input values are negative.\n\n    \"\"\"\n    if base < 0 or height < 0 or length < 0:\n        raise ValueError(\"Input values cannot be negative.\")\n\n    base_area = (base * height) / 2\n    volume = base_area * length\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    \"\"\"\n    Find the shared elements from the given two lists.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n\n    Returns:\n    set: A set containing the shared elements.\n\n    Example:\n    >>> similar_elements((3, 4, 5, 6), (5, 7, 4, 10))\n    {4, 5}\n    \"\"\"\n    return set(list1) & set(list2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs(num1, num2):\n    \"\"\"\n    Check whether the given two integers have opposite sign or not.\n    \n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n    \n    Returns:\n    bool: True if the two integers have opposite signs, False otherwise.\n    \"\"\"\n    return (num1 < 0 and num2 > 0) or (num1 > 0 and num2 < 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Find the nth centered hexagonal number.\n\n    A centered hexagonal number is a figurate number that represents a hexagon.\n    It can be calculated using the formula H(n) = 2n^2 - n, where n is the position of the number in the sequence.\n\n    Args:\n        n (int): The position of the centered hexagonal number to find.\n\n    Returns:\n        int: The nth centered hexagonal number.\n\n    Raises:\n        ValueError: If n is less than 1.\n\n    Examples:\n        >>> centered_hexagonal_number(10)\n        271\n        >>> centered_hexagonal_number(1)\n        1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n    return 2 * n**2 - n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1000000]]}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Parameters:\n    n (int): The number of rows.\n    m (int): The number of columns.\n\n    Returns:\n    int: The Eulerian number a(n, m).\n\n    Raises:\n    ValueError: If n or m is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    if not isinstance(m, int) or m <= 0:\n        raise ValueError(\"m must be a positive integer\")\n\n    if m == 1:\n        return 2**n\n    elif n == 1:\n        return m + 1\n    else:\n        return eulerian_num(n-1, m) + eulerian_num(n, m-1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 1]], "plus_fail_tests": [[0, 0]]}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    Check whether the length of the word is odd or not.\n\n    Parameters:\n    word (str): The word to check.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(string1, string2):\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string1 (str): The first string.\n        string2 (str): The second string.\n\n    Returns:\n        str: The modified string with characters removed.\n\n    Examples:\n        >>> remove_dirty_chars(\"probasscurve\", \"pros\")\n        'bacuve'\n    \"\"\"\n    clean_string = \"\"\n    for char in string1:\n        if char not in string2:\n            clean_string += char\n    return clean_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, rotations):\n    count = 0\n    length = len(binary_string)\n    \n    for i in range(rotations):\n        binary_string = binary_string[1:] + binary_string[0]  # Rotate the binary string\n        decimal_value = int(binary_string, 2)  # Convert the rotated string to decimal\n        \n        if decimal_value % 2 != 0:  # Check if the decimal value is odd\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    Function to find the nth octagonal number.\n    \n    Parameters:\n    n (int): The position of the octagonal number to be found.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    return n * (3 * n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns(patterns, sequence):\n    \"\"\"\n    Check whether the given sequence follows the patterns.\n\n    Args:\n    patterns (list): A list of patterns to be followed.\n    sequence (list): A list of elements to be checked against the patterns.\n\n    Returns:\n    bool: True if the sequence follows the patterns, False otherwise.\n    \"\"\"\n    if len(patterns) != len(sequence):\n        return False\n\n    pattern_dict = {}\n    for i in range(len(patterns)):\n        if patterns[i] not in pattern_dict:\n            pattern_dict[patterns[i]] = sequence[i]\n        else:\n            if pattern_dict[patterns[i]] != sequence[i]:\n                return False\n\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["red", "green", "greenn"], ["a", "b", "b"]]], "plus_fail_tests": [[["red", "green", "blue", "yellow"], ["a", "b", "b", "c"]]]}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    \"\"\"\n    Finds the length of the smallest list in a list of lists.\n\n    Args:\n    - list_of_lists: A list of lists.\n\n    Returns:\n    - The length of the smallest list.\n\n    Raises:\n    - ValueError: If the input is an empty list.\n\n    Examples:\n    >>> Find_Min_Length([[1],[1,2]])\n    1\n    >>> Find_Min_Length([[1,2,3],[4,5],[6]])\n    1\n    >>> Find_Min_Length([[1,2],[3,4,5],[6,7,8,9]])\n    2\n    \"\"\"\n\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    min_length = float('inf')\n    for lst in list_of_lists:\n        min_length = min(min_length, len(lst))\n\n    return min_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    # Convert the list of digits to a string\n    digits_str = [str(digit) for digit in digits]\n    \n    # Sort the string in descending order\n    sorted_digits = sorted(digits_str, reverse=True)\n    \n    # Join the sorted digits to form the largest number\n    max_num = int(''.join(sorted_digits))\n    \n    return max_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Parameters:\n    a (int or float): The base number.\n    b (int): The exponent.\n\n    Returns:\n    int or float: The result of 'a' raised to the power 'b'.\n    \"\"\"\n    return a ** b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_monotonic(arr):\n    \"\"\"\n    Check whether the given array is monotonic or not.\n\n    Parameters:\n    arr (list): The input array to be checked.\n\n    Returns:\n    bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n\n    if len(arr) <= 1:\n        return True\n\n    increasing = decreasing = True\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            increasing = False\n        if arr[i] < arr[i + 1]:\n            decreasing = False\n\n    return increasing or decreasing\n\n# Test cases\nassert is_monotonic([6, 5, 4, 4]) == True\nassert is_monotonic([1, 2, 3, 4]) == True\nassert is_monotonic([4, 3, 2, 1]) == True\nassert is_monotonic([1, 2, 4, 3]) == False\nassert is_monotonic([1, 1, 1, 1]) == True\nassert is_monotonic([1, 2, 3, 2, 1]) == True\nassert is_monotonic([1, 2, 3, 3, 2, 1]) == True\nassert is_monotonic([1, 2, 3, 4, 3, 2, 1]) == False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere.\n\n    Args:\n        radius (float): The radius of the sphere.\n\n    Returns:\n        float: The volume of the sphere.\n\n    Raises:\n        ValueError: If the radius is negative.\n\n    Examples:\n        >>> volume_sphere(10)\n        4188.790204786391\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def newman_conway(n):\n    \"\"\"\n    Find the nth number in the Newman Conway sequence.\n\n    Parameters:\n    n (int): The position of the number to find in the sequence.\n\n    Returns:\n    int: The nth number in the Newman Conway sequence.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n\n    sequence = [0, 1, 1]  # Initialize the sequence with the first three numbers\n\n    for i in range(3, n + 1):\n        sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n\n    return sequence[n]\n\n\n# Test the function\nassert newman_conway(10) == 6", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    Finds the closest smaller number than n.\n\n    Args:\n        n (int): The number to find the closest smaller number for.\n\n    Returns:\n        int: The closest smaller number than n.\n\n    Raises:\n        ValueError: If n is less than or equal to 0.\n\n    Examples:\n        >>> closest_num(11)\n        10\n        >>> closest_num(10)\n        9\n        >>> closest_num(1)\n        0\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n\n    return n - 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The index of the element to find (1-based indexing).\n\n    Returns:\n    int: The kth element in the array.\n\n    Raises:\n    IndexError: If the index k is out of range.\n\n    Examples:\n    >>> kth_element([12, 3, 5, 7, 19], 2)\n    3\n    >>> kth_element([1, 2, 3, 4, 5], 5)\n    5\n    >>> kth_element([10, 20, 30], 3)\n    30\n    \"\"\"\n\n    if k < 1 or k > len(arr):\n        raise IndexError(\"Index out of range\")\n\n    return arr[k - 1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "import math\ndef multiply_num(numbers):\n    \"\"\"\n    Multiply all the numbers in a list and divide with the length of the list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The result of multiplying all the numbers and dividing by the length of the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> multiply_num([8, 2, 3, -1, 7])\n        -67.2\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    product = 1\n    for num in numbers:\n        product *= num\n\n    return product / len(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort(lst):\n    gap = len(lst)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(lst):\n            if lst[i] > lst[i + gap]:\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                sorted = False\n            i += 1\n\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist(list1, sublist):\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n    \n    Parameters:\n    - list1 (list): The main list to be checked.\n    - sublist (list): The sublist to be searched within the main list.\n    \n    Returns:\n    - bool: True if the sublist is found in the main list, False otherwise.\n    \"\"\"\n    if len(sublist) > len(list1):\n        return False\n    \n    for i in range(len(list1) - len(sublist) + 1):\n        if list1[i:i+len(sublist)] == sublist:\n            return True\n    \n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n\n    Parameters:\n    side_length (int or float): The length of the side of the square.\n\n    Returns:\n    int or float: The perimeter of the square.\n\n    Raises:\n    ValueError: If the side length is negative.\n\n    Examples:\n    >>> square_perimeter(10)\n    40\n    >>> square_perimeter(0)\n    0\n    >>> square_perimeter(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length cannot be negative.\n    \"\"\"\n\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n\n    return 4 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    Parameters:\n    n (int): The index of the tetrahedral number to calculate.\n\n    Returns:\n    int: The nth tetrahedral number.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n    return (n * (n + 1) * (n + 2)) // 6", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[false]]}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        lst (list): A list of lists containing strings.\n\n    Returns:\n        list: A new list of lists with each sublist sorted.\n\n    Examples:\n        >>> sort_sublists([[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]])\n        [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n\n    surface_area = 4 * math.pi * radius**2\n    return surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    \"\"\"\n    Converts a snake case string to camel case string.\n\n    Parameters:\n    snake_str (str): The snake case string to be converted.\n\n    Returns:\n    str: The camel case string.\n\n    Examples:\n    >>> snake_to_camel('python_program')\n    'PythonProgram'\n    >>> snake_to_camel('hello_world')\n    'HelloWorld'\n    >>> snake_to_camel('my_variable')\n    'MyVariable'\n    \"\"\"\n\n    # Split the snake case string into words\n    words = snake_str.split('_')\n\n    # Capitalize the first letter of each word except the first word\n    words = [words[0]] + [word.capitalize() for word in words[1:]]\n\n    # Join the words to form the camel case string\n    camel_str = ''.join(words)\n\n    return camel_str", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python_program"]], "plus_fail_tests": [["___python_program"]]}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer(string):\n    \"\"\"\n    Check if a string represents an integer or not.\n    \n    Parameters:\n    string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    \"\"\"\n    Check if all tuples in the given list have equal length.\n\n    Args:\n    tuples (list): A list of tuples.\n\n    Returns:\n    bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    lengths = set(len(t) for t in tuples)\n    return len(lengths) == 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(decimal):\n    if decimal == 0:\n        return '0'\n    \n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal //= 2\n    \n    return binary", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        int: The length of the longest word.\n\n    Raises:\n        ValueError: If the input is an empty list.\n\n    Examples:\n        >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n        7\n        >>> len_log([\"apple\", \"banana\", \"cherry\"])\n        6\n        >>> len_log([])\n        Traceback (most recent call last):\n            ...\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not words:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    return max(len(word) for word in words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(num):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    # Check if the number is negative\n    if num < 0:\n        return False\n\n    # Check if the number is a perfect square\n    if int(num ** 0.5) ** 2 == num:\n        return True\n\n    # Check if the number can be represented as the difference of two squares\n    for i in range(int(num ** 0.5) + 1):\n        j = int((num - i*i) ** 0.5)\n        if i*i + j*j == num:\n            return True\n\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[991]]}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def is_palindrome(n):\n    \"\"\"\n    Check if a given number is a palindrome.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is a palindrome, False otherwise.\n    \"\"\"\n    return str(n) == str(n)[::-1]\ndef next_smallest_palindrome(n):\n    \"\"\"\n    Find the next smallest palindrome of a specified integer.\n    \n    Parameters:\n    n (int): The specified integer.\n    \n    Returns:\n    int: The next smallest palindrome.\n    \"\"\"\n    if n < 10:\n        return n + 1\n    \n    while True:\n        n += 1\n        if is_palindrome(n):\n            return n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[9]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        tuples_list (list): A list of tuples.\n        k (int): The number to check divisibility against.\n\n    Returns:\n        list: A list of tuples with all elements divisible by k.\n\n    Examples:\n        >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n        [(6, 24, 12)]\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(elem % k == 0 for elem in t):\n            result.append(t)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(number):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \n    Args:\n        number (int): The number to be checked.\n        \n    Returns:\n        bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string and reverse it\n    reversed_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_num = int(reversed_str)\n    \n    # Check if the number is one less than twice its reverse\n    if number == (reversed_num * 2) - 1:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring(strings, substring):\n    \"\"\"\n    Check if a string is present as a substring in a given list of string values.\n\n    Args:\n        strings (list): A list of string values.\n        substring (str): The substring to search for.\n\n    Returns:\n        bool: True if the substring is found in any of the strings, False otherwise.\n    \"\"\"\n    for string in strings:\n        if substring in string:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference(tuple_list):\n    max_diff = 0\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            diff = abs(tuple_list[i][0] - tuple_list[j][0]) + abs(tuple_list[i][1] - tuple_list[j][1])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 5], [1, 7], [10, 3], [1, 2]]]], "plus_fail_tests": [[[[1000000, 999999], [10000000, 9999999], [100000000, 99999999], [1000000000, 999999999]]]]}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(number):\n    \"\"\"\n    Check if a number is divisible by 11.\n\n    Parameters:\n    number (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    # Convert the number to a string for easier manipulation\n    number_str = str(number)\n\n    # Initialize the sum of odd-positioned digits and the sum of even-positioned digits\n    sum_odd = 0\n    sum_even = 0\n\n    # Iterate through the digits of the number\n    for i, digit in enumerate(number_str):\n        # Convert the digit back to an integer\n        digit = int(digit)\n\n        # Check if the position of the digit is odd or even\n        if i % 2 == 0:\n            sum_odd += digit\n        else:\n            sum_even += digit\n\n    # Calculate the difference between the sums\n    diff = sum_odd - sum_even\n\n    # Check if the difference is divisible by 11\n    if diff % 11 == 0:\n        return True\n    else:\n        return False\n\n# Test the function\nassert is_divisible_by_11(12345) == False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists(lst):\n    freq_dict = {}\n    for sublist in lst:\n        for element in sublist:\n            if element in freq_dict:\n                freq_dict[element] += 1\n            else:\n                freq_dict[element] = 1\n    return freq_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> smallest_num([10, 20, 1, 45, 99])\n        1\n        >>> smallest_num([-5, 0, 100, -1000, 1000])\n        -1000\n        >>> smallest_num([])\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n    lst (list): A list of tuples.\n\n    Returns:\n    str: The first value of the tuple with the smallest second value.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    >>> index_minimum([('Alice', 50), ('Bob', 30), ('Charlie', 40)])\n    'Bob'\n    >>> index_minimum([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list cannot be empty.\n    \"\"\"\n\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    min_index = 0\n    for i in range(1, len(lst)):\n        if lst[i][1] < lst[min_index][1]:\n            min_index = i\n\n    return lst[min_index][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(number):\n    \"\"\"\n    Check whether the given number is undulating or not.\n    \n    An undulating number is a number that contains alternating odd and even digits.\n    For example, 1212121 is an undulating number since it has alternating odd and even digits (1, 2, 1, 2, 1, 2, 1).\n    \n    Args:\n        number (int): The number to be checked.\n    \n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string for easier manipulation\n    number_str = str(number)\n    \n    # Check if the length of the number is less than 3\n    if len(number_str) < 3:\n        return False\n    \n    # Get the first two digits of the number\n    first_digit = int(number_str[0])\n    second_digit = int(number_str[1])\n    \n    # Check if the first two digits have alternating odd and even properties\n    if (first_digit % 2 == 0 and second_digit % 2 != 0) or (first_digit % 2 != 0 and second_digit % 2 == 0):\n        # Iterate through the remaining digits and check if they have alternating odd and even properties\n        for i in range(2, len(number_str), 2):\n            if int(number_str[i]) % 2 == first_digit % 2 or int(number_str[i]) % 2 == second_digit % 2:\n                return False\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1212121]], "plus_fail_tests": [[2121212121212121]]}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuples.\n\n    Args:\n        lst (list): The list to be appended.\n        tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n        tuple: The resulting tuple with the list appended.\n\n    Raises:\n        TypeError: If the input is not of the correct type.\n\n    Examples:\n        >>> add_lists([5, 6, 7], (9, 10))\n        (9, 10, 5, 6, 7)\n    \"\"\"\n    if not isinstance(lst, list) or not isinstance(tpl, tuple):\n        raise TypeError(\"Input must be a list and a tuple.\")\n\n    return tpl + tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    \n    # Merge dict1 into merged_dict\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    \n    # Merge dict2 into merged_dict\n    for key, value in dict2.items():\n        merged_dict[key] = value\n    \n    # Merge dict3 into merged_dict\n    for key, value in dict3.items():\n        merged_dict[key] = value\n    \n    return merged_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks(lst):\n    lst.sort(key=lambda x: x[1])\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n    nested_lists (list): A list of lists containing integers.\n\n    Returns:\n    list: A list of common elements found in all nested lists.\n\n    \"\"\"\n    common_elements = set(nested_lists[0])  # Initialize with the first nested list\n\n    for nested_list in nested_lists[1:]:\n        common_elements.intersection_update(nested_list)  # Update the common elements with the intersection of each nested list\n\n    return list(common_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count(lst):\n    \"\"\"\n    Counts the number of True values in the given list.\n\n    Args:\n        lst (list): A list of boolean values.\n\n    Returns:\n        int: The count of True values in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-boolean values.\n\n    Examples:\n        >>> count([True, False, True])\n        2\n        >>> count([False, False, False])\n        0\n        >>> count([True, True, True, False, True])\n        4\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    count = 0\n    for item in lst:\n        if not isinstance(item, bool):\n            raise ValueError(\"List must contain only boolean values.\")\n        if item:\n            count += 1\n\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number using a recursive approach.\n\n    Parameters:\n    n (int): The index of the Bell number to calculate.\n\n    Returns:\n    int: The nth Bell number.\n\n    Raises:\n    ValueError: If n is less than 0.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int(t):\n    \"\"\"\n    Converts a given tuple of positive integers into a single integer.\n    \n    Parameters:\n    t (tuple): The input tuple of positive integers.\n    \n    Returns:\n    int: The single integer representation of the input tuple.\n    \"\"\"\n    return int(''.join(map(str, t)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    return string.split()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    max_diff = 0\n    count_zeroes = 0\n    count_ones = 0\n\n    for char in binary_string:\n        if char == '0':\n            count_zeroes += 1\n        else:\n            count_ones += 1\n        \n        diff = count_ones - count_zeroes\n        if diff < 0:\n            count_zeroes = 0\n            count_ones = 0\n        else:\n            max_diff = max(max_diff, diff)\n    \n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["11000010001"]], "plus_fail_tests": [["0000001110000001111111"]]}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if mid % 2 == 0:\n            if arr[mid] == arr[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        else:\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return arr[left]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum_common_divisors(a, b):\n    \"\"\"\n    Finds the sum of common divisors of two given numbers.\n\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n\n    Returns:\n    int: The sum of common divisors of a and b.\n    \"\"\"\n    def get_divisors(n):\n        \"\"\"\n        Generates a list of divisors of a given number.\n\n        Parameters:\n        n (int): The number to find divisors for.\n\n        Returns:\n        list: A list of divisors of n.\n        \"\"\"\n        divisors = []\n        for i in range(1, n+1):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    divisors_a = get_divisors(a)\n    divisors_b = get_divisors(b)\n    common_divisors = list(set(divisors_a) & set(divisors_b))\n    return sum(common_divisors)\n\n# Test the function\nassert sum_common_divisors(10, 15) == 6", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to calculate whether the matrix is a magic square.\n    \"\"\"\n    # Check if the matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n    \n    # Calculate the expected sum\n    n = len(matrix)\n    expected_sum = n * (n ** 2 + 1) // 2\n    \n    # Calculate the row sums\n    row_sums = [sum(row) for row in matrix]\n    \n    # Check if all row sums are equal to the expected sum\n    if not all(row_sum == expected_sum for row_sum in row_sums):\n        return False\n    \n    # Calculate the column sums\n    column_sums = [sum(column) for column in zip(*matrix)]\n    \n    # Check if all column sums are equal to the expected sum\n    if not all(column_sum == expected_sum for column_sum in column_sums):\n        return False\n    \n    # Calculate the diagonal sums\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum_2 = sum(matrix[i][n-i-1] for i in range(n))\n    \n    # Check if both diagonal sums are equal to the expected sum\n    if diagonal_sum_1 != expected_sum or diagonal_sum_2 != expected_sum:\n        return False\n    \n    # If all checks pass, the matrix is a magic square\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[7, 7], [7, 7]]]]}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Function to multiply two integers.\n\n    Parameters:\n    a (int): First integer.\n    b (int): Second integer.\n\n    Returns:\n    int: The product of the two integers.\n    \"\"\"\n    return a * b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import cmath\nimport math\ndef angle_complex(z):\n    \"\"\"\n    Calculate the angle (in radians) of a complex number.\n\n    Parameters:\n    z (complex): The complex number.\n\n    Returns:\n    float: The angle (in radians) of the complex number.\n\n    \"\"\"\n    return cmath.phase(z)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list of elements.\n\n    \"\"\"\n\n    def flip(arr, i):\n        \"\"\"\n        Flips the elements in the list from index 0 to i.\n\n        Parameters:\n        arr (list): The list of elements.\n        i (int): The index up to which the elements should be flipped.\n\n        Returns:\n        list: The list with the flipped elements.\n\n        \"\"\"\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n        return arr\n\n    def find_max(arr, n):\n        \"\"\"\n        Finds the index of the maximum element in the list up to index n.\n\n        Parameters:\n        arr (list): The list of elements.\n        n (int): The index up to which the maximum element should be searched.\n\n        Returns:\n        int: The index of the maximum element.\n\n        \"\"\"\n        max_idx = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n\n    n = len(arr)\n    curr_size = n\n    while curr_size > 1:\n        max_idx = find_max(arr, curr_size)\n        if max_idx != curr_size - 1:\n            arr = flip(arr, max_idx)\n            arr = flip(arr, curr_size - 1)\n        curr_size -= 1\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple(lst):\n    max_product = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            product = abs(lst[i][0] * lst[j][0]) * abs(lst[i][1] * lst[j][1])\n            if product > max_product:\n                max_product = product\n    return max_product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[2, 7], [2, 6], [1, 8], [4, 9]]]], "plus_fail_tests": [[[[-10, 20], [15, -2], [-5, 10]]]]}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    words = sentence.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    \"\"\"\n    Converts a tuple to a string.\n\n    Args:\n        tup (tuple): The input tuple to be converted.\n\n    Returns:\n        str: The converted string.\n\n    Examples:\n        >>> tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))\n        'exercises'\n    \"\"\"\n    return ''.join(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers in a given list of numbers.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The sum of the negative numbers in the list.\n\n    Raises:\n    TypeError: If the input is not a list.\n    ValueError: If the list does not contain any negative numbers.\n\n    Examples:\n    >>> sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])\n    -32\n    >>> sum_negativenum([1, 2, 3, 4, 5])\n    0\n    \"\"\"\n\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    negatives = [num for num in numbers if num < 0]\n\n    if not negatives:\n        raise ValueError(\"List does not contain any negative numbers.\")\n\n    return sum(negatives)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    vowel_list = [c for c in s if c in vowels]\n    vowel_list.reverse()\n    result = \"\"\n    vowel_index = 0\n    for c in s:\n        if c in vowels:\n            result += vowel_list[vowel_index]\n            vowel_index += 1\n        else:\n            result += c\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    \n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    if non_zero_count == 0:\n        return 0\n    \n    return zero_count / non_zero_count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list): A list of lists containing numbers.\n\n    Returns:\n        set: A set containing all the numbers from the list of lists.\n\n    Example:\n        >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n        {3, 4, 5, 7, 1}\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    \"\"\"\n    Finds integers x and y that satisfy ax + by = n as a tuple, or returns None if no solution exists.\n\n    Parameters:\n    a (int): First integer.\n    b (int): Second integer.\n    n (int): Target sum.\n\n    Returns:\n    tuple or None: A tuple (x, y) if a solution exists, otherwise None.\n    \"\"\"\n\n    # Check if n is divisible by the greatest common divisor of a and b\n    gcd = math.gcd(a, b)\n    if n % gcd != 0:\n        return None\n\n    # Solve the equation using the extended Euclidean algorithm\n    x0, y0 = 0, 1\n    x1, y1 = 1, 0\n    a, b = b, a  # Swap values to make calculations easier\n\n    while a != 0:\n        q = b // a\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n        b, a = a, b - q * a\n\n    # Scale the solution to ensure x and y are integers\n    x = x0 * n // gcd\n    y = y0 * n // gcd\n\n    return x, y", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 7]], "plus_fail_tests": [[100, 50, 4000]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \"\"\"\n    circumference = 2 * math.pi * radius\n    return circumference", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculates the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n        lst (list): The input list of numbers.\n        start (int): The starting index of the range.\n        end (int): The ending index of the range.\n\n    Returns:\n        int: The sum of numbers within the specified range.\n\n    Raises:\n        IndexError: If the start or end index is out of range.\n\n    Examples:\n        >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10)\n        29\n        >>> sum_range_list([1, 2, 3, 4, 5], 0, 4)\n        15\n        >>> sum_range_list([1, 2, 3, 4, 5], 1, 3)\n        9\n    \"\"\"\n    if start < 0 or end >= len(lst) or start > end:\n        raise IndexError(\"Invalid range\")\n\n    return sum(lst[start:end+1])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 7, 5]]}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    if len(list1) > 0:\n        list1[-1] = list2\n        return list1\n    else:\n        return list2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 9, 10], [2, 4, 6, 8]]], "plus_fail_tests": [[[1, 2, 3, 4], []]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    if len(arr) < 2:\n        return None\n    \n    max_diff = abs(arr[0] - arr[1])\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    \n    return max_diff", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1]]]}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in a string with a given character and returns the modified string.\n\n    Args:\n        string (str): The input string.\n        character (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by the given character.\n    \"\"\"\n    return string.replace(' ', character)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(num):\n    \"\"\"\n    Check whether the given number can be represented as sum of non-zero powers of 2 or not.\n    \n    Parameters:\n    num (int): The number to be checked.\n    \n    Returns:\n    bool: True if the number can be represented as sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    if num <= 0:\n        return False\n    \n    while num > 0:\n        if num & 1 == 0:  # Check if the least significant bit is 0\n            return False\n        num >>= 1  # Right shift the number by 1 bit\n        \n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[123456788]]}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the number of items that are identical in the same position of three given lists.\n    \n    Args:\n        list1 (list): The first input list.\n        list2 (list): The second input list.\n        list3 (list): The third input list.\n    \n    Returns:\n        int: The number of items that are identical in the same position of the three lists.\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n\n    Args:\n        lst (list): The list to search for occurrences.\n        num: The number to count occurrences of.\n\n    Returns:\n        int: The number of occurrences of `num` in `lst`.\n    \"\"\"\n    return lst.count(num)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon.\n\n    Parameters:\n    side_length (float or int): The length of the sides of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    perimeter = 5 * side_length\n    return perimeter", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    freq_dict = {}\n    max_freq = 0\n    max_item = None\n    \n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n        \n        if freq_dict[item] > max_freq:\n            max_freq = freq_dict[item]\n            max_item = item\n    \n    return max_item", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 5, 6, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 6]]]}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return min(m // 2, 2)\n    else:\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = min(m // 2, 2)\n        for i in range(3, n + 1):\n            for j in range(1, i // 2 + 1):\n                dp[i] += dp[j] * dp[i - j]\n            dp[i] *= 2\n            if m >= 2 * i - 1:\n                dp[i] += dp[i - 1]\n        return dp[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 4]], "plus_fail_tests": [[100, 10]]}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance(string):\n    count = 0\n    index = 0\n    while index < len(string):\n        if string[index:index+3] == 'std':\n            count += 1\n            index += 3\n        else:\n            index += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type(t):\n    \"\"\"\n    Check if all elements in a tuple have the same data type.\n\n    Args:\n        t (tuple): The input tuple.\n\n    Returns:\n        bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    types = set(type(item) for item in t)\n    return len(types) <= 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n\n    # Initialize variables to store the maximum sum of increasing and decreasing subsequences\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    # Calculate the maximum sum of increasing subsequence\n    increasing[0] = arr[0]\n    for i in range(1, n):\n        increasing[i] = max(arr[i], increasing[i-1])\n\n    # Calculate the maximum sum of decreasing subsequence\n    decreasing[n-1] = arr[n-1]\n    for i in range(n-2, -1, -1):\n        decreasing[i] = max(arr[i], decreasing[i+1])\n\n    # Find the maximum sum of a bitonic subsequence\n    max_sum = float('-inf')\n    for i in range(n):\n        max_sum = max(max_sum, increasing[i] + decreasing[i] - arr[i])\n\n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 15, 51, 45, 33, 100, 12, 18, 9]]], "plus_fail_tests": [[[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]]]}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(z):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Parameters:\n    z (complex): The complex number to be converted.\n\n    Returns:\n    tuple: A tuple containing the magnitude and angle of the complex number in polar coordinates.\n\n    \"\"\"\n    magnitude = abs(z)\n    angle = cmath.phase(z)\n    return (magnitude, angle)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    count = 0\n    for i in range(n):\n        if arr[i] == element:\n            count += 1\n        if count > n/2:\n            return True\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(num):\n    \"\"\"\n    This function sets all even bits of a given number.\n\n    Parameters:\n    num (int): The input number.\n\n    Returns:\n    int: The number with all even bits set.\n\n    Example:\n    >>> even_bit_set_number(10)\n    10\n    >>> even_bit_set_number(15)\n    15\n    >>> even_bit_set_number(21)\n    23\n    \"\"\"\n\n    # Loop through each bit position\n    for i in range(31):\n        # Check if the bit at position i is even\n        if i % 2 == 0:\n            # Set the bit at position i\n            num |= 1 << i\n\n    return num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    count = 0\n    for element in lst:\n        if isinstance(element, int):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    \"\"\"\n    This function counts the total number of characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements(list1, list2):\n    \"\"\"\n    Remove all elements from list1 that are present in list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list of elements to be removed.\n\n    Returns:\n        list: The modified list with elements removed.\n\n    Examples:\n        >>> remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8])\n        [1, 3, 5, 7, 9, 10]\n    \"\"\"\n    return [x for x in list1 if x not in list2]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Function to find the nth hexagonal number.\n    \n    Parameters:\n    n (int): The position of the hexagonal number to be found.\n    \n    Returns:\n    int: The nth hexagonal number.\n    \"\"\"\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math\ndef lateralsuface_cylinder(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Args:\n        radius (float): The radius of the cylinder.\n        height (float): The height of the cylinder.\n\n    Returns:\n        float: The lateral surface area of the cylinder.\n\n    Raises:\n        ValueError: If either radius or height is negative.\n\n    Examples:\n        >>> lateralsuface_cylinder(10, 5)\n        314.15000000000003\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be positive\")\n\n    lateral_surface_area = 2 * math.pi * radius * height\n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string(string):\n    \"\"\"\n    Removes characters with odd index values from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with characters removed.\n\n    Examples:\n        >>> odd_values_string('abcdef')\n        'ace'\n        >>> odd_values_string('hello')\n        'e'\n        >>> odd_values_string('python')\n        'pt'\n    \"\"\"\n    return string[::2]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    \"\"\"\n    Count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    \n    Args:\n        string (str): The input string to count characters from.\n        \n    Returns:\n        int: The count of characters that occur at the same position in the string as in the English alphabet (case insensitive).\n    \"\"\"\n    count = 0\n    for i, char in enumerate(string.lower()):\n        if char.isalpha() and char == chr(ord('a') + i):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurences(lst):\n    \"\"\"\n    This function takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    result = {}\n    for tup in lst:\n        if tup in result:\n            result[tup] += 1\n        else:\n            result[tup] = 1\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 1], [1, 3], [2, 5], [5, 2], [6, 3]]]], "plus_fail_tests": [[[[2, 2], [1, 3], [2, 2], [3, 1], [1, 3]]]]}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    sorted_lst = sorted(lst, reverse=True)\n    return sorted_lst[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Find the minimum of three numbers.\n\n    Args:\n        a (int): First number.\n        b (int): Second number.\n        c (int): Third number.\n\n    Returns:\n        int: The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    if n <= 0:\n        return 1\n    else:\n        return 2 ** (n.bit_length() + 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[1]]}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Parameters:\n    side_length (float or int): The length of one side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> volume_cube(3)\n    27.0\n    >>> volume_cube(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    volume = side_length ** 3\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(tuple_data, element):\n    \"\"\"\n    This function takes in a tuple and an element and counts the occurrences of the element in the tuple.\n\n    Args:\n        tuple_data (tuple): The input tuple.\n        element: The element to count occurrences of.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tuple_data.count(element)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i+cl-1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\n    return dp[0][n-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check whether the two numbers differ at one bit position only.\n\n    Args:\n    num1 (int): The first number.\n    num2 (int): The second number.\n\n    Returns:\n    bool: True if the two numbers differ at one bit position only, False otherwise.\n    \"\"\"\n    # XOR the two numbers to find the bits that differ\n    xor_result = num1 ^ num2\n\n    # Count the number of set bits in the XOR result\n    count = 0\n    while xor_result:\n        count += xor_result & 1\n        xor_result >>= 1\n\n    # Return True if count is 1, indicating that the two numbers differ at one bit position only\n    return count == 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, 10]]}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall(number):\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    A Woodall number is a positive integer that is the product of two consecutive integers (i.e., a number and its successor).\n\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Woodall number, False otherwise.\n    \"\"\"\n    if number <= 2:\n        return False\n\n    for i in range(2, number):\n        if number == i * (i + 1):\n            return True\n\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[383]], "plus_fail_tests": [[123456789]]}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    def sum_divisors(num):\n        divisors_sum = 0\n        for i in range(1, num // 2 + 1):\n            if num % i == 0:\n                divisors_sum += i\n        return divisors_sum\n\n    amicable_sum = 0\n    for num in range(1, n + 1):\n        sum1 = sum_divisors(num)\n        sum2 = sum_divisors(sum1)\n        if sum2 == num and sum1 != sum2:\n            amicable_sum += num\n    return amicable_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9999]], "plus_fail_tests": [[10000]]}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age(age):\n    if age <= 0:\n        return \"Invalid age\"\n    elif age <= 1:\n        return 14\n    else:\n        return 22 + (age - 2) * 5", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12]], "plus_fail_tests": [[100]]}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_sum(n):\n    \"\"\"\n    Calculates the sum of the squares of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> square_sum(2)\n    10\n    >>> square_sum(3)\n    38\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_squares = 0\n    for i in range(1, 2*n+1, 2):\n        sum_of_squares += i**2\n\n    return sum_of_squares\n\n# Testing the function\nassert square_sum(2) == 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    \"\"\"\n    Calculates the sum of squares of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of squares of the first n even natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> square_Sum(2)\n    20\n    >>> square_Sum(3)\n    56\n    >>> square_Sum(5)\n    380\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_squares = 0\n    for i in range(1, n+1):\n        sum_of_squares += i*2\n\n    return sum_of_squares", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[100]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Function to find the nth decagonal number.\n    \n    Parameters:\n    n (int): The position of the decagonal number to be found.\n    \n    Returns:\n    int: The nth decagonal number.\n    \"\"\"\n    return n * (3 * n - 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n    \n    Args:\n        radius (float): The radius of the cylinder.\n        height (float): The height of the cylinder.\n    \n    Returns:\n        float: The volume of the cylinder.\n    \"\"\"\n    base_area = math.pi * radius**2\n    volume = base_area * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate(num):\n    num_str = str(num)\n    for digit in num_str:\n        digit_count = num_str.count(digit)\n        if digit_count > int(digit):\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculates the sum of even index binomial coefficients up to the given positive integer n.\n    \n    Parameters:\n    n (int): A positive integer.\n    \n    Returns:\n    int: The sum of even index binomial coefficients.\n    \n    Raises:\n    ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    sum_even_coeff = 0\n    for k in range(0, n+1, 2):\n        coeff = binomial_coefficient(n, k)\n        sum_even_coeff += coeff\n    \n    return sum_even_coeff\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculates the binomial coefficient C(n, k).\n    \n    Parameters:\n    n (int): A positive integer.\n    k (int): A non-negative integer.\n    \n    Returns:\n    int: The binomial coefficient C(n, k).\n    \n    Raises:\n    ValueError: If n or k is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n    if k > n:\n        return 0\n    \n    result = 1\n    for i in range(1, k+1):\n        result = result * (n - i + 1) // i\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(num):\n    \"\"\"\n    This function takes an integer 'num' as input and returns the value of 'num' with the left most unset bit set to 1.\n    \n    Parameters:\n    num (int): The integer number for which the left most unset bit needs to be set.\n    \n    Returns:\n    int: The value of 'num' with the left most unset bit set to 1.\n    \"\"\"\n    if num == 0:\n        return 1\n    \n    # Find the position of the left most unset bit\n    bit_position = 0\n    while num & (1 << bit_position):\n        bit_position += 1\n    \n    # Set the left most unset bit to 1\n    num |= (1 << bit_position)\n    \n    return num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[255]]}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    \"\"\"\n    Function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n    \n    Parameters:\n    n (int): The length of the binary sequence divided by 2.\n    \n    Returns:\n    float: The count of binary sequences satisfying the condition.\n    \"\"\"\n    # Base case: when n = 1\n    if n == 1:\n        return 2.0\n    \n    # Recursive case: count of binary sequences for n > 1\n    count = 0\n    for i in range(1 << (n-1)):\n        # Generate binary sequence of length n-1\n        binary_seq = bin(i)[2:].zfill(n-1)\n        \n        # Calculate the sum of first and last n-1 bits\n        first_sum = sum(int(bit) for bit in binary_seq)\n        last_sum = sum(int(bit) for bit in binary_seq[::-1])\n        \n        # Check if the sum of first and last n-1 bits is equal\n        if first_sum == last_sum:\n            count += 1\n    \n    # Multiply the count by 2 to consider both possible leading 0s and 1s\n    return count * 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[4]]}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n\n    Parameters:\n    side_length (int or float): The length of one side of the cube.\n\n    Returns:\n    int or float: The lateral surface area of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> lateralsurface_cube(5)\n    100\n    >>> lateralsurface_cube(0)\n    0\n    >>> lateralsurface_cube(-2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    return 4 * side_length * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element(lst, n):\n    \"\"\"\n    Extracts the nth element from a given list of tuples.\n\n    Args:\n        lst (list): A list of tuples.\n        n (int): The index of the element to extract.\n\n    Returns:\n        list: A list containing the nth element from each tuple in the input list.\n\n    Raises:\n        IndexError: If the index is out of range.\n\n    Examples:\n        >>> extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0)\n        ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n\n        >>> extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1)\n        [98, 97, 91, 94]\n    \"\"\"\n    result = []\n    for tup in lst:\n        try:\n            result.append(tup[n])\n        except IndexError:\n            raise IndexError(f\"Index {n} is out of range for tuple {tup}\")\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    \"\"\"\n    Calculates the sum of even numbers at even positions in a list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The sum of even numbers at even positions.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> sum_even_and_even_index([5, 6, 12, 1, 18, 8])\n        30\n        >>> sum_even_and_even_index([1, 2, 3, 4, 5, 6])\n        12\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length(lst):\n    max_len = 0\n    max_lst = []\n    for sub_lst in lst:\n        if len(sub_lst) > max_len:\n            max_len = len(sub_lst)\n            max_lst = sub_lst\n    return max_len, max_lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    return all(item == element for item in lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(string):\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character found, return None\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    count = 0\n    for element in tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    Returns the ASCII value of a character.\n\n    Parameters:\n    char (str): The character whose ASCII value is to be calculated.\n\n    Returns:\n    int: The ASCII value of the character.\n\n    Raises:\n    TypeError: If the input is not a single character.\n\n    Examples:\n    >>> ascii_value('A')\n    65\n    >>> ascii_value('1')\n    49\n    \"\"\"\n\n    if len(char) != 1:\n        raise TypeError(\"Input must be a single character.\")\n\n    return ord(char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_power_of_2(n):\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2\n\n# Test cases\nassert highest_power_of_2(10) == 8\nassert highest_power_of_2(16) == 16\nassert highest_power_of_2(31) == 32\nassert highest_power_of_2(63) == 64\nassert highest_power_of_2(64) == 64", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Perform mathematical division operation element-wise across the given tuples.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple with the result of division operation element-wise across the input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> division_elements((10, 4, 6, 9), (5, 2, 3, 3))\n        (2, 2, 2, 3)\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = tuple(a / b for a, b in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    return (b, a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the maximum of the two.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The maximum of the two input numbers.\n    \"\"\"\n    return max(a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(num):\n    \"\"\"\n    Function to find whether the parity of a given number is odd.\n    \n    Parameters:\n    num (int): The number for which parity needs to be determined.\n    \n    Returns:\n    bool: True if the parity is odd, False otherwise.\n    \"\"\"\n    return num % 2 != 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    result = []\n    for num in numbers:\n        digit_sum = 0\n        for digit in str(num):\n            digit_sum += int(digit)\n        result.append(digit_sum)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 2, 56]]], "plus_fail_tests": [[[]]]}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values1, values2):\n    result = []\n    for i in range(len(keys)):\n        inner_dict = {values1[i]: values2[i]}\n        outer_dict = {keys[i]: inner_dict}\n        result.append(outer_dict)\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [[1, 2, 3], [4, 5, 6], {"a": "x", "b": "y", "c": "z"}]]]}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n\n    return sum(primes[:n])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(lst):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    Args:\n    lst (list): A list of tuples containing names and scores.\n\n    Returns:\n    tuple: A tuple containing the name and the maximum aggregate.\n\n    \"\"\"\n    aggregates = {}\n    for name, score in lst:\n        if name in aggregates:\n            aggregates[name] += score\n        else:\n            aggregates[name] = score\n\n    max_name = max(aggregates, key=aggregates.get)\n    max_aggregate = aggregates[max_name]\n\n    return (max_name, max_aggregate)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    Removes odd numbers from a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A new list with only the even numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "import re\ndef text_match_two_three(text):\n    \"\"\"\n    Checks whether a string contains the 'a' character followed by two or three 'b' characters.\n    \n    Args:\n        text (str): The input string to be checked.\n    \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"ab{2,3}\"\n    return bool(re.search(pattern, text))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        lucas_sequence = [2, 1]\n        for i in range(2, n + 1):\n            lucas_sequence.append(lucas_sequence[i - 1] + lucas_sequence[i - 2])\n        return lucas_sequence[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple(lst):\n    \"\"\"\n    Find the minimum product from the pairs of tuples within a given list.\n    \n    Args:\n    lst (list): A list of tuples, where each tuple contains two integers.\n    \n    Returns:\n    int: The minimum product of the pairs of tuples.\n    \"\"\"\n    min_product = float('inf')  # Initialize with positive infinity\n    \n    for tup in lst:\n        product = tup[0] * tup[1]\n        if product < min_product:\n            min_product = product\n    \n    return min_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a list to store the maximum sum of increasing subsequence\n    max_sum = [0] * n\n\n    # Initialize the maximum sum for the i-th index\n    max_sum[i] = arr[i]\n\n    # Iterate through the array from the (i+1)-th index to the end\n    for j in range(i+1, n):\n        # Check if the current element is greater than the last element of the subsequence\n        if arr[j] > max_sum[i]:\n            # Update the maximum sum for the j-th index\n            max_sum[j] = max(max_sum[j], max_sum[i] + arr[j])\n\n    # Find the maximum sum from the prefix until the i-th index\n    prefix_sum = max(max_sum[:i])\n\n    # Find the maximum sum from the suffix starting from the (k+1)-th index\n    suffix_sum = max(max_sum[k+1:])\n\n    # Return the maximum sum of increasing subsequence\n    return prefix_sum + suffix_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    \"\"\"\n    Extracts the rear element from each tuple in the list and returns a new list.\n\n    Args:\n        tuples_list (list): A list of tuples.\n\n    Returns:\n        list: A list containing the rear element of each tuple.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If any tuple in the list does not have at least two elements.\n\n    Examples:\n        >>> rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)])\n        [21, 20, 19]\n    \"\"\"\n    if not isinstance(tuples_list, list):\n        raise TypeError(\"Input must be a list.\")\n\n    result = []\n    for t in tuples_list:\n        if len(t) < 2:\n            raise ValueError(\"Each tuple must have at least two elements.\")\n        result.append(t[-1])\n\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[["h"], [[["a", "b"], ["c", "d"]], ["e", "f"]], [[["i", "j"], ["k", ["l", "m"]]], ["n", 2]], [[["a", "b"], ["c", "d"]], ["e", "f"]]]]]}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the minimum of the two.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The minimum of the two input numbers.\n    \"\"\"\n    return min(a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    flattened_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    return flattened_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(side1, side2):\n    \"\"\"\n    Calculate the length of the third side of a right-angled triangle.\n\n    Parameters:\n    side1 (float): Length of the first side of the triangle.\n    side2 (float): Length of the second side of the triangle.\n\n    Returns:\n    float: Length of the third side of the triangle.\n\n    Raises:\n    ValueError: If either side1 or side2 is negative.\n\n    \"\"\"\n    if side1 < 0 or side2 < 0:\n        raise ValueError(\"Sides of a triangle cannot be negative.\")\n\n    # Using the Pythagorean theorem to calculate the length of the third side\n    side3 = math.sqrt(side1**2 + side2**2)\n\n    return side3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    result = []\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i+n])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"], 3]], "plus_fail_tests": [[[], 1]]}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The count of inversions in the array.\n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        element: The element to check for.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val(lst):\n    max_val = float('-inf')\n    for item in lst:\n        if isinstance(item, (int, float)) and item > max_val:\n            max_val = item\n    return max_val", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["3.14", false, 7.5]]]}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple(string):\n    \"\"\"\n    Converts a given string to a tuple of characters.\n    \n    Parameters:\n    string (str): The input string to be converted.\n    \n    Returns:\n    tuple: A tuple containing each character of the input string.\n    \n    Example:\n    >>> string_to_tuple(\"python 3.0\")\n    ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"\n    return tuple(string)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    \"\"\"\n    Subtract two lists element-wise.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list with the element-wise subtraction of list2 from list1.\n\n    Raises:\n        ValueError: If the input lists have different lengths.\n\n    Examples:\n        >>> sub_list([1, 2, 3], [4, 5, 6])\n        [-3, -3, -3]\n        >>> sub_list([10, 20, 30], [5, 10, 15])\n        [5, 10, 15]\n        >>> sub_list([1, 2, 3], [1, 2])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input lists must have the same length.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [x - y for x, y in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1, tuple2):\n    \"\"\"\n    Subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the subtracted elements.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> subtract_elements((10, 4, 5), (2, 5, 18))\n        (8, -1, -13)\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    subtracted_tuple = tuple(a - b for a, b in zip(tuple1, tuple2))\n    return subtracted_tuple\n\n# Testing the function\nassert subtract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, num):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n    \n    Args:\n    list1 (list): The first list of numbers.\n    list2 (list): The second list of numbers.\n    num (int): The number of largest products to find.\n    \n    Returns:\n    list: A list of the specified number of largest products.\n    \n    Raises:\n    ValueError: If either list1 or list2 is empty or if num is less than or equal to 0.\n    \"\"\"\n    \n    if not list1 or not list2:\n        raise ValueError(\"Both lists must be non-empty.\")\n    if num <= 0:\n        raise ValueError(\"The number of products to find must be greater than 0.\")\n    \n    products = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n    \n    products.sort(reverse=True)\n    return products[:num]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], [], 0]]}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for index, value in enumerate(arr):\n        if value == element:\n            return True, index\n    return False, -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    filtered_dict = {key: value for key, value in dictionary.items() if value >= n}\n    return filtered_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if the elements of a given list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    \"\"\"\n    Function to maximize the given two tuples.\n\n    Args:\n    tuple1 (tuple): First input tuple.\n    tuple2 (tuple): Second input tuple.\n\n    Returns:\n    tuple: Maximized tuple.\n\n    Raises:\n    ValueError: If the input tuples are not of equal length.\n\n    Examples:\n    >>> maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3)))\n    ((6, 7), (4, 9), (2, 9), (7, 10))\n    \"\"\"\n\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must be of equal length.\")\n\n    result = []\n    for i in range(len(tuple1)):\n        max_element = max(tuple1[i][0], tuple2[i][0]), max(tuple1[i][1], tuple2[i][1])\n        result.append(max_element)\n\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, k, target):\n    \"\"\"\n    Finds the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The number of times the array should be repeated.\n    target (int): The target value to compare the sum against.\n\n    Returns:\n    int: The largest sum of a contiguous array in the modified array.\n\n    \"\"\"\n\n    # Calculate the sum of the original array\n    original_sum = sum(arr)\n\n    # Calculate the maximum sum of a contiguous subarray in the original array\n    max_sum = max_sub_array_sum(arr)\n\n    # Calculate the maximum sum of a contiguous subarray in the modified array\n    modified_sum = max_sum * (k // target)\n\n    # If there is a remaining array that needs to be considered\n    if k % target != 0:\n        # Calculate the sum of the remaining array\n        remaining_sum = max_sub_array_sum(arr[:k % target])\n\n        # Update the modified sum with the remaining sum\n        modified_sum += remaining_sum\n\n    return modified_sum\ndef max_sub_array_sum(arr):\n    \"\"\"\n    Finds the maximum sum of a contiguous subarray in the given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum sum of a contiguous subarray.\n\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 20, -30, -1], 4, 3]], "plus_fail_tests": [[[5, -2, 10, 4, -7, 3], 6, 5]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    result = []\n    for word in words:\n        if word.startswith('p'):\n            result.extend(word.split())\n    return tuple(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python PHP", "Java JavaScript", "c c++"]]], "plus_fail_tests": [[["Python Programming", "Java Programming", "Perl Programming", "Ruby Programming", "PHP Programming", "C Programming"]]]}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    return (lst[:L], lst[L:])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct(t):\n    \"\"\"\n    Check if given tuple contains no duplicates.\n\n    Parameters:\n    t (tuple): The input tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    return len(t) == len(set(t))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given its radius and height.\n    \n    Args:\n        radius (float): The radius of the cone.\n        height (float): The height of the cone.\n    \n    Returns:\n        float: The volume of the cone.\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be positive numbers.\")\n    \n    volume = (1/3) * math.pi * radius**2 * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    \"\"\"\n    Find the minimum value in a given heterogeneous list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        The minimum value in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> min_val(['Python', 3, 2, 4, 5, 'version'])\n        2\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n\n    min_val = lst[0]\n    for item in lst:\n        if isinstance(item, (int, float)) and item < min_val:\n            min_val = item\n\n    return min_val", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef newman_prime(n):\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num):\n            count += 1\n        num += 1\n    return num - 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find(dividend, divisor):\n    \"\"\"\n    This function takes two numbers as input and returns the quotient of the first number divided by the second number, rounded down to the nearest integer.\n\n    Parameters:\n    - dividend (int or float): The number to be divided.\n    - divisor (int or float): The number to divide by.\n\n    Returns:\n    - int: The quotient of the division, rounded down to the nearest integer.\n\n    Example:\n    >>> find(10, 3)\n    3\n    \"\"\"\n    quotient = dividend // divisor\n    return quotient", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n\n    Args:\n        lst (list): The list of elements to apply the format string to.\n        format_str (str): The format string to apply.\n\n    Returns:\n        list: A new list with the format string applied to each element.\n\n    Examples:\n        >>> add_string([1, 2, 3, 4], 'temp{0}')\n        ['temp1', 'temp2', 'temp3', 'temp4']\n    \"\"\"\n    return [format_str.format(item) for item in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n\n    Args:\n        seq1 (list): The first sequence.\n        seq2 (list): The second sequence.\n\n    Returns:\n        bool: True if there is any overlapping value, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    Find the median of three numbers.\n\n    Parameters:\n    a (float): First number.\n    b (float): Second number.\n    c (float): Third number.\n\n    Returns:\n    float: The median of the three numbers.\n\n    Raises:\n    ValueError: If any of the input values are not numeric.\n\n    \"\"\"\n    numbers = [a, b, c]\n    numbers.sort()\n    median = numbers[1]\n    return float(median)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    \"\"\"\n    Recursively finds the depth of a dictionary.\n\n    Args:\n        dictionary (dict): The dictionary to find the depth of.\n\n    Returns:\n        int: The depth of the dictionary.\n\n    Raises:\n        TypeError: If the input is not a dictionary.\n\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        raise TypeError(\"Input must be a dictionary.\")\n\n    max_depth = 1\n    for value in dictionary.values():\n        if isinstance(value, dict):\n            depth = 1 + dict_depth(value)\n            max_depth = max(max_depth, depth)\n\n    return max_depth", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Finds the n'th star number.\n\n    A star number is a triangular number that is also a hexagonal number.\n    A triangular number is the sum of all positive integers up to a given number.\n    A hexagonal number is a number that appears in a hexagonal grid.\n\n    Args:\n        n (int): The position of the star number to find.\n\n    Returns:\n        int: The n'th star number.\n\n    Raises:\n        ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n\n    # Generate hexagonal numbers until we find the n'th star number\n    hex_num = 1\n    count = 1\n    while count < n:\n        hex_num += 4 * count + 1\n        count += 1\n\n    return hex_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    max_length = 0\n    max_element = []\n    \n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n    \n    return max_element", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    max_product = float('-inf')\n    result = ()\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                result = (arr[i], arr[j])\n    \n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1000000, 2000000, 3000000, 4000000, 4000000]]]}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    \"\"\"\n    Calculate the cube sum of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The cube sum of the first n even natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> cube_Sum(2)\n    72\n    >>> cube_Sum(3)\n    308\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum = 0\n    for i in range(2, 2*n+1, 2):\n        sum += i**3\n\n    return sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[false]]}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    return total_sum * len(rounded_numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples(t1, t2):\n    \"\"\"\n    Function to extract the elementwise and tuples from the given two tuples.\n\n    Args:\n    t1 (tuple): First input tuple.\n    t2 (tuple): Second input tuple.\n\n    Returns:\n    tuple: A tuple containing the elementwise and of the input tuples.\n\n    Raises:\n    ValueError: If the input tuples have different lengths.\n\n    Examples:\n    >>> and_tuples((10, 4, 6, 9), (5, 2, 3, 3))\n    (0, 0, 2, 1)\n    >>> and_tuples((1, 1, 1), (0, 1, 1))\n    (0, 1, 1)\n    >>> and_tuples((1, 0, 1), (1, 1, 0))\n    (1, 0, 0)\n    \"\"\"\n\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = tuple(a & b for a, b in zip(t1, t2))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    \"\"\"\n    Removes odd characters from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with odd characters removed.\n    \"\"\"\n    return ''.join(char for index, char in enumerate(string) if index % 2 == 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python"]], "plus_fail_tests": [["Hello, world!"]]}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    float: The average of cubes of the first n natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> find_Average_Of_Cube(2)\n    4.5\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    average = sum_of_cubes / n\n    return average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the given delimiter.\n\n    Args:\n        t (tuple): The input tuple.\n        delimiter (str, optional): The delimiter to be used for concatenation. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n\n    Examples:\n        >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n        'ID-is-4-UTS'\n        >>> concatenate_tuple((\"Hello\", \"World\"), delimiter='_')\n        'Hello_World'\n    \"\"\"\n    return delimiter.join(str(x) for x in t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the rear index element of each string in the tuple.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n\n    Examples:\n        >>> extract_rear(('Mers', 'for', 'Vers') )\n        ['s', 'r', 's']\n    \"\"\"\n    if not isinstance(tuple_of_strings, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    return [string[-1] for string in tuple_of_strings]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    \"\"\"\n    Removes uppercase substrings from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with uppercase substrings removed.\n    \"\"\"\n    result = \"\"\n    current_substring = \"\"\n\n    for char in string:\n        if char.isupper():\n            current_substring += char\n        else:\n            if current_substring.islower():\n                result += current_substring\n            current_substring = \"\"\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["cAstyoUrFavoRitETVshoWs"]], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    \"\"\"\n    Returns a list of negative numbers from the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    list: A list of negative numbers from the given list.\n    \"\"\"\n    return [num for num in lst if num < 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list): The input array of numbers.\n    num (int or float): The number to be checked.\n\n    Returns:\n    bool: True if the number is greater than all elements of the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single(nums):\n    \"\"\"\n    Function to join a list of multiple integers into a single integer.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: A single integer formed by joining the elements of the input list.\n    \"\"\"\n    return int(''.join(map(str, nums)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def change_date_format(date):\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    \n    Args:\n        date (str): The date in yyyy-mm-dd format.\n        \n    Returns:\n        str: The date in dd-mm-yyyy format.\n    \"\"\"\n    # Split the date into year, month, and day\n    year, month, day = date.split('-')\n    \n    # Rearrange the date in dd-mm-yyyy format\n    new_date = f\"{day}-{month}-{year}\"\n    \n    return new_date", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    \"\"\"\n    Function to find cubes of individual elements in a list.\n    \n    Parameters:\n    nums (list): A list of numbers.\n    \n    Returns:\n    list: A list of cubes of the individual elements in the input list.\n    \"\"\"\n    return [num**3 for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(size):\n    \"\"\"\n    Calculate the surface area of a cube of a given size.\n\n    Parameters:\n    size (int): The size of the cube.\n\n    Returns:\n    int: The surface area of the cube.\n\n    Raises:\n    ValueError: If the size is not a positive integer.\n\n    Examples:\n    >>> surfacearea_cube(5)\n    150\n    >>> surfacearea_cube(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Size must be a positive integer.\n    \"\"\"\n\n    if not isinstance(size, int) or size <= 0:\n        raise ValueError(\"Size must be a positive integer.\")\n\n    return 6 * size * size", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-3]]}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    \"\"\"\n    Filters odd numbers from a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A new list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        element1 = tuple1[i]\n        element2 = tuple2[i]\n        multiplied_elements = (element1[0] * element2[0], element1[1] * element2[1])\n        result.append(multiplied_elements)\n    return tuple(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10]]]]}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Find the directrix of a parabola.\n\n    Parameters:\n    a (float): Coefficient of x^2 term.\n    b (float): Coefficient of x term.\n    c (float): Constant term.\n\n    Returns:\n    float: The directrix of the parabola.\n\n    Raises:\n    ValueError: If the parabola has no directrix (when a = 0).\n\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Parabola has no directrix when a = 0\")\n\n    directrix = -b**2 / (4*a)\n    return directrix", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    \"\"\"\n    Calculate the median length of a trapezium.\n\n    Parameters:\n    a (float): Length of the first base of the trapezium.\n    b (float): Length of the second base of the trapezium.\n    c (float): Length of the height of the trapezium.\n\n    Returns:\n    float: The median length of the trapezium.\n\n    Raises:\n    ValueError: If any of the input values are negative or zero.\n\n    \"\"\"\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All input values must be positive and non-zero.\")\n\n    median = (a + b) * c / (2 * (a + (b - a) / 2))\n    return median", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 25, 35]], "plus_fail_tests": [[2.3, 4.7, 3.9]]}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tuple_data, list_elements):\n    count = 0\n    for element in list_elements:\n        count += tuple_data.count(element)\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_digit(number):\n    \"\"\"\n    This function takes a number as input and returns the last digit of that number.\n    \n    Parameters:\n    number (int): The number for which the last digit needs to be found.\n    \n    Returns:\n    int: The last digit of the given number.\n    \"\"\"\n    return number % 10\n\n# Test the function\nassert last_digit(123) == 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    arr.sort()\n    return arr[-1] + arr[0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_string = string[::-1]\n        reversed_list.append(reversed_string)\n    return reversed_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    \"\"\"\n    Function to match a word containing 'z'.\n    \n    Parameters:\n    text (str): The input text to be checked.\n    \n    Returns:\n    bool: True if the word containing 'z' is found, False otherwise.\n    \"\"\"\n    pattern = r'\\b\\w*z\\w*\\b'\n    match = re.search(pattern, text)\n    if match:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the given index.\n\n    Parameters:\n    n (int): The index up to which the sum of Perrin numbers should be calculated.\n\n    Returns:\n    int: The sum of Perrin numbers up to the given index.\n\n    Raises:\n    ValueError: If the input is not a positive integer.\n\n    Examples:\n    >>> cal_sum(9)\n    49\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    perrin_numbers = [3, 0, 2]  # Initial Perrin numbers\n\n    if n <= 2:\n        return perrin_numbers[n]\n\n    for i in range(3, n + 1):\n        perrin_numbers.append(perrin_numbers[i - 1] + perrin_numbers[i - 2])\n\n    return sum(perrin_numbers)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(lst, size):\n    return [string for string in lst if len(string) == size]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise(t):\n    \"\"\"\n    Function to find the pairwise addition of the neighboring elements of the given tuple.\n    \n    Parameters:\n    t (tuple): The input tuple\n    \n    Returns:\n    tuple: The tuple containing the pairwise addition of the neighboring elements\n    \n    Example:\n    >>> add_pairwise((1, 5, 7, 8, 10))\n    (6, 12, 15, 18)\n    \"\"\"\n    result = []\n    for i in range(len(t) - 1):\n        result.append(t[i] + t[i+1])\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection(tuple_list1, tuple_list2):\n    \"\"\"\n    Find the tuple intersection of elements in the given tuple list irrespective of their order.\n\n    Args:\n    tuple_list1 (list): The first tuple list.\n    tuple_list2 (list): The second tuple list.\n\n    Returns:\n    set: A set of tuples representing the intersection of the elements in the two lists.\n\n    \"\"\"\n    # Convert the tuples in each list to sets and find the intersection\n    set1 = set(map(tuple, tuple_list1))\n    set2 = set(map(tuple, tuple_list2))\n    intersection_set = set1.intersection(set2)\n\n    # Convert the intersection set back to a list of tuples\n    intersection_list = [tuple(sorted(t)) for t in intersection_set]\n\n    # Return the intersection as a set of tuples\n    return set(intersection_list)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 4], [5, 6], [9, 10], [4, 5]], [[5, 4], [3, 4], [6, 5], [9, 11]]]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], [[2, 3, 1], [6, 5, 4], [11, 12, 10]]]]}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    result = [[]]\n    for i in range(len(lst)):\n        for j in range(len(result)):\n            result.append(result[j] + [lst[i]])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_digit(number):\n    \"\"\"\n    This function takes a number as input and returns the first digit of that number.\n    \n    Parameters:\n    number (int): The number from which the first digit needs to be extracted.\n    \n    Returns:\n    int: The first digit of the given number.\n    \"\"\"\n    # Convert the number to a string and extract the first character\n    first_digit = str(number)[0]\n    \n    # Convert the first digit back to an integer and return it\n    return int(first_digit)\n\n# Test the function\nassert first_digit(123) == 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    length (float or int): The length of the rectangle.\n    width (float or int): The width of the rectangle.\n\n    Returns:\n    float or int: The area of the rectangle.\n\n    Raises:\n    ValueError: If either length or width is negative.\n\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"Length and width must be positive numbers.\")\n    return length * width", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):\n    adverbs = ['clearly', 'easily', 'quickly', 'happily', 'sadly', 'always', 'never']\n    words = sentence.split()\n    for i, word in enumerate(words):\n        if word in adverbs:\n            return i, i + len(word) - 1, word\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["clearly!! we can see the sky"]], "plus_fail_tests": [["heavily and quickly we ran down the steep hill"]]}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_month_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 31 days or not.\n\n    Parameters:\n    month_number (int): The month number to be checked.\n\n    Returns:\n    bool: True if the month contains 31 days, False otherwise.\n    \"\"\"\n    # Define a list of month numbers that have 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n\n    # Check if the given month number is in the list\n    if month_number in months_with_31_days:\n        return True\n    else:\n        return False\n\n# Test the function\nassert check_month_number(5) == True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    toggled_string = \"\"\n    for char in string:\n        if char.islower():\n            toggled_string += char.upper()\n        elif char.isupper():\n            toggled_string += char.lower()\n    return toggled_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    \"\"\"\n    Removes lowercase substrings from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The input string with lowercase substrings removed.\n    \"\"\"\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    \"\"\"\n    Check whether the given list contains consecutive numbers or not.\n    \n    Parameters:\n    lst (list): The input list of integers.\n    \n    Returns:\n    bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # Iterate through the sorted list and check for consecutive numbers\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i+1] - sorted_lst[i] != 1:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    Calculates the product of the array elements modulo n.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The modulo value.\n\n    Returns:\n    int: The product of the array elements modulo n.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([], 11)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list cannot be empty.\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n\n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split(nums):\n    return [num for num in nums if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    sorted_items = sorted(dictionary.items(), key=lambda x: x[1], reverse=True)\n    return sorted_items", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    if len(arr) == 0:\n        return 0\n\n    max_product = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n\n        max_product = max(max_product, max_ending_here)\n\n    return max_product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[-3, -100, -4, -5, -150, -6]]]}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def convert_to_lower(string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    string (str): The string to be converted.\n\n    Returns:\n    str: The converted string in lower case.\n    \"\"\"\n    return string.lower()\n\n# Test the function\nassert convert_to_lower(\"InValid\") == \"invalid\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] ^ arr[j]) % 2 != 0:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers = sum([i for i in range(1, n+1)])\n    return sum_of_cubes - sum_of_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(sublists):\n    max_length = 0\n    for sublist in sublists:\n        length = len(sublist)\n        if length > max_length:\n            max_length = length\n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with a new character.\n\n    Args:\n        string (str): The input string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace the old character with.\n\n    Returns:\n        str: The modified string with replaced characters.\n\n    Examples:\n        >>> replace_char(\"polygon\", \"y\", \"l\")\n        'pollgon'\n        >>> replace_char(\"hello world\", \"o\", \"a\")\n        'hella warld'\n    \"\"\"\n    return string.replace(old_char, new_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min(sublists):\n    \"\"\"\n    Finds the sublist with the minimum length.\n\n    Args:\n    sublists (list): A list of sublists.\n\n    Returns:\n    list: The sublist with the minimum length.\n\n    Raises:\n    ValueError: If the input is an empty list.\n\n    Examples:\n    >>> Find_Min([[1],[1,2],[1,2,3]])\n    [1]\n    >>> Find_Min([[1,2,3],[4,5],[6]])\n    [6]\n    >>> Find_Min([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list cannot be empty.\n    \"\"\"\n\n    if not sublists:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    min_length = float('inf')\n    min_sublist = []\n\n    for sublist in sublists:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    \"\"\"\n    Function to drop empty items from a given dictionary.\n\n    Args:\n    - dictionary: A dictionary containing key-value pairs.\n\n    Returns:\n    - A new dictionary with empty values removed.\n\n    Example:\n    >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})\n    {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculates the sum of the per-digit difference between two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The sum of the per-digit difference between num1 and num2.\n\n    Raises:\n        TypeError: If either num1 or num2 is not an integer.\n\n    Examples:\n        >>> digit_distance_nums(1, 2)\n        1\n        >>> digit_distance_nums(123, 321)\n        3\n        >>> digit_distance_nums(123, 456)\n        6\n    \"\"\"\n    # Check if inputs are integers\n    if not isinstance(num1, int) or not isinstance(num2, int):\n        raise TypeError(\"Both inputs must be integers.\")\n\n    # Convert numbers to strings for easier manipulation\n    num1_str = str(num1)\n    num2_str = str(num2)\n\n    # Ensure both numbers have the same number of digits\n    if len(num1_str) != len(num2_str):\n        raise ValueError(\"Both numbers must have the same number of digits.\")\n\n    # Calculate the sum of the per-digit differences\n    sum_diff = 0\n    for i in range(len(num1_str)):\n        sum_diff += abs(int(num1_str[i]) - int(num2_str[i]))\n\n    return sum_diff", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12345, 9]]}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    \"\"\"\n    Find the union of the elements of two given tuples and output them in sorted order.\n    \n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n    \n    Returns:\n        tuple: A new tuple containing the union of elements from both input tuples, sorted in ascending order.\n    \"\"\"\n    # Combine the two input tuples\n    combined_tuple = tuple1 + tuple2\n    \n    # Use set to remove duplicates and convert it back to a tuple\n    unique_elements = tuple(set(combined_tuple))\n    \n    # Sort the unique elements in ascending order\n    sorted_tuple = tuple(sorted(unique_elements))\n    \n    return sorted_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split(string):\n    \"\"\"\n    Split a string into characters.\n\n    Parameters:\n    string (str): The input string to be split.\n\n    Returns:\n    list: A list of characters from the input string.\n\n    Example:\n    >>> split('python')\n    ['p', 'y', 't', 'h', 'o', 'n']\n    \"\"\"\n    return list(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n        string (str): The input string.\n        \n    Returns:\n        list: A list of values extracted between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_Pairs(arr, target):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] != arr[j] and arr[i] + arr[j] == target:\n                count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], 5]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10]]}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): The non-negative integer for which the sum of digits needs to be calculated.\n\n    Returns:\n    int: The sum of the digits of the input integer.\n\n    Raises:\n    ValueError: If the input is a negative integer.\n\n    Examples:\n    >>> sum_digits(345)\n    12\n    >>> sum_digits(0)\n    0\n    >>> sum_digits(987654321)\n    45\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        lst (list): A list of lists containing strings.\n\n    Returns:\n        list: A new list with each sublist sorted in alphabetical order.\n\n    Examples:\n        >>> sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])\n        [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    return [{} for _ in range(n)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    if n < 0:\n        return None\n    elif n == 0 or n == 1:\n        return 1\n    \n    result = 1\n    for i in range(2, n+1):\n        result *= i\n    \n    return result % 10\n\n# Test cases\nassert last_digit_factorial(4) == 4\nassert last_digit_factorial(5) == 2\nassert last_digit_factorial(10) == 0\nassert last_digit_factorial(0) == 1\nassert last_digit_factorial(1) == 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(arr, sub_arr):\n    \"\"\"\n    Check whether a list is a sublist of another list.\n\n    Parameters:\n    arr (list): The main list.\n    sub_arr (list): The sublist to be checked.\n\n    Returns:\n    bool: True if sub_arr is a sublist of arr, False otherwise.\n    \"\"\"\n    if len(sub_arr) > len(arr):\n        return False\n\n    for i in range(len(arr) - len(sub_arr) + 1):\n        if arr[i:i+len(sub_arr)] == sub_arr:\n            return True\n\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [1, 3, 5]]]}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def is_sorted_list(lst):\n    \"\"\"\n    Check whether a specified list is sorted or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\n# Test the function\nassert is_sorted_list([1,2,4,6,8,10,12,14,16,17]) == True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    unique_numbers = set(numbers)\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A tuple containing the dissimilar elements between the two input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10))\n        (3, 6, 7, 10)\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    dissimilar_elements = []\n    for i in range(len(tuple1)):\n        if tuple1[i] != tuple2[i]:\n            dissimilar_elements.append(tuple1[i])\n            dissimilar_elements.append(tuple2[i])\n\n    return tuple(dissimilar_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4, 5, 6], [5, 7, 4, 10]]], "plus_fail_tests": [[[3, 4, 5, 6, 7, 8, 9], [5, 7, 4, 10, 12, 14, 16]]]}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n\n    Args:\n        arr1 (list): The first sorted array.\n        arr2 (list): The second sorted array.\n        k (int): The position of the element to find.\n\n    Returns:\n        int: The kth element.\n\n    Raises:\n        ValueError: If k is out of range.\n\n    \"\"\"\n    len1, len2 = len(arr1), len(arr2)\n    if k > len1 + len2 or k < 1:\n        raise ValueError(\"k is out of range\")\n\n    i, j = 0, 0\n    while True:\n        if i == len1:\n            return arr2[j + k - 1]\n        if j == len2:\n            return arr1[i + k - 1]\n        if k == 1:\n            return min(arr1[i], arr2[j])\n\n        mid = (k // 2) - 1\n        idx1 = min(i + mid, len1 - 1)\n        idx2 = min(j + mid, len2 - 1)\n\n        if arr1[idx1] <= arr2[idx2]:\n            k -= idx1 - i + 1\n            i = idx1 + 1\n        else:\n            k -= idx2 - j + 1\n            j = idx2 + 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 1], [], 3]]}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    \"\"\"\n    Function to remove uneven elements in the nested mixed tuple.\n    \n    Args:\n    - nested_tuple: A mixed nested tuple containing integers.\n    \n    Returns:\n    - A new tuple with only the even elements from the nested tuple.\n    \"\"\"\n    result = ()\n    for item in nested_tuple:\n        if isinstance(item, int) and item % 2 == 0:\n            result += (item,)\n        elif isinstance(item, tuple):\n            result += (extract_even(item),)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(t):\n    return sys.getsizeof(t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\n    # Convert the number to string to count the number of digits\n    num_str = str(num)\n    num_digits = len(num_str)\n    \n    # Calculate the sum of the cubes of each digit\n    sum_of_cubes = sum(int(digit)**num_digits for digit in num_str)\n    \n    # Check if the sum of cubes is equal to the original number\n    if sum_of_cubes == num:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    even_num = None\n    odd_num = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            even_num = num\n            break\n    \n    for num in lst:\n        if num % 2 != 0:\n            odd_num = num\n            break\n    \n    if even_num is not None and odd_num is not None:\n        return even_num - odd_num\n    else:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The difference between the largest and smallest values in the list.\n\n    Raises:\n        ValueError: If the input list is empty or contains non-integer values.\n\n    Examples:\n        >>> big_diff([1, 2, 3, 4])\n        3\n        >>> big_diff([7, 2, 9, 1, 5])\n        8\n        >>> big_diff([3, 3, 3, 3])\n        0\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    min_num = float('inf')\n    max_num = float('-inf')\n\n    for num in nums:\n        if not isinstance(num, int):\n            raise ValueError(\"Input list must contain only integers.\")\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n\n    return max_num - min_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    \"\"\"\n    Finds perfect squares between two given numbers.\n\n    Args:\n        start (int): The starting number.\n        end (int): The ending number.\n\n    Returns:\n        list: A list of perfect squares between the given numbers.\n\n    Raises:\n        ValueError: If start is greater than end.\n\n    Examples:\n        >>> perfect_squares(1, 30)\n        [1, 4, 9, 16, 25]\n    \"\"\"\n    if start > end:\n        raise ValueError(\"Start must be less than or equal to end.\")\n\n    squares = []\n    for num in range(start, end + 1):\n        if int(num ** 0.5) ** 2 == num:\n            squares.append(num)\n\n    return squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char(string):\n    \"\"\"\n    Find the first repeated character in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The first repeated character, or None if no repeated character is found.\n    \"\"\"\n    seen = set()\n    for char in string:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import cmath\ndef polar_rect(r, theta):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n    \n    Parameters:\n    r (float): The radial distance from the origin.\n    theta (float): The angle in radians.\n    \n    Returns:\n    tuple: A tuple containing the rectangular coordinates (x, y).\n    \"\"\"\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    return (x, y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items(dataset, n):\n    sorted_items = sorted(dataset, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    # Split the list at the nth element\n    split_list = arr[:n]\n    remaining_list = arr[n:]\n    \n    # Add the first part to the end\n    result = remaining_list + split_list\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        tuple: The converted tuple.\n\n    Examples:\n        >>> list_tuple([5, 10, 7, 4, 15, 3])\n        (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    Parameters:\n    base_edge (float): The length of the base edge of the square pyramid.\n    height (float): The height of the square pyramid.\n\n    Returns:\n    float: The surface area of the square pyramid.\n\n    Raises:\n    ValueError: If either base_edge or height is negative.\n\n    \"\"\"\n    if base_edge < 0 or height < 0:\n        raise ValueError(\"Base edge and height must be positive values.\")\n\n    base_area = base_edge ** 2\n    lateral_area = (base_edge * height) / 2\n    total_area = base_area + lateral_area\n\n    return total_area\n\n# Test the function\nassert surface_area(3, 4) == 33", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(num):\n    \"\"\"\n    Check whether the given number is even or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is even, False otherwise.\n    \"\"\"\n    return num % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    \"\"\"\n    Removes leading zeroes from an IP address.\n\n    Args:\n        ip_address (str): The IP address to remove leading zeroes from.\n\n    Returns:\n        str: The IP address with leading zeroes removed.\n\n    Examples:\n        >>> removezero_ip(\"216.08.094.196\")\n        '216.8.94.196'\n        >>> removezero_ip(\"000.000.000.001\")\n        '1.0.0.0'\n        >>> removezero_ip(\"0.0.0.0\")\n        '0.0.0.0'\n    \"\"\"\n    octets = ip_address.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    return '.'.join(cleaned_octets)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The number of terms in the product.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    Examples:\n    >>> sum_Of_product(3)\n    15\n    >>> sum_Of_product(5)\n    225\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n\n    result = 0\n    for i in range(1, n+1):\n        product = 1\n        for j in range(1, i+1):\n            product *= binomial_coefficient(i, j)\n        result += product\n\n    return result\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to be chosen.\n\n    Returns:\n    int: The binomial coefficient C(n, k).\n\n    Raises:\n    ValueError: If n or k is less than 0 or if k is greater than n.\n\n    Examples:\n    >>> binomial_coefficient(5, 3)\n    10\n    >>> binomial_coefficient(10, 0)\n    1\n    \"\"\"\n\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid values for n and k\")\n\n    if k == 0 or k == n:\n        return 1\n\n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_list(lst):\n    if len(lst) < 2:\n        return lst\n    else:\n        lst[0], lst[-1] = lst[-1], lst[0]\n        return lst\n\n# Test cases\nassert swap_list([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\nassert swap_list([1, 2, 3, 4, 5]) == [5, 2, 3, 4, 1]\nassert swap_list([10]) == [10]\nassert swap_list([]) == []", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n    \n    Parameters:\n    degrees (float): The value in degrees to be converted to radians.\n    \n    Returns:\n    float: The value in radians.\n    \"\"\"\n    return degrees * (math.pi / 180)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def get_lucid(n):\n    lucid_numbers = []\n    for num in range(1, n+1):\n        if is_lucid(num):\n            lucid_numbers.append(num)\n    return lucid_numbers\n\ndef is_lucid(num):\n    if num == 1:\n        return True\n    elif num % 2 == 0:\n        return False\n    else:\n        while num > 1:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = 3 * num + 1\n        return True\n\n# Test the function\nassert get_lucid(10) == [1, 2, 3, 5, 7]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    \"\"\"\n    Reverse the order of words separated by spaces in a given string.\n    \n    Parameters:\n    string (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: The input string with the words in reverse order.\n    \"\"\"\n    words = string.split()  # Split the string into a list of words\n    reversed_words = ' '.join(reversed(words))  # Reverse the order of words and join them back with spaces\n    return reversed_words", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n'th column of a matrix.\n\n    Args:\n    - matrix: A list of lists representing the matrix.\n    - n: The index of the column to find the maximum value.\n\n    Returns:\n    - The maximum value in the n'th column of the matrix.\n\n    Raises:\n    - ValueError: If the matrix is empty or the column index is out of range.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n\n    if not matrix:\n        raise ValueError(\"Matrix is empty\")\n\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n\n    if n < 0 or n >= num_cols:\n        raise ValueError(\"Column index out of range\")\n\n    max_value = float('-inf')\n\n    for row in matrix:\n        max_value = max(max_value, row[n])\n\n    return max_value", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[-5, -2, -10], [-5, -2, -10], [-8, -3, -7], [-6, -9, -4]], -1]]}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    averages = []\n    for tup in tuples:\n        avg = sum(tup) / len(tup)\n        averages.append(avg)\n    return averages", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, n):\n    \"\"\"\n    Find the median of two sorted lists of same size.\n\n    Args:\n    list1 (list): The first sorted list.\n    list2 (list): The second sorted list.\n    n (int): The size of the lists.\n\n    Returns:\n    float: The median value.\n\n    Raises:\n    ValueError: If the lists are not of the same size.\n\n    \"\"\"\n    if len(list1) != n or len(list2) != n:\n        raise ValueError(\"Lists must be of the same size.\")\n\n    merged_list = sorted(list1 + list2)\n    mid_index = n // 2\n\n    if n % 2 == 0:\n        median = (merged_list[mid_index - 1] + merged_list[mid_index]) / 2\n    else:\n        median = merged_list[mid_index]\n\n    return median", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5]], "plus_fail_tests": [[[1, 4, 7, 10, 13, 16, 19, 22, 25, 28], [2, 5, 8, 11, 14, 17, 20, 23, 26, 29], 10]]}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    if k < 0 or k >= len(lst):\n        raise ValueError(\"Invalid value of k\")\n    del lst[k]\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(string, pattern):\n    match = re.search(pattern, string)\n    if match:\n        start_index = match.start()\n        end_index = match.end() - 1\n        return match.group(), start_index, end_index\n    else:\n        return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["The quick brown fox jumps over the lazy dog.", "fox"]], "plus_fail_tests": [["", ""]]}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo(t1, t2):\n    \"\"\"\n    Perform element-wise modulo operation on two tuples of the same length.\n\n    Args:\n        t1 (tuple): The first tuple.\n        t2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the element-wise modulo results.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5))\n        (0, 4, 5, 1)\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    return tuple(a % b for a, b in zip(t1, t2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n\n    \"\"\"\n    # Calculate the sum of the first n natural numbers\n    total_sum = (n * (n + 1)) / 2\n\n    # Calculate the average of the first n natural numbers\n    average = total_sum / n\n\n    return total_sum, average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return even_numbers\n\n# Test the function\nassert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    \"\"\"\n    Takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n    \n    Args:\n        lst (list): A list of lists, where each sublist has two elements.\n    \n    Returns:\n        list: A list of two lists where the first list has the first element of each sublist and the second one has the second.\n    \"\"\"\n    result = [[], []]\n    for sublist in lst:\n        result[0].append(sublist[0])\n        result[1].append(sublist[1])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    total_sum = 0\n    for tup in tuple_list:\n        total_sum += sum(tup)\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divide two lists element-wise.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list containing the element-wise division of list1 and list2.\n\n    Raises:\n        ValueError: If the lengths of list1 and list2 are not equal.\n\n    Examples:\n        >>> div_list([4,5,6],[1, 2, 3])\n        [4.0, 2.5, 2.0]\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"The lengths of list1 and list2 must be equal.\")\n\n    return [x / y for x, y in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    return string.replace(' ', '%20')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "import math\ndef triangle_area(radius):\n    if radius <= 0:\n        return None\n    else:\n        height = math.sqrt(3) / 2 * radius\n        area = 0.5 * radius * height\n        return area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[0]], "plus_fail_tests": [[0.5]]}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(string):\n    \"\"\"\n    Convert a given string to uppercase.\n\n    Parameters:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to uppercase.\n    \"\"\"\n    return string.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    \"\"\"\n    Finds the size of the largest subset of a list of numbers so that every pair is divisible.\n\n    Args:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The size of the largest subset.\n\n    \"\"\"\n\n    def is_divisible(a, b):\n        \"\"\"\n        Checks if two numbers are divisible.\n\n        Args:\n        a (int): The first number.\n        b (int): The second number.\n\n        Returns:\n        bool: True if the numbers are divisible, False otherwise.\n\n        \"\"\"\n        return a % b == 0 or b % a == 0\n\n    def find_largest_subset_helper(numbers, current_subset, index):\n        \"\"\"\n        Helper function to recursively find the largest subset.\n\n        Args:\n        numbers (list): A list of numbers.\n        current_subset (list): The current subset being considered.\n        index (int): The index of the current number being considered.\n\n        Returns:\n        int: The size of the largest subset.\n\n        \"\"\"\n        if index == len(numbers):\n            return len(current_subset)\n\n        # Exclude the current number and move to the next index\n        exclude = find_largest_subset_helper(numbers, current_subset, index + 1)\n\n        # Include the current number if it is divisible with all the numbers in the current subset\n        include = 0\n        if all(is_divisible(numbers[index], num) for num in current_subset):\n            include = find_largest_subset_helper(numbers, current_subset + [numbers[index]], index + 1)\n\n        # Return the maximum size of the subsets\n        return max(exclude, include)\n\n    return find_largest_subset_helper(numbers, [], 0)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    return [num**n for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num(string):\n    # Initialize two empty strings to store the characters and numbers separately\n    chars = ''\n    nums = ''\n    \n    # Iterate through each character in the string\n    for char in string:\n        # Check if the character is a number\n        if char.isdigit():\n            # Append the number to the nums string\n            nums += char\n        else:\n            # Append the character to the chars string\n            chars += char\n    \n    # Concatenate the chars and nums strings and return the result\n    return chars + nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    bell[0][0] = 1\n\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(string):\n    \"\"\"\n    Function to put spaces between words starting with capital letters in a given string.\n    \n    Parameters:\n    string (str): The input string.\n    \n    Returns:\n    str: The modified string with spaces between words starting with capital letters.\n    \"\"\"\n    words = string.split()\n    modified_words = []\n    \n    for word in words:\n        if word[0].isupper():\n            modified_words.append(' ' + word)\n        else:\n            modified_words.append(word)\n    \n    return ''.join(modified_words).strip()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["PythonProgrammingExamples"]], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(text):\n    \"\"\"\n    Check if a string contains 'z' except at the start and end of the word.\n\n    Args:\n        text (str): The input string to check.\n\n    Returns:\n        bool: True if the string contains 'z' except at the start and end of the word, False otherwise.\n    \"\"\"\n    words = text.split()\n    for word in words:\n        if len(word) > 2 and word[0] != 'z' and word[-1] != 'z' and 'z' in word[1:-1]:\n            return True\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["zzzxyabczzz"]]}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "import re\ndef extract_quotation(string):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, string)\n    return matches", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone given its radius r and height h.\n    \n    Parameters:\n    r (float): The radius of the cone.\n    h (float): The height of the cone.\n    \n    Returns:\n    float: The lateral surface area of the cone.\n    \"\"\"\n    slant_height = math.sqrt(r**2 + h**2)\n    base_area = math.pi * r**2\n    lateral_surface_area = math.pi * r * slant_height\n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    result = base ** power\n    digit_sum = sum(int(digit) for digit in str(result))\n    return digit_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_sum(nums, target):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n    - nums: A list of integers.\n    - target: The target value to compare XOR results against.\n\n    Returns:\n    - The sum of XOR of all pairs of numbers in the given list.\n\n    Example:\n    >>> pair_xor_sum([5, 9, 7, 6], 4)\n    47\n    \"\"\"\n\n    result = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                result += 1\n    return result\n\n# Testing the function\nassert pair_xor_sum([5, 9, 7, 6], 4) == 47", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + 2*b\n        return b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(amount, expected_amount):\n    \"\"\"\n    Check whether the given amount has no profit and no loss.\n\n    Parameters:\n    amount (float): The actual amount.\n    expected_amount (float): The expected amount.\n\n    Returns:\n    bool: True if the amount has no profit and no loss, False otherwise.\n    \"\"\"\n    return amount == expected_amount", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        \n        if left_child < n and arr[left_child] < arr[i]:\n            return False\n        \n        if right_child < n and arr[right_child] < arr[i]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(lst):\n    total_sum = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)+1):\n            sublist = lst[i:j]\n            product = 1\n            for num in sublist:\n                product *= num\n            total_sum += product\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(num):\n    # Check if the number has at least 2 bits\n    if num & 3 == 0:\n        return num\n    \n    # Get the number of bits in the given number\n    num_bits = num.bit_length()\n    \n    # Create a mask to toggle all bits except the first and last bit\n    mask = (1 << (num_bits - 2)) - 1\n    \n    # Toggle the middle bits using the mask\n    toggled_num = num ^ mask\n    \n    return toggled_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[2147483647]]}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 4, 6, 8, 10, 12, 14], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]]]}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    filtered_students = {}\n    for student, (height, weight) in students.items():\n        if height > min_height and weight > min_weight:\n            filtered_students[student] = (height, weight)\n    return filtered_students\nmin_height = 6.0\nmin_weight = 70", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    result = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i-1]:\n            result.append(lst[i])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] < arr[left]:\n            largest = left\n\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    def build_heap(arr):\n        n = len(arr)\n\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n\n    def sort(arr):\n        build_heap(arr)\n        n = len(arr)\n\n        for i in range(n - 1, 0, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify(arr, i, 0)\n\n    sort(arr)\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the tuple and return a new tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        dictionary (dict): The dictionary to be added.\n\n    Returns:\n        tuple: A new tuple with the dictionary added.\n\n    Examples:\n        >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} )\n        (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    return tup + (dictionary,)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The second smallest number in the list.\n\n    Raises:\n        ValueError: If the list has less than two numbers.\n\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two numbers\")\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 2]]], "plus_fail_tests": [[[]]]}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_month_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n\n    Parameters:\n    month_number (int): The month number to be checked.\n\n    Returns:\n    bool: True if the month contains 30 days, False otherwise.\n    \"\"\"\n    # Define a list of month numbers that have 30 days\n    months_with_30_days = [4, 6, 9, 11]\n\n    # Check if the month number is in the list of months with 30 days\n    if month_number in months_with_30_days:\n        return True\n    else:\n        return False\n\n# Test the function\nassert check_month_number(6) == True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    # Initialize the first row\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Initialize the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Find the maximum average\n    max_average = 0\n    for i in range(n):\n        for j in range(n):\n            path_count = (i + 1) * (j + 1)\n            max_average = max(max_average, dp[i][j] / path_count)\n\n    return max_average", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [6, 5, 4], [7, 3, 9]]]], "plus_fail_tests": [[[[0, 0, 0], [0, 0, 0], [0, 0, -1]]]]}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    modified_string = string.replace(' ', '_')\n    return modified_string", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [["The_Avengers"]], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(string):\n    \"\"\"\n    Check whether the given string is starting with a vowel or not using regex.\n\n    Parameters:\n    string (str): The input string to be checked.\n\n    Returns:\n    bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU].*'\n    return re.match(pattern, string) is not None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(a):\n    \"\"\"\n    Calculate the area of a tetrahedron.\n\n    Parameters:\n    a (float): The length of the sides of the tetrahedron.\n\n    Returns:\n    float: The area of the tetrahedron.\n\n    Raises:\n    ValueError: If the input `a` is not a positive number.\n\n    \"\"\"\n    if a <= 0:\n        raise ValueError(\"The length of the sides of the tetrahedron must be a positive number.\")\n\n    # Calculate the area using Heron's formula\n    area = math.sqrt(3) * (a ** 2)\n\n    return area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "def occurrence_substring(string, substring):\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    Return None if there is no match.\n\n    Args:\n        string (str): The main string to search within.\n        substring (str): The substring to search for.\n\n    Returns:\n        tuple: A tuple containing the substring, starting index, and ending index of the first occurrence.\n        None: If there is no match.\n\n    Examples:\n        >>> occurrence_substring('python programming, python language','python')\n        ('python', 0, 6)\n        >>> occurrence_substring('python programming, python language','java')\n        None\n    \"\"\"\n    index = string.find(substring)\n    if index == -1:\n        return None\n    else:\n        return substring, index, index + len(substring) - 1\n\n# Testing the function\nassert occurrence_substring('python programming, python language','python') == ('python', 0, 6)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple to be converted.\n        \n    Returns:\n        dict: A dictionary where the keys are elements from the tuple and the values are the subsequent elements.\n        \n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n    \n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(digit) for digit in str(num)]\n        if all(num % digit == 0 for digit in digits):\n            result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 22]], "plus_fail_tests": [[100, 200]]}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any none value.\n\n    Args:\n    t (tuple): The input tuple to be checked.\n\n    Returns:\n    bool: True if the tuple has any none value, False otherwise.\n    \"\"\"\n    return None in t", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(string):\n    \"\"\"\n    Check whether all characters in a string are the same or not.\n\n    Parameters:\n    string (str): The input string to check.\n\n    Returns:\n    bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    return len(set(string)) == 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n    bracket_pairs = {')': '(', ']': '[', '}': '{'}\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n\n    return len(stack) == 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "def is_decimal(string):\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n    \n    Parameters:\n    string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string is a decimal number with a precision of 2, False otherwise.\n    \"\"\"\n    try:\n        number = float(string)\n        if '.' in string:\n            decimal_part = string.split('.')[1]\n            if len(decimal_part) > 2:\n                return False\n        return True\n    except ValueError:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["-123.11"]]}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def Diff(li1, li2):\n    return [i for i in li1 + li2 if i not in li1 or i not in li2]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array up to the given position 'k'\n    arr[:k] = arr[:k][::-1]\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Find the index of the smallest triangular number with n digits.\n\n    Parameters:\n    n (int): The number of digits in the triangular number.\n\n    Returns:\n    int: The index of the smallest triangular number with n digits.\n\n    \"\"\"\n    index = 1\n    triangular_number = 1\n\n    while True:\n        # Calculate the next triangular number\n        index += 1\n        triangular_number += index\n\n        # Check if the number of digits is equal to n\n        if len(str(triangular_number)) == n:\n            return index", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1]]}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n\n    Args:\n    - records: A list of tuples representing records, where each tuple contains a name and a value.\n    - k: An integer representing the number of minimum records to be returned.\n\n    Returns:\n    - A list of tuples containing the minimum k records.\n\n    Raises:\n    - ValueError: If k is greater than the number of records or if records is empty.\n\n    Examples:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    >>> min_k([('Alice', 9), ('Bob', 5), ('Charlie', 7)], 3)\n    [('Bob', 5), ('Charlie', 7), ('Alice', 9)]\n    >>> min_k([], 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: records is empty\n    >>> min_k([('John', 6), ('Jane', 8), ('Mike', 4)], 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: k is greater than the number of records\n    \"\"\"\n\n    if not records:\n        raise ValueError(\"records is empty\")\n\n    if k > len(records):\n        raise ValueError(\"k is greater than the number of records\")\n\n    sorted_records = sorted(records, key=lambda x: x[1])\n    return sorted_records[:k]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Find the nth nonagonal number.\n\n    A nonagonal number is a figurate number that represents a non-agon with n sides,\n    where each side has a length equal to the number.\n\n    Parameters:\n    n (int): The position of the nonagonal number to find.\n\n    Returns:\n    int: The nth nonagonal number.\n\n    \"\"\"\n    return n * (3 * n - 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1000000]]}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    Counts the number of indices where the two input lists have the same values.\n    \n    Args:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n    \n    Returns:\n    int: The number of indices where the lists have the same values.\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    # Sort the array in ascending order\n    arr = sorted(arr)\n    \n    # Initialize the minimum difference as the maximum possible value\n    min_diff = float('inf')\n    \n    # Iterate through the array to find the minimum difference\n    for i in range(n-1):\n        diff = arr[i+1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sum_name_lengths(names):\n    total_length = 0\n    for name in names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length\n\n# Test the function\nassert sum_name_lengths(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    n = n % len(lst)  # handle cases where n > len(lst)\n    return lst[-n:] + lst[:-n]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar(string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with replaced special characters.\n\n    Examples:\n        >>> replace_specialchar('Python language, Programming language.')\n        'Python:language::Programming:language:'\n    \"\"\"\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        string = string.replace(char, ':')\n    return string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, value):\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def wind_chill(wind_velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \n    Args:\n        wind_velocity (int): Wind velocity in km/h.\n        temperature (int): Temperature in celsius.\n    \n    Returns:\n        int: Wind chill index rounded to the next integer.\n    \"\"\"\n    wind_chill_index = 13.12 + (0.6215 * temperature) - (11.37 * (wind_velocity ** 0.16)) + (0.3965 * temperature * (wind_velocity ** 0.16))\n    return round(wind_chill_index)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for string in string_list:\n        if string == string[::-1]:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["julia", "best", "tseb", "for", "ailuj"]]], "plus_fail_tests": [[["abc", "cba", "def", "fed", "hij", "jih", "klm", "mlk"]]]}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count(nums, target_sum):\n    count = 0\n    pairs = {}\n    \n    for num in nums:\n        complement = target_sum - num\n        if complement in pairs:\n            count += pairs[complement]\n        if num in pairs:\n            pairs[num] += 1\n        else:\n            pairs[num] = 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element(nums):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        nums (list): A list of numbers.\n        \n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    Function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length.\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i] + list2[i])\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    # Count the number of zeroes in the list\n    zero_count = lst.count(0)\n\n    # Remove all zeroes from the list\n    lst = [num for num in lst if num != 0]\n\n    # Append the required number of zeroes at the end of the list\n    lst.extend([0] * zero_count)\n\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    left = 0\n    right = len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(numbers):\n    # Convert strings to integers and sort the list\n    sorted_numbers = sorted(numbers, key=lambda x: int(x))\n    \n    # Convert the sorted list back to integers\n    sorted_numbers = [int(num) for num in sorted_numbers]\n    \n    return sorted_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the fourth power of the first n odd natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> odd_num_sum(2)\n    82\n    >>> odd_num_sum(3)\n    2026\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    sum_of_powers = 0\n    for i in range(1, 2*n + 1, 2):\n        sum_of_powers += i ** 4\n\n    return sum_of_powers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i+1]))\n    return pairs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    \"\"\"\n    Removes all words with length k from the given string.\n\n    Args:\n        string (str): The input string.\n        k (int): The length of words to be removed.\n\n    Returns:\n        str: The modified string with words of length k removed.\n    \"\"\"\n    words = string.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    even_num = None\n    odd_num = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if even_num is None:\n                even_num = num\n            else:\n                return \"Only one even number is expected in the list.\"\n        else:\n            if odd_num is None:\n                odd_num = num\n            else:\n                return \"Only one odd number is expected in the list.\"\n    \n    if even_num is None or odd_num is None:\n        return \"Both even and odd numbers are required in the list.\"\n    \n    return even_num * odd_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 4, 1, 6, 8]]], "plus_fail_tests": [[[-10, -5, 0, 5, 10]]]}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    \"\"\"\n    Calculates the sum of non-repeated elements in a given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of non-repeated elements in the list.\n\n    Examples:\n    >>> find_sum([1, 2, 3, 1, 1, 4, 5, 6])\n    21\n    >>> find_sum([1, 2, 3, 4, 5])\n    15\n    >>> find_sum([1, 1, 1, 1, 1])\n    0\n    \"\"\"\n\n    # Create a dictionary to store the count of each element in the list\n    count_dict = {}\n\n    # Count the occurrences of each element in the list\n    for num in lst:\n        count_dict[num] = count_dict.get(num, 0) + 1\n\n    # Calculate the sum of non-repeated elements\n    sum_non_repeated = 0\n    for num, count in count_dict.items():\n        if count == 1:\n            sum_non_repeated += num\n\n    return sum_non_repeated", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    total_sum = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)+1):\n            if (j - i) % 2 != 0:\n                total_sum += sum(arr[i:j])\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    result = []\n    current_sublist = [lst[0]]\n\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current_sublist.append(lst[i])\n        else:\n            result.append(current_sublist)\n            current_sublist = [lst[i]]\n\n    result.append(current_sublist)\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "def find_combinations(tuples):\n    combinations = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            combinations.append((tuples[i][0] + tuples[j][0], tuples[i][1] + tuples[j][1]))\n            combinations.append((tuples[i][0] + tuples[j][1], tuples[i][1] + tuples[j][0]))\n    return combinations", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    \"\"\"\n    Function to match a string that has an 'a' followed by three 'b'.\n    \n    Args:\n        text (str): The input string to be matched.\n    \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'abbb'\n    return bool(re.search(pattern, text))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, value):\n    \"\"\"\n    Find the right insertion point for a specified value in sorted order.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    value (int): The value to be inserted.\n\n    Returns:\n    int: The index where the value should be inserted to maintain sorted order.\n\n    Examples:\n    >>> right_insertion([1,2,4,5], 6)\n    4\n    >>> right_insertion([1,2,4,5], 3)\n    2\n    >>> right_insertion([1,2,4,5], 1)\n    1\n    \"\"\"\n\n    # Initialize the left and right pointers\n    left = 0\n    right = len(arr) - 1\n\n    # Perform binary search to find the right insertion point\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, -90.20293226837086, -12.02758648076636, -35.964731488229475], false]]}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors is even.\n\n    Parameters:\n    n (int): The number to check for divisors.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    # Remove the parentheses from the string\n    tuple_str = tuple_str.replace(\"(\", \"\").replace(\")\", \"\")\n    \n    # Split the string by commas and convert each element to integer\n    int_tuple = tuple(map(int, tuple_str.split(\",\")))\n    \n    return int_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(string):\n    max_run = 0\n    current_run = 0\n\n    for char in string:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n\n    return max_run", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(string):\n    \"\"\"\n    Removes all whitespaces from a given string.\n\n    Parameters:\n    string (str): The input string from which whitespaces are to be removed.\n\n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "import math\ndef is_perfect_square(num):\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Parameters:\n    num (int): The number to be checked.\n    \n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    sqrt = math.isqrt(num)\n    return sqrt * sqrt == num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    \"\"\"\n    Create a new tuple from the given string and list.\n\n    Args:\n        lst (list): The list of elements.\n        string (str): The string to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple with the elements from the list and the string.\n\n    Examples:\n        >>> new_tuple([\"WEB\", \"is\"], \"best\")\n        ('WEB', 'is', 'best')\n    \"\"\"\n    return tuple(lst + [string])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(lst):\n    max_sum = float('-inf')\n    max_list = []\n    \n    for sub_list in lst:\n        sub_sum = sum(sub_list)\n        if sub_sum > max_sum:\n            max_sum = sub_sum\n            max_list = sub_list\n    \n    return max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(num, d):\n    # Convert number to binary string\n    binary_str = bin(num)[2:]\n    \n    # Rotate the binary string by d bits\n    rotated_str = binary_str[d:] + binary_str[:d]\n    \n    # Convert the rotated binary string back to decimal\n    rotated_num = int(rotated_str, 2)\n    \n    return rotated_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[16, 2]], "plus_fail_tests": [[1, 1]]}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    Counts the number of equal numbers from three given integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n        c (int): The third integer.\n\n    Returns:\n        int: The count of equal numbers.\n\n    Raises:\n        TypeError: If any of the arguments are not integers.\n\n    Examples:\n        >>> test_three_equal(1, 1, 1)\n        3\n        >>> test_three_equal(1, 2, 3)\n        0\n        >>> test_three_equal(1, 1, 2)\n        2\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        raise TypeError(\"All arguments must be integers.\")\n\n    count = 0\n    if a == b:\n        count += 1\n    if b == c:\n        count += 1\n    if a == c:\n        count += 1\n\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 2, 2]], "plus_fail_tests": [[10, 10, 20]]}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    Calculate the sum of all values in the given dictionary.\n\n    Args:\n        dictionary (dict): A dictionary containing key-value pairs.\n\n    Returns:\n        int: The sum of all values in the dictionary.\n\n    Raises:\n        TypeError: If the input is not a dictionary.\n\n    Examples:\n        >>> return_sum({'a': 100, 'b': 200, 'c': 300})\n        600\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        raise TypeError(\"Input must be a dictionary.\")\n\n    return sum(dictionary.values())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    left = 0\n    right = len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"\n    Calculate the sum of an array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int: The sum of the numbers in the array.\n    \"\"\"\n    return sum(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    Check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\n    Args:\n    tuple1 (tuple): The first tuple.\n    tuple2 (tuple): The second tuple.\n\n    Returns:\n    bool: True if each element of tuple2 is smaller than its corresponding element in tuple1, False otherwise.\n    \"\"\"\n    for i in range(len(tuple1)):\n        if tuple1[i] >= tuple2[i]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3], [2, 3, 4]]], "plus_fail_tests": [[[3, 7, 11, 15, 19], [2, 6, 10, 14, 18]]]}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested(tup):\n    \"\"\"\n    Remove tuples from the given tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        tuple: The modified tuple with tuples removed.\n\n    \"\"\"\n    result = []\n    for item in tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K(tuple_data, k):\n    \"\"\"\n    Check if the given tuples contain the k or not.\n\n    Args:\n    tuple_data (tuple): The input tuple to be checked.\n    k (int): The value to be searched in the tuple.\n\n    Returns:\n    bool: True if the value k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_data", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(lists):\n    \"\"\"\n    Count the number of lists in a given number of lists.\n\n    Args:\n    - lists: A list of lists.\n\n    Returns:\n    - count: An integer representing the number of lists.\n\n    Example:\n    >>> count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]])\n    4\n    \"\"\"\n    count = 0\n    for lst in lists:\n        if isinstance(lst, list):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    bool: True if the product is even, False otherwise.\n    \"\"\"\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(text):\n    \"\"\"\n    Function to match a string that has an 'a' followed by anything, ending in 'b'.\n    \n    Args:\n        text (str): The input text to be matched.\n    \n    Returns:\n        bool: True if the text matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"a.*b$\"\n    return bool(re.match(pattern, text))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    Calculates the sum of all odd natural numbers within the range l and r.\n\n    Parameters:\n    l (int): The lower bound of the range.\n    r (int): The upper bound of the range.\n\n    Returns:\n    int: The sum of all odd natural numbers within the range.\n\n    Raises:\n    ValueError: If l is greater than r.\n\n    Examples:\n    >>> sum_in_range(2, 5)\n    8\n    >>> sum_in_range(1, 10)\n    25\n    >>> sum_in_range(5, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: l cannot be greater than r.\n    \"\"\"\n\n    if l > r:\n        raise ValueError(\"l cannot be greater than r.\")\n\n    sum_odd = 0\n    for num in range(l, r+1):\n        if num % 2 != 0:\n            sum_odd += num\n\n    return sum_odd", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sumofFactors(num):\n    factors = [i for i in range(1, num+1) if num % i == 0 and i % 2 == 0]\n    return sum(factors)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates(coordinate):\n    x, y = coordinate\n    adjacent_coordinates = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i != 0 or j != 0:\n                adjacent_coordinates.append([x + i, y + j])\n    return adjacent_coordinates", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4]]], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    if n <= 1:\n        return 1\n    else:\n        result = 0\n        for i in range(n):\n            result += catalan_number(i) * catalan_number(n - i - 1)\n        return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def get_next_prime(num):\n        while True:\n            num += 1\n            if is_prime(num):\n                return num\n\n    def get_polite_number(n):\n        count = 0\n        num = 2\n        while count < n:\n            if is_prime(num):\n                count += 1\n            num = get_next_prime(num)\n        return num\n\n    return get_polite_number(n)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[10000000]]}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "def combinations_colors(lst, n):\n    if n == 0:\n        return [()]\n    else:\n        result = []\n        for i in range(len(lst)):\n            for combo in combinations_colors(lst, n-1):\n                result.append(combo + (lst[i],))\n        return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    \"\"\"\n    Calculates the sum of the first n even natural numbers raised to the fifth power.\n    \n    Parameters:\n    n (int): The number of even natural numbers to consider.\n    \n    Returns:\n    int: The sum of the first n even natural numbers raised to the fifth power.\n    \"\"\"\n    sum = 0\n    count = 0\n    num = 2\n    \n    while count < n:\n        if num % 2 == 0:\n            sum += num ** 5\n            count += 1\n        num += 1\n    \n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_rotations(string):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n\n    Raises:\n    ValueError: If the input is not a string.\n\n    Examples:\n    >>> find_rotations(\"aaaa\")\n    1\n    >>> find_rotations(\"abcde\")\n    5\n    >>> find_rotations(\"\")\n    0\n    \"\"\"\n\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n\n    if len(string) == 0:\n        return 0\n\n    rotations = 1\n    while string != string[1:] + string[0]:\n        string = string[1:] + string[0]\n        rotations += 1\n\n    return rotations\n\n# Testing the function\nassert find_rotations(\"aaaa\") == 1\nassert find_rotations(\"abcde\") == 5\nassert find_rotations(\"\") == 0", "base_status": "timeout", "plus_status": "timeout", "base_fail_tests": [], "plus_fail_tests": []}]}}