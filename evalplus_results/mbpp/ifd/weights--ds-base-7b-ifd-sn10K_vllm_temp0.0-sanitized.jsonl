{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    \"\"\"\n    Finds the shared elements from the given two lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A list containing the shared elements.\n\n    Raises:\n        TypeError: If either list1 or list2 is not a list.\n\n    Examples:\n        >>> similar_elements([1, 2, 3, 4], [3, 4, 5, 6])\n        [3, 4]\n        >>> similar_elements([1, 2, 3], [4, 5, 6])\n        []\n    \"\"\"\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both arguments must be lists.\")\n\n    return list(set(list1) & set(list2))"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums (list): A list of numbers.\n        n (int): The number of largest integers to find.\n\n    Returns:\n        list: A list of the n largest integers in descending order.\n\n    Raises:\n        ValueError: If n is greater than the length of the input list.\n\n    Examples:\n        >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n        [85, 75, 65]\n    \"\"\"\n    if n > len(nums):\n        raise ValueError(\"n cannot be greater than the length of the input list.\")\n\n    # Use heapq.nlargest() to find the n largest integers\n    largest_nums = heapq.nlargest(n, nums)\n\n    # Reverse the list to get the descending order\n    largest_nums.reverse()\n\n    return largest_nums"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check whether the two numbers differ at one bit position only.\n\n    Args:\n        num1 (int): The first number.\n        num2 (int): The second number.\n\n    Returns:\n        bool: True if the two numbers differ at one bit position only, False otherwise.\n    \"\"\"\n    # XOR the two numbers to find the bit positions where they differ\n    xor_result = num1 ^ num2\n\n    # Count the number of set bits in the XOR result\n    set_bit_count = bin(xor_result).count('1')\n\n    # If the count is 1, the two numbers differ at one bit position only\n    return set_bit_count == 1"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(string):\n    \"\"\"\n    Find all words that are at least 4 characters long in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of words that are at least 4 characters long.\n\n    Examples:\n        >>> find_char_long('Please move back to stream')\n        ['Please', 'move', 'back', 'stream']\n    \"\"\"\n    words = string.split()\n    result = [word for word in words if len(word) >= 4]\n    return result"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list with the squares of each number.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    list: A new list with the squares of each number in the input list.\n\n    Examples:\n    >>> square_nums([1, 2, 3, 4, 5])\n    [1, 4, 9, 16, 25]\n    >>> square_nums([-2, 0, 4, 8])\n    [4, 0, 16, 64]\n    >>> square_nums([])\n    []\n    \"\"\"\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "def find_rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n\n    Raises:\n        ValueError: If the input string is empty.\n\n    Examples:\n        >>> find_rotations(\"aaaa\")\n        1\n        >>> find_rotations(\"abcde\")\n        5\n        >>> find_rotations(\"\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Input string cannot be empty.\n    \"\"\"\n    if not s:\n        raise ValueError(\"Input string cannot be empty.\")\n\n    # Concatenate the string with itself\n    s += s\n\n    # Find the length of the original string\n    n = len(s) // 2\n\n    # Find the length of the longest proper prefix that is also a proper suffix\n    lps = [0] * n\n    length = 0\n    i = 1\n\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The minimum number of rotations is the difference between the length of the original string and the length of the longest proper prefix that is also a proper suffix\n    return n - lps[-1]"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from a string.\n\n    Args:\n        string (str): The input string.\n        char (str): The character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrence of the character removed.\n\n    Raises:\n        ValueError: If the input string is empty or the character to be removed is not found in the string.\n\n    Examples:\n        >>> remove_Occ(\"hello\", \"l\")\n        'heo'\n        >>> remove_Occ(\"python\", \"o\")\n        'pythn'\n        >>> remove_Occ(\"\", \"a\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Input string cannot be empty.\n        >>> remove_Occ(\"python\", \"z\")\n        Traceback (most recent call last):\n        ...\n        ValueError: Character 'z' not found in the string.\n    \"\"\"\n    if not string:\n        raise ValueError(\"Input string cannot be empty.\")\n\n    if char not in string:\n        raise ValueError(f\"Character '{char}' not found in the string.\")\n\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n\n    return string[:first_index] + string[last_index+1:]"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n        list of lists: The sorted matrix.\n\n    Raises:\n        ValueError: If the input matrix is empty or not a valid matrix.\n\n    Examples:\n        >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n        [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n\n    # Check if the input matrix is empty\n    if not matrix:\n        raise ValueError(\"Input matrix cannot be empty.\")\n\n    # Check if the input matrix is a valid matrix\n    num_cols = len(matrix[0])\n    for row in matrix:\n        if len(row) != num_cols:\n            raise ValueError(\"Input matrix is not a valid matrix.\")\n\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n\n    return sorted_matrix"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculates the volume of a triangular prism.\n\n    Parameters:\n    base (float): The base length of the triangular prism.\n    height (float): The height of the triangular prism.\n    length (float): The length of the triangular prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n\n    Raises:\n    ValueError: If any of the input parameters are negative or zero.\n\n    \"\"\"\n\n    if base <= 0 or height <= 0 or length <= 0:\n        raise ValueError(\"Base, height, and length must be positive numbers.\")\n\n    volume = (base * height * length) / 2\n    return volume"}
{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(text):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    # Split the input string into words using underscore as the delimiter\n    words = text.split('_')\n\n    # Check if each word is lowercase\n    for word in words:\n        if not word.islower():\n            return False\n\n    return True"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Calculates the perimeter of a square given its side length.\n\n    Parameters:\n    side_length (float or int): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> square_perimeter(10)\n    40\n    >>> square_perimeter(0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 4 * side_length"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(string1, string2):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Args:\n        string1 (str): The first string.\n        string2 (str): The second string.\n\n    Returns:\n        str: The modified string with characters removed.\n\n    Examples:\n        >>> remove_dirty_chars(\"probasscurve\", \"pros\")\n        'bacuve'\n        >>> remove_dirty_chars(\"hello\", \"world\")\n        'hello'\n        >>> remove_dirty_chars(\"python\", \"\")\n        'python'\n    \"\"\"\n    # Create a set of characters from string2\n    dirty_chars = set(string2)\n\n    # Use list comprehension to filter out characters from string1 that are in dirty_chars\n    clean_string = ''.join([char for char in string1 if char not in dirty_chars])\n\n    return clean_string"}
{"task_id": "Mbpp/19", "solution": "def has_duplicate(arr):\n    \"\"\"\n    Check if a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): The array of integers to be checked.\n\n    Returns:\n    bool: True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    # Create an empty set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each element in the array\n    for element in arr:\n        # If the element is already in the set, it is a duplicate\n        if element in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(element)\n\n    # If no duplicate is found, return False\n    return False\n\n# Test the function\nassert has_duplicate([1, 2, 3, 4, 5]) == False\nassert has_duplicate([1, 2, 3, 2, 4, 5]) == True\nassert has_duplicate([1, 1, 2, 3, 4, 5]) == True"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    A Woodall number is a positive integer that is the product of two consecutive integers\n    (i.e., n = (2^p) * (2^(p+1)), where p is a positive integer).\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number is a Woodall number, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    # Check if n is a power of 2\n    if n & (n - 1) != 0:\n        return False\n\n    # Check if n is a product of two consecutive powers of 2\n    p = 0\n    while n % 2 == 0:\n        n //= 2\n        p += 1\n\n    return n == 1 and p > 0"}
{"task_id": "Mbpp/56", "solution": "def check(num):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Reverse the number\n    reverse_num = int(str(num)[::-1])\n\n    # Check if the number is one less than twice its reverse\n    if num == reverse_num * 2 - 1:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    \"\"\"\n    Finds the largest number that can be formed with the given list of digits.\n\n    Args:\n        digits (list): A list of integers representing the digits.\n\n    Returns:\n        int: The largest number that can be formed with the given digits.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> find_Max_Num([1, 2, 3])\n        321\n        >>> find_Max_Num([4, 2, 4, 5, 3, 7])\n        754432\n        >>> find_Max_Num([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not digits:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n\n    # Convert the sorted digits to a string and convert it back to an integer\n    max_num = int(''.join(map(str, sorted_digits)))\n\n    return max_num"}
{"task_id": "Mbpp/58", "solution": "def opposite_signs(a, b):\n    \"\"\"\n    Check whether the given two integers have opposite signs or not.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    bool: True if the two integers have opposite signs, False otherwise.\n    \"\"\"\n    return (a ^ b) < 0\n\n# Test cases\nassert opposite_signs(1, -2) == True\nassert opposite_signs(1, 2) == False\nassert opposite_signs(-1, 2) == False\nassert opposite_signs(-1, -2) == True"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    Calculates the nth octagonal number.\n\n    Parameters:\n    n (int): The position of the octagonal number to be calculated.\n\n    Returns:\n    int: The nth octagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/61", "solution": "def count_substrings(s):\n    \"\"\"\n    Count the number of substrings with the sum of digits equal to their length.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of substrings with the sum of digits equal to their length.\n\n    Examples:\n        >>> count_substrings('112112')\n        6\n        >>> count_substrings('12345')\n        0\n        >>> count_substrings('123456')\n        21\n    \"\"\"\n    count = 0\n    n = len(s)\n\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            substring_sum = sum(int(digit) for digit in substring)\n            if substring_sum == len(substring):\n                count += 1\n\n    return count"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> smallest_num([10, 20, 1, 45, 99])\n        1\n        >>> smallest_num([-10, -20, -1, -45, -99])\n        -99\n        >>> smallest_num([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n\n    return smallest"}
{"task_id": "Mbpp/63", "solution": "def max_difference(tuple_list):\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        tuple_list (list): A list of tuples, where each tuple contains two integers.\n\n    Returns:\n        int: The maximum difference between available pairs.\n\n    Raises:\n        ValueError: If the input list is empty or contains tuples with less than two elements.\n\n    Examples:\n        >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n        7\n        >>> max_difference([(1, 1), (2, 2), (3, 3)])\n        0\n        >>> max_difference([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n        >>> max_difference([(1,)])\n        Traceback (most recent call last):\n        ...\n        ValueError: Tuples in the list must have at least two elements.\n    \"\"\"\n    if not tuple_list:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    max_diff = float('-inf')\n    for i in range(len(tuple_list)):\n        if len(tuple_list[i]) < 2:\n            raise ValueError(\"Tuples in the list must have at least two elements.\")\n        for j in range(i + 1, len(tuple_list)):\n            diff = abs(tuple_list[i][0] - tuple_list[j][0]) + abs(tuple_list[i][1] - tuple_list[j][1])\n            max_diff = max(max_diff, diff)\n\n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def sort_tuples_by_second_value(lst):\n    \"\"\"\n    Sorts a list of tuples based on the second value of each tuple.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        list: A new list of tuples sorted based on the second value of each tuple.\n\n    Examples:\n        >>> subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n        [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n    \"\"\"\n    return sorted(lst, key=lambda x: x[1])\n\n\n# Testing the function\nassert sort_tuples_by_second_value([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    \"\"\"\n    Recursively flattens a list and sums all its elements.\n\n    Args:\n        lst (list): The list to be flattened and summed.\n\n    Returns:\n        int: The sum of all elements in the flattened list.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> recursive_list_sum([1, 2, [3,4],[5,6]])\n        21\n        >>> recursive_list_sum([1, 2, [3,4],[5,6], 7])\n        28\n        >>> recursive_list_sum([1, 2, [3,4],[5,6], 7, [8, 9]])\n        36\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    def flatten(lst):\n        \"\"\"\n        Recursively flattens a list.\n\n        Args:\n            lst (list): The list to be flattened.\n\n        Returns:\n            list: The flattened list.\n        \"\"\"\n        flattened = []\n        for item in lst:\n            if isinstance(item, list):\n                flattened.extend(flatten(item))\n            else:\n                flattened.append(item)\n        return flattened\n\n    def sum_list(lst):\n        \"\"\"\n        Sums all elements in a list.\n\n        Args:\n            lst (list): The list to be summed.\n\n        Returns:\n            int: The sum of all elements in the list.\n        \"\"\"\n        return sum(lst)\n\n    return sum_list(flatten(lst))"}
{"task_id": "Mbpp/66", "solution": "def pos_count(nums):\n    \"\"\"\n    Count the number of positive numbers in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The number of positive numbers in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> pos_count([1,-2,3,-4])\n        2\n        >>> pos_count([-1,-2,-3])\n        0\n        >>> pos_count([1,2,3])\n        3\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list.\")\n\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Calculates the number of ways to partition a set of Bell numbers.\n\n    Parameters:\n    n (int): The number of Bell numbers to partition.\n\n    Returns:\n    int: The number of ways to partition the set of Bell numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Initialize the Bell number array\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n\n    # Calculate the Bell numbers\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n\n    # Return the number of ways to partition the set of Bell numbers\n    return bell[n][0]"}
{"task_id": "Mbpp/68", "solution": "def is_monotonic(arr):\n    \"\"\"\n    Check whether the given array is monotonic or not.\n\n    Parameters:\n    arr (list): The input array to be checked.\n\n    Returns:\n    bool: True if the array is monotonic, False otherwise.\n\n    Examples:\n    >>> is_monotonic([6, 5, 4, 4])\n    True\n    >>> is_monotonic([1, 2, 3, 4])\n    True\n    >>> is_monotonic([4, 3, 2, 1])\n    True\n    >>> is_monotonic([1, 2, 0, 4])\n    False\n    >>> is_monotonic([1, 1, 1, 1])\n    True\n    >>> is_monotonic([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n\n    # Check if the array is empty or has only one element\n    if len(arr) <= 1:\n        return True\n\n    # Check if the array is increasing or decreasing\n    increasing = arr[0] <= arr[-1]\n\n    # Iterate through the array and check if the order is consistent\n    for i in range(1, len(arr)):\n        if increasing and arr[i] < arr[i-1]:\n            return False\n        elif not increasing and arr[i] > arr[i-1]:\n            return False\n\n    return True"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(lst, sublst):\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n\n    Args:\n        lst (list): The main list to be checked.\n        sublst (list): The sublist to be searched in the main list.\n\n    Returns:\n        bool: True if the sublist is found in the main list, False otherwise.\n    \"\"\"\n    # Convert the main list and sublist to tuples for easier comparison\n    lst_tup = tuple(lst)\n    sublst_tup = tuple(sublst)\n\n    # Check if the sublist is a substring of the main list\n    if sublst_tup in lst_tup:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    \"\"\"\n    Check if all tuples in the given list have equal length.\n\n    Args:\n        tuples (list): A list of tuples.\n\n    Returns:\n        bool: True if all tuples have equal length, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not tuples:\n        return False\n\n    # Get the length of the first tuple\n    length = len(tuples[0])\n\n    # Check if all tuples have the same length\n    for t in tuples:\n        if len(t) != length:\n            return False\n\n    return True"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(lst):\n    \"\"\"\n    Sorts a list of elements using the Comb Sort algorithm.\n\n    Parameters:\n    lst (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list of elements.\n\n    \"\"\"\n\n    # Initialize the gap size\n    gap = len(lst)\n\n    # Initialize a flag to check if any swaps have been made\n    swapped = True\n\n    while gap > 1 or swapped:\n        # Reduce the gap size by a factor of 1.3\n        gap = int(gap / 1.3)\n\n        if gap < 1:\n            gap = 1\n\n        swapped = False\n\n        for i in range(len(lst) - gap):\n            if lst[i] > lst[i + gap]:\n                # Swap the elements\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                swapped = True\n\n    return lst"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares or not.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    # Check if the number is negative\n    if n < 0:\n        return False\n\n    # Check if the number is a perfect square\n    if int(n ** 0.5) ** 2 == n:\n        return True\n\n    # Check if the number can be represented as the difference of two squares\n    for i in range(1, int(n ** 0.5) + 1):\n        if int((n - i ** 2) ** 0.5) ** 2 == n - i ** 2:\n            return True\n\n    return False"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(patterns, sequence):\n    \"\"\"\n    Check whether the given sequence follows the patterns.\n\n    Args:\n        patterns (list): A list of patterns to be checked.\n        sequence (list): A list of elements to be checked against the patterns.\n\n    Returns:\n        bool: True if the sequence follows the patterns, False otherwise.\n\n    Raises:\n        ValueError: If the lengths of patterns and sequence are not equal.\n\n    Examples:\n        >>> is_samepatterns([\"red\", \"green\", \"green\"], [\"a\", \"b\", \"b\"])\n        True\n        >>> is_samepatterns([\"red\", \"green\", \"green\"], [\"a\", \"b\", \"c\"])\n        False\n    \"\"\"\n    if len(patterns) != len(sequence):\n        raise ValueError(\"Lengths of patterns and sequence must be equal.\")\n\n    for i in range(len(patterns)):\n        if patterns[i] != sequence[i]:\n            return False\n\n    return True"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the given list of tuples that have all elements divisible by k.\n\n    Args:\n        tuples_list (list): A list of tuples.\n        k (int): The divisor.\n\n    Returns:\n        list: A list of tuples that have all elements divisible by k.\n\n    Examples:\n        >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n        [(6, 24, 12)]\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result"}
{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(num):\n    \"\"\"\n    Check if a number is divisible by 11.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    # Convert the number to a string to access individual digits\n    num_str = str(num)\n\n    # Initialize the sum of odd and even digits\n    odd_sum = 0\n    even_sum = 0\n\n    # Iterate through each digit in the number\n    for i, digit in enumerate(num_str):\n        # Add odd digits to odd_sum\n        if i % 2 == 0:\n            odd_sum += int(digit)\n        # Add even digits to even_sum\n        else:\n            even_sum += int(digit)\n\n    # Calculate the difference between odd_sum and even_sum\n    diff = abs(odd_sum - even_sum)\n\n    # Check if the difference is divisible by 11\n    if diff % 11 == 0:\n        return True\n    else:\n        return False\n\n# Test cases\nassert is_divisible_by_11(12345) == False\nassert is_divisible_by_11(1111111111) == True\nassert is_divisible_by_11(121) == True"}
{"task_id": "Mbpp/79", "solution": "def is_odd_length(word):\n    \"\"\"\n    Check whether the length of a word is odd or not.\n\n    Args:\n        word (str): The word to be checked.\n\n    Returns:\n        bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0\n\n# Test cases\nassert is_odd_length(\"Hadoop\") == False\nassert is_odd_length(\"Python\") == True\nassert is_odd_length(\"Java\") == False"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculates the nth tetrahedral number.\n\n    Parameters:\n    n (int): The position of the tetrahedral number to be calculated.\n\n    Returns:\n    int: The nth tetrahedral number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> tetrahedral_number(5)\n    35\n    >>> tetrahedral_number(10)\n    225\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    \"\"\"\n    Calculates the volume of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume"}
{"task_id": "Mbpp/84", "solution": "def newman_conway(n):\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n\n    Parameters:\n    n (int): The index of the number to be found in the sequence.\n\n    Returns:\n    int: The nth number in the Newman-Conway sequence.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1.\")\n\n    sequence = [0, 1, 1]  # Initialize the sequence with the first three numbers\n\n    for i in range(3, n + 1):\n        if i % 2 == 0:\n            sequence.append(sequence[i // 2])\n        else:\n            sequence.append(sequence[(i - 1) // 2] + sequence[(i + 1) // 2])\n\n    return sequence[n]\n\n\n# Testing the function\nassert newman_conway(10) == 6"}
{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculates the surface area of a sphere.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n\n    surface_area = 4 * math.pi * radius**2\n    return surface_area"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculates the nth centered hexagonal number.\n\n    Parameters:\n    n (int): The position of the centered hexagonal number to be calculated.\n\n    Returns:\n    int: The nth centered hexagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> centered_hexagonal_number(10)\n    271\n    >>> centered_hexagonal_number(1)\n    1\n    >>> centered_hexagonal_number(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merge three dictionaries into a single dictionary.\n\n    Args:\n        dict1 (dict): The first dictionary.\n        dict2 (dict): The second dictionary.\n        dict3 (dict): The third dictionary.\n\n    Returns:\n        dict: A new dictionary that contains all the key-value pairs from the input dictionaries.\n\n    Raises:\n        TypeError: If any of the input arguments is not a dictionary.\n\n    Examples:\n        >>> merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })\n        {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}\n    \"\"\"\n\n    # Check if all input arguments are dictionaries\n    if not isinstance(dict1, dict) or not isinstance(dict2, dict) or not isinstance(dict3, dict):\n        raise TypeError(\"All input arguments must be dictionaries.\")\n\n    # Merge dictionaries\n    merged_dict = {**dict1, **dict2, **dict3}\n\n    return merged_dict"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list as input and returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    dict: A dictionary where the keys are the unique elements in the list and the values are the frequencies of those elements.\n\n    Examples:\n    >>> freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30])\n    {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    >>> freq_count(['a', 'b', 'c', 'a', 'b', 'c', 'c'])\n    {'a': 2, 'b': 2, 'c': 3}\n    >>> freq_count([])\n    {}\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    Find the closest smaller number than n.\n\n    Args:\n        n (int): The number to find the closest smaller number for.\n\n    Returns:\n        int: The closest smaller number than n.\n\n    Raises:\n        ValueError: If n is less than or equal to 1.\n\n    Examples:\n        >>> closest_num(11)\n        10\n        >>> closest_num(10)\n        9\n        >>> closest_num(1)\n        Traceback (most recent call last):\n        ...\n        ValueError: n must be greater than 1.\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n\n    # Find the closest smaller number by subtracting 1 from n until it becomes a power of 2\n    closest_num = n - 1\n    while closest_num & (closest_num - 1) != 0:\n        closest_num -= 1\n\n    return closest_num"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        int: The length of the longest word.\n\n    Raises:\n        ValueError: If the input is not a list or if the list is empty.\n\n    Examples:\n        >>> len_log([\"python\", \"PHP\", \"bigdata\"])\n        7\n        >>> len_log([\"hello\", \"world\"])\n        5\n        >>> len_log([])\n        Traceback (most recent call last):\n        ...\n        ValueError: The input list is empty.\n        >>> len_log(\"hello\")\n        Traceback (most recent call last):\n        ...\n        ValueError: The input is not a list.\n    \"\"\"\n    if not isinstance(words, list):\n        raise ValueError(\"The input is not a list.\")\n\n    if not words:\n        raise ValueError(\"The input list is empty.\")\n\n    return max(len(word) for word in words)"}
{"task_id": "Mbpp/91", "solution": "def find_substring(lst, substring):\n    \"\"\"\n    Check if a string is present as a substring in a given list of string values.\n\n    Args:\n        lst (list): A list of string values.\n        substring (str): The substring to search for.\n\n    Returns:\n        bool: True if the substring is found in any of the string values in the list, False otherwise.\n    \"\"\"\n    for item in lst:\n        if substring in item:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(num):\n    \"\"\"\n    Check whether the given number is undulating or not.\n\n    An undulating number is a number that has at least three digits and alternates between odd and even digits.\n\n    Args:\n        num (int): The number to be checked.\n\n    Returns:\n        bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string\n    num_str = str(num)\n\n    # Check if the number has at least three digits\n    if len(num_str) < 3:\n        return False\n\n    # Check if the number alternates between odd and even digits\n    for i in range(len(num_str) - 2):\n        if int(num_str[i]) % 2 == int(num_str[i+1]) % 2 == int(num_str[i+2]) % 2:\n            return False\n\n    return True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' raised to the power 'b'.\n\n    Parameters:\n    a (int or float): The base number.\n    b (int or float): The exponent.\n\n    Returns:\n    int or float: The result of raising 'a' to the power 'b'.\n\n    Raises:\n    ValueError: If 'b' is negative.\n\n    Examples:\n    >>> power(3, 4)\n    81\n    >>> power(2.5, 3)\n    15.625\n    >>> power(5, 0)\n    1\n    >>> power(0, 5)\n    0\n    >>> power(0, 0)\n    1\n    >>> power(-2, 3)\n    -8\n    >>> power(2, -3)\n    0.125\n    >>> power(-2, -3)\n    -0.125\n    \"\"\"\n    if b < 0:\n        raise ValueError(\"Exponent must be non-negative.\")\n    elif b == 0:\n        return 1\n    elif a == 0:\n        return 0\n    else:\n        result = 1\n        for _ in range(abs(b)):\n            result *= a\n        if b < 0:\n            return 1 / result\n        else:\n            return result"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        str: The first value of the tuple with the smallest second value.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n        'Varsha'\n        >>> index_minimum([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty.\")\n\n    min_value = min(lst, key=lambda x: x[1])\n    return min_value[0]"}
{"task_id": "Mbpp/95", "solution": "def find_min_length(lst):\n    \"\"\"\n    Find the length of the smallest list in a list of lists.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        int: The length of the smallest list.\n\n    Raises:\n        ValueError: If the input is not a list of lists.\n\n    Examples:\n        >>> find_min_length([[1], [1, 2]])\n        1\n        >>> find_min_length([[1, 2, 3], [4, 5], [6]])\n        1\n        >>> find_min_length([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n        2\n    \"\"\"\n    if not isinstance(lst, list) or not all(isinstance(sublst, list) for sublst in lst):\n        raise ValueError(\"Input must be a list of lists.\")\n\n    if not lst:\n        return 0\n\n    min_length = min(len(sublst) for sublst in lst)\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n\n    Parameters:\n    n (int): The integer for which the number of divisors needs to be found.\n\n    Returns:\n    int: The number of divisors of the given integer.\n\n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(24)\n    8\n    >>> divisor(1)\n    1\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(flattened_list):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        flattened_list (list): A flattened list of lists.\n\n    Returns:\n        dict: A dictionary containing the frequency of each element in the flattened list.\n\n    Examples:\n        >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n        {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    frequency_dict = {}\n    for sublist in flattened_list:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict"}
{"task_id": "Mbpp/98", "solution": "import math\ndef multiply_num(numbers):\n    \"\"\"\n    Multiply all the numbers in a list and divide with the length of the list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        float: The result of multiplying all the numbers in the list and dividing by the length of the list.\n\n    Raises:\n        ValueError: If the input is not a list or if the list is empty.\n\n    Examples:\n        >>> multiply_num([8, 2, 3, -1, 7])\n        -67.2\n        >>> multiply_num([])\n        Traceback (most recent call last):\n        ...\n        ValueError: The input list is empty.\n        >>> multiply_num(10)\n        Traceback (most recent call last):\n        ...\n        ValueError: The input must be a list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"The input must be a list.\")\n\n    if len(numbers) == 0:\n        raise ValueError(\"The input list is empty.\")\n\n    product = 1\n    for num in numbers:\n        product *= num\n\n    return product / len(numbers)"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(decimal):\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\n    Args:\n        decimal (int): The decimal number to be converted.\n\n    Returns:\n        str: The binary equivalent of the decimal number.\n\n    Raises:\n        ValueError: If the input is not a non-negative integer.\n\n    Examples:\n        >>> decimal_to_binary(8)\n        '1000'\n        >>> decimal_to_binary(10)\n        '1010'\n        >>> decimal_to_binary(0)\n        '0'\n    \"\"\"\n    if not isinstance(decimal, int) or decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if decimal == 0:\n        return '0'\n\n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal //= 2\n\n    return binary"}
{"task_id": "Mbpp/100", "solution": "def is_palindrome(n):\n    \"\"\"\n    Check if a number is a palindrome.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is a palindrome, False otherwise.\n    \"\"\"\n    return str(n) == str(n)[::-1]\ndef next_smallest_palindrome(n):\n    \"\"\"\n    Find the next smallest palindrome of a specified integer.\n\n    Parameters:\n    n (int): The integer to find the next smallest palindrome for.\n\n    Returns:\n    int: The next smallest palindrome of the specified integer.\n    \"\"\"\n    if is_palindrome(n):\n        return n\n\n    while True:\n        n += 1\n        if is_palindrome(n):\n            return n"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The index of the element to find.\n\n    Returns:\n    int: The kth element in the array.\n\n    Raises:\n    ValueError: If the input array is empty or if k is out of range.\n\n    Examples:\n    >>> kth_element([12, 3, 5, 7, 19], 2)\n    3\n    >>> kth_element([1, 2, 3, 4, 5], 5)\n    5\n    >>> kth_element([], 1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input array is empty.\n    >>> kth_element([1, 2, 3, 4, 5], 6)\n    Traceback (most recent call last):\n    ...\n    ValueError: k is out of range.\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input array is empty.\")\n\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k is out of range.\")\n\n    return sorted(arr)[k - 1]"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    \"\"\"\n    Convert a snake case string to camel case string.\n\n    Args:\n        snake_str (str): The snake case string to be converted.\n\n    Returns:\n        str: The camel case string.\n\n    Examples:\n        >>> snake_to_camel('python_program')\n        'PythonProgram'\n        >>> snake_to_camel('hello_world')\n        'HelloWorld'\n    \"\"\"\n    # Split the snake case string into words\n    words = snake_str.split('_')\n\n    # Capitalize the first letter of each word except the first word\n    camel_str = words[0] + ''.join(word.capitalize() for word in words[1:])\n\n    return camel_str"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculates the Eulerian number a(n, m) using the recursive formula:\n    a(n, m) = a(n-1, m) + m * a(n-1, m-1)\n\n    Parameters:\n    n (int): The number of vertices in the graph\n    m (int): The number of edges in the graph\n\n    Returns:\n    int: The Eulerian number a(n, m)\n\n    Raises:\n    ValueError: If either n or m is negative\n\n    \"\"\"\n\n    if n < 0 or m < 0:\n        raise ValueError(\"n and m must be non-negative\")\n\n    if n == 0:\n        return 1\n\n    if m == 0 or m > n:\n        return 0\n\n    return eulerian_num(n - 1, m) + m * eulerian_num(n - 1, m - 1)"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        lst (list): A list of lists, where each sublist contains strings.\n\n    Returns:\n        list: A new list with each sublist sorted in ascending order.\n\n    Examples:\n        >>> sort_sublists([[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]])\n        [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/105", "solution": "def count_true_booleans(lst):\n    \"\"\"\n    Counts the number of True values in a given list.\n\n    Args:\n        lst (list): A list of boolean values.\n\n    Returns:\n        int: The number of True values in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-boolean values.\n\n    Examples:\n        >>> count_true_booleans([True, False, True])\n        2\n        >>> count_true_booleans([False, False, False])\n        0\n        >>> count_true_booleans([True, True, True])\n        3\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    count = 0\n    for value in lst:\n        if not isinstance(value, bool):\n            raise ValueError(\"List must contain only boolean values.\")\n        if value:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuples.\n\n    Args:\n        lst (list): The list to be appended.\n        tpl (tuple): The tuple to which the list is to be appended.\n\n    Returns:\n        tuple: A new tuple with the list appended to the original tuple.\n\n    Raises:\n        TypeError: If the input arguments are not of the correct type.\n\n    Examples:\n        >>> add_lists([5, 6, 7], (9, 10))\n        (9, 10, 5, 6, 7)\n        >>> add_lists([], (1, 2, 3))\n        (1, 2, 3)\n        >>> add_lists([1, 2, 3], ())\n        (1, 2, 3)\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(tpl, tuple):\n        raise TypeError(\"The second argument must be a tuple.\")\n\n    return tpl + tuple(lst)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three sorted lists into a single sorted list.\n\n    Args:\n        list1 (list): The first sorted list.\n        list2 (list): The second sorted list.\n        list3 (list): The third sorted list.\n\n    Returns:\n        list: A new list containing all the elements from the input lists in sorted order.\n\n    Raises:\n        TypeError: If any of the input arguments is not a list.\n\n    Examples:\n        >>> merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])\n        [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n    \"\"\"\n\n    # Check if all input arguments are lists\n    if not all(isinstance(lst, list) for lst in [list1, list2, list3]):\n        raise TypeError(\"All input arguments must be lists.\")\n\n    # Merge the three lists into a single list\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list\n    merged_list.sort()\n\n    return merged_list"}
{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, num_rotations):\n    \"\"\"\n    Find the number of numbers with an odd value when rotating a binary string the given number of times.\n\n    Args:\n        binary_string (str): The binary string to be rotated.\n        num_rotations (int): The number of times the binary string should be rotated.\n\n    Returns:\n        int: The number of numbers with an odd value when rotating the binary string the given number of times.\n\n    Raises:\n        ValueError: If the binary string contains characters other than '0' and '1'.\n\n    Examples:\n        >>> odd_Equivalent(\"011001\", 6)\n        3\n        >>> odd_Equivalent(\"101010\", 3)\n        0\n    \"\"\"\n\n    # Check if the binary string contains only '0' and '1'\n    if not all(c in '01' for c in binary_string):\n        raise ValueError(\"Binary string should only contain '0' and '1'.\")\n\n    # Calculate the number of rotations required to get back to the original string\n    num_rotations %= len(binary_string)\n\n    # Count the number of odd values after rotating the binary string\n    count = 0\n    for i in range(len(binary_string)):\n        rotated_string = binary_string[i:] + binary_string[:i]\n        rotated_value = int(rotated_string, 2)\n        if rotated_value % 2 != 0:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n        nested_lists (list): A list of lists, where each inner list contains elements.\n\n    Returns:\n        list: A list of common elements found in all the inner lists.\n\n    Raises:\n        ValueError: If the input is not a list of lists.\n\n    Examples:\n        >>> common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])\n        [18, 12]\n    \"\"\"\n    if not isinstance(nested_lists, list) or not all(isinstance(lst, list) for lst in nested_lists):\n        raise ValueError(\"Input must be a list of lists.\")\n\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)"}
{"task_id": "Mbpp/113", "solution": "def check_integer(string):\n    \"\"\"\n    Check if a string represents an integer.\n\n    Args:\n        string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    \"\"\"\n    Convert a given tuple of positive integers into a single integer.\n\n    Args:\n        tup (tuple): A tuple of positive integers.\n\n    Returns:\n        int: The single integer formed by concatenating the elements of the tuple.\n\n    Raises:\n        ValueError: If the input is not a tuple or if any element in the tuple is not a positive integer.\n\n    Examples:\n        >>> tuple_to_int((1, 2, 3))\n        123\n        >>> tuple_to_int((4, 5, 6))\n        456\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    for num in tup:\n        if not isinstance(num, int) or num < 0:\n            raise ValueError(\"Tuple elements must be positive integers.\")\n\n    return int(''.join(map(str, tup)))"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    \"\"\"\n    Convert a string to a list of strings split on the space character.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        list: A list of strings split on the space character.\n\n    Examples:\n        >>> string_to_list(\"python programming\")\n        ['python', 'programming']\n        >>> string_to_list(\"Hello World\")\n        ['Hello', 'World']\n    \"\"\"\n    return string.split()"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    \"\"\"\n    Find the element that appears only once in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n\n    Returns:\n    int: The element that appears only once in the array.\n\n    Raises:\n    ValueError: If the input list is empty or does not contain exactly one element that appears only once.\n\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input list is empty.\")\n\n    if len(arr) == 1:\n        return arr[0]\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] == arr[mid - 1]:\n            if mid % 2 == 0:\n                right = mid - 2\n            else:\n                left = mid + 1\n        elif arr[mid] == arr[mid + 1]:\n            if mid % 2 == 0:\n                left = mid + 2\n            else:\n                right = mid - 1\n        else:\n            return arr[mid]\n\n    return arr[left]"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(lst):\n    \"\"\"\n    Finds the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        int: The maximum absolute product between numbers in pairs of tuples.\n\n    Raises:\n        ValueError: If the input list is empty or contains non-tuple elements.\n\n    Examples:\n        >>> max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)])\n        36\n        >>> max_product_tuple([(1, 2), (3, 4), (5, 6)])\n        30\n        >>> max_product_tuple([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n        >>> max_product_tuple([(1, 2), (3, 4), (5, 6), (7,)])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list must contain only tuples.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    if not all(isinstance(elem, tuple) for elem in lst):\n        raise ValueError(\"Input list must contain only tuples.\")\n\n    max_product = float('-inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            product = abs(lst[i][0] * lst[j][1] - lst[i][1] * lst[j][0])\n            max_product = max(max_product, product)\n\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculates the sum of all amicable numbers from 1 to a specified number.\n\n    Parameters:\n    n (int): The upper limit of the range to consider.\n\n    Returns:\n    int: The sum of all amicable numbers from 1 to n.\n\n    \"\"\"\n\n    def sum_of_divisors(num):\n        \"\"\"\n        Calculates the sum of proper divisors of a given number.\n\n        Parameters:\n        num (int): The number to calculate the sum of divisors for.\n\n        Returns:\n        int: The sum of proper divisors of the given number.\n\n        \"\"\"\n        divisors_sum = 0\n        for i in range(1, num):\n            if num % i == 0:\n                divisors_sum += i\n        return divisors_sum\n\n    amicable_numbers_sum = 0\n    for num in range(1, n+1):\n        sum_of_divisors_num = sum_of_divisors(num)\n        if sum_of_divisors_num <= n and sum_of_divisors(sum_of_divisors_num) == num and num != sum_of_divisors_num:\n            amicable_numbers_sum += num\n\n    return amicable_numbers_sum"}
{"task_id": "Mbpp/124", "solution": "import math\ndef angle_complex(z):\n    \"\"\"\n    Calculates the angle of a complex number.\n\n    Parameters:\n    z (complex): The complex number for which the angle needs to be calculated.\n\n    Returns:\n    float: The angle of the complex number in radians.\n\n    Raises:\n    ValueError: If the input is not a complex number.\n\n    \"\"\"\n    if not isinstance(z, complex):\n        raise ValueError(\"Input must be a complex number.\")\n\n    angle = math.atan2(z.imag, z.real)\n    return angle"}
{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):"}
{"task_id": "Mbpp/126", "solution": "def sum_common_divisors(a, b):\n    \"\"\"\n    Calculates the sum of common divisors of two given numbers.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The sum of common divisors of a and b.\n\n    \"\"\"\n    # Find the common divisors of a and b\n    common_divisors = set()\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.add(i)\n\n    # Calculate the sum of common divisors\n    return sum(common_divisors)\n\n# Test the function\nassert sum_common_divisors(10, 15) == 6"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Multiply two integers.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    int: The product of the two integers.\n\n    Raises:\n    TypeError: If either `a` or `b` is not an integer.\n\n    Examples:\n    >>> multiply_int(10, 20)\n    200\n    >>> multiply_int(5, 0)\n    0\n    >>> multiply_int(1.5, 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments must be integers.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both arguments must be integers.\")\n    return a * b"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n        n (int): The minimum length of words to be considered.\n        sentence (str): The input sentence.\n\n    Returns:\n        list: A list of words that are longer than n characters.\n\n    Examples:\n        >>> long_words(3, \"python is a programming language\")\n        ['python', 'programming', 'language']\n    \"\"\"\n    words = sentence.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if a given matrix is a magic square.\n\n    A magic square is a square matrix in which the sum of each row, column, and diagonal is the same.\n\n    Args:\n        matrix (list of lists): The matrix to be checked.\n\n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    # Get the size of the matrix\n    n = len(matrix)\n\n    # Calculate the sum of the first row\n    row_sum = sum(matrix[0])\n\n    # Check if each row has the same sum\n    for i in range(1, n):\n        if sum(matrix[i]) != row_sum:\n            return False\n\n    # Check if each column has the same sum\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != row_sum:\n            return False\n\n    # Check if the main diagonal has the same sum\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][i]\n    if diag_sum != row_sum:\n        return False\n\n    # Check if the secondary diagonal has the same sum\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][n - i - 1]\n    if diag_sum != row_sum:\n        return False\n\n    return True"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The item with maximum frequency.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])\n        2\n        >>> max_occurrences([])\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n\n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    # Find the item with maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    \"\"\"\n    Reverse only the vowels of a given string (where y is not a vowel).\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with vowels reversed.\n\n    Examples:\n        >>> reverse_vowels(\"Python\")\n        'Pothn'\n        >>> reverse_vowels(\"Hello World\")\n        'Hollo Werld'\n        >>> reverse_vowels(\"Python\")\n        'Python'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    s = list(s)\n    i, j = 0, len(s) - 1\n\n    while i < j:\n        if s[i] not in vowels:\n            i += 1\n        elif s[j] not in vowels:\n            j -= 1\n        else:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n\n    return ''.join(s)"}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    \"\"\"\n    Converts a tuple to a string.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        str: The string representation of the input tuple.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n\n    Examples:\n        >>> tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))\n        'exercises'\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The sum of the negative numbers in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list is empty.\n\n    Examples:\n        >>> sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])\n        -32\n        >>> sum_negativenum([])\n        ValueError: List is empty.\n        >>> sum_negativenum(10)\n        TypeError: Input must be a list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if not numbers:\n        raise ValueError(\"List is empty.\")\n\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Calculates the nth hexagonal number.\n\n    Parameters:\n    n (int): The position of the hexagonal number to be calculated.\n\n    Returns:\n    int: The nth hexagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes in the array.\n\n    Raises:\n    ValueError: If the input is not a list or if any element in the list is not an integer.\n\n    Examples:\n    >>> zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])\n    0.181818\n    >>> zero_count([0, 0, 0, 0, 0])\n    1.0\n    >>> zero_count([1, 2, 3, 4, 5])\n    0.0\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list\")\n\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError(\"All elements in the list must be integers\")\n\n    zero_count = sum(1 for x in arr if x == 0)\n    non_zero_count = len(arr) - zero_count\n    ratio = zero_count / non_zero_count\n\n    return ratio"}
{"task_id": "Mbpp/138", "solution": "def is_sum_of_powers_of_two(n):\n    \"\"\"\n    Check whether the given number can be represented as the sum of non-zero powers of 2.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as the sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Base case: if n is 0, it can be represented as the sum of non-zero powers of 2\n    if n == 0:\n        return True\n\n    # If n is negative, it cannot be represented as the sum of non-zero powers of 2\n    if n < 0:\n        return False\n\n    # Iterate through all possible powers of 2 from 1 to n/2\n    for i in range(1, n):\n        # Check if the current power of 2 is less than or equal to n\n        if 2**i <= n:\n            # Check if the remaining part of n can be represented as the sum of non-zero powers of 2\n            if is_sum_of_powers_of_two(n - 2**i):\n                return True\n        else:\n            # If the current power of 2 is greater than n, we can stop the iteration\n            break\n\n    # If no combination of non-zero powers of 2 can represent n, return False\n    return False\n\n# Test cases\nassert is_sum_of_powers_of_two(10) == True\nassert is_sum_of_powers_of_two(15) == True\nassert is_sum_of_powers_of_two(20) == True\nassert is_sum_of_powers_of_two(25) == True\nassert is_sum_of_powers_of_two(30) == True\nassert is_sum_of_powers_of_two(31) == False\nassert is_sum_of_powers_of_two(32) == True\nassert is_sum_of_powers_of_two(33) == False\nassert is_sum_of_powers_of_two(34) == False\nassert is_sum_of_powers_of_two(35) == False\nassert is_sum_of_powers_of_two(36) == True\nassert is_sum_of_powers_of_two(37) == False\nassert is_sum_of_powers_of_two(38) == False\nassert is_sum_of_powers_of_two(39) == False\nassert is_sum_of_powers_of_two(40) == True\nassert is_sum_of_powers_of_two(41) == False\nassert is_sum_of_powers_of_two(42) == False\nassert is_sum_of_powers_of_two(43) == False\nassert is_sum_of_powers_of_two(44) == False\nassert is_sum_of_powers_of_two(45) == False\nassert is_sum_of_powers_of_two(46) == False"}
{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    \"\"\"\n    Calculates the circumference of a circle.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    float: The circumference of the circle.\n\n    Raises:\n    ValueError: If the radius is negative.\n\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(lst):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        set: A set of numbers extracted from the input list.\n\n    Examples:\n        >>> extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])\n        {1, 3, 4, 5, 7}\n    \"\"\"\n    return set(num for sublist in lst for num in sublist)"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Parameters:\n    lst (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list of elements.\n\n    \"\"\"\n\n    def flip(lst, end):\n        \"\"\"\n        Flips the elements in the list from the start to the end index.\n\n        Parameters:\n        lst (list): The list of elements.\n        end (int): The index up to which the elements should be flipped.\n\n        Returns:\n        list: The flipped list of elements.\n\n        \"\"\"\n        start = 0\n        while start < end:\n            lst[start], lst[end] = lst[end], lst[start]\n            start += 1\n            end -= 1\n        return lst\n\n    def find_max_index(lst, end):\n        \"\"\"\n        Finds the index of the maximum element in the list up to the end index.\n\n        Parameters:\n        lst (list): The list of elements.\n        end (int): The index up to which the maximum element should be found.\n\n        Returns:\n        int: The index of the maximum element.\n\n        \"\"\"\n        max_index = 0\n        for i in range(1, end + 1):\n            if lst[i] > lst[max_index]:\n                max_index = i\n        return max_index\n\n    n = len(lst)\n    current_size = n\n\n    while current_size > 1:\n        max_index = find_max_index(lst, current_size - 1)\n\n        if max_index != current_size - 1:\n            lst = flip(lst, max_index)\n            lst = flip(lst, current_size - 1)\n\n        current_size -= 1\n\n    return lst"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the number of items that are identical in the same position of three given lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        int: The number of items that are identical in the same position of the three lists.\n\n    Raises:\n        ValueError: If the lengths of the input lists are not equal.\n\n    Examples:\n        >>> count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])\n        3\n        >>> count_samepair([1,2,3],[4,5,6],[7,8,9])\n        0\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must have equal lengths.\")\n\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): A tuple of integers.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n\n    Raises:\n    ValueError: If the input is not a tuple or if the tuple is empty.\n\n    Examples:\n    >>> max_Abs_Diff((2, 1, 5, 3))\n    4\n    >>> max_Abs_Diff((-2, -1, -5, -3))\n    4\n    >>> max_Abs_Diff((1, 1, 1, 1))\n    0\n    >>> max_Abs_Diff(())\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be a non-empty tuple.\n    \"\"\"\n\n    if not isinstance(arr, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    if len(arr) == 0:\n        raise ValueError(\"Input must be a non-empty tuple.\")\n\n    min_val = max_val = arr[0]\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return max_val - min_val"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    \"\"\"\n    Finds integers x and y that satisfy the equation ax + by = n.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    n (int): The target value.\n\n    Returns:\n    tuple: A tuple containing x and y, or None if no solution exists.\n\n    \"\"\"\n    # Check if n is divisible by gcd(a, b)\n    if n % gcd(a, b) != 0:\n        return None\n\n    # Find the greatest common divisor (gcd) of a and b\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Find the Bezout's coefficients x and y\n    def bezout(a, b):\n        if b == 0:\n            return 1, 0\n        else:\n            x, y = bezout(b, a % b)\n            return y, x - (a // b) * y\n\n    # Calculate x and y\n    x, y = bezout(a, b)\n    x *= n // gcd(a, b)\n    y *= n // gcd(a, b)\n\n    return x, y"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(lst, elements_to_remove):\n    \"\"\"\n    Remove all elements from a given list present in another list.\n\n    Args:\n        lst (list): The list from which elements need to be removed.\n        elements_to_remove (list): The list of elements to be removed from the original list.\n\n    Returns:\n        list: The updated list with the specified elements removed.\n\n    Examples:\n        >>> remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8])\n        [1, 3, 5, 7, 9, 10]\n    \"\"\"\n    return [x for x in lst if x not in elements_to_remove]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    \"\"\"\n    Calculates the sum of the series (n - 2*i) from i=0 to n // 2.\n\n    Parameters:\n    n (int): The number up to which the series is calculated.\n\n    Returns:\n    int: The sum of the series.\n\n    Raises:\n    ValueError: If n is negative.\n\n    Examples:\n    >>> sum_series(6)\n    12\n    >>> sum_series(10)\n    20\n    >>> sum_series(0)\n    0\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    # Calculate the sum of the series\n    sum_of_series = 0\n    for i in range(n // 2 + 1):\n        sum_of_series += n - 2 * i\n\n    return sum_of_series"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    \"\"\"\n    Count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The number of characters that occur at the same position in the string as in the English alphabet.\n\n    Examples:\n        >>> count_char_position(\"xbcefg\")\n        2\n        >>> count_char_position(\"abcdefg\")\n        7\n        >>> count_char_position(\"\")\n        0\n    \"\"\"\n    # Convert the string to lowercase for case insensitivity\n    string = string.lower()\n\n    # Initialize a counter for the number of characters that occur at the same position\n    count = 0\n\n    # Iterate over the characters in the string\n    for i, char in enumerate(string):\n        # Check if the character is in the English alphabet\n        if char.isalpha():\n            # Check if the character is at the same position as its alphabetical index\n            if char == chr(ord('a') + i):\n                count += 1\n\n    return count"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The number of pairs of integers that xor to an even number.\n\n    Examples:\n        >>> find_even_pair([5, 4, 7, 2, 1])\n        4\n        >>> find_even_pair([1, 2, 3, 4, 5])\n        0\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The smallest power of 2 greater than or equal to n.\n\n    Raises:\n    ValueError: If n is negative.\n\n    Examples:\n    >>> next_power_of_2(0)\n    1\n    >>> next_power_of_2(1)\n    1\n    >>> next_power_of_2(2)\n    2\n    >>> next_power_of_2(3)\n    4\n    >>> next_power_of_2(4)\n    4\n    >>> next_power_of_2(5)\n    8\n    >>> next_power_of_2(6)\n    8\n    >>> next_power_of_2(7)\n    8\n    >>> next_power_of_2(8)\n    8\n    >>> next_power_of_2(9)\n    16\n    >>> next_power_of_2(10)\n    16\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    if n == 0:\n        return 1\n\n    # Find the highest set bit in n\n    highest_bit = n.bit_length() - 1\n\n    # Set all bits below the highest set bit to 1\n    mask = (1 << highest_bit) - 1\n\n    # Set the highest bit to 1\n    return 1 << highest_bit"}
{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n\n    Args:\n        lst (list): The list to search for occurrences.\n        num: The number to count occurrences of.\n\n    Returns:\n        int: The number of occurrences of the given number in the list.\n\n    Examples:\n        >>> frequency([1, 2, 3, 4, 4, 4], 4)\n        3\n        >>> frequency([1, 2, 3], 4)\n        0\n    \"\"\"\n    return lst.count(num)"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        lst (list): The list of numbers.\n        start (int): The starting index of the range (inclusive).\n        end (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of numbers in the specified range.\n\n    Raises:\n        ValueError: If the start index is greater than the end index.\n        IndexError: If the start or end index is out of range.\n\n    Examples:\n        >>> sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10)\n        29\n        >>> sum_range_list([1, 2, 3, 4, 5], 0, 4)\n        15\n        >>> sum_range_list([1, 2, 3, 4, 5], 1, 3)\n        9\n    \"\"\"\n    if start > end:\n        raise ValueError(\"Start index cannot be greater than end index.\")\n\n    if start < 0 or end >= len(lst):\n        raise IndexError(\"Start or end index is out of range.\")\n\n    return sum(lst[start:end+1])"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculates the perimeter of a regular pentagon given the length of its sides.\n\n    Parameters:\n    side_length (float or int): The length of the sides of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> perimeter_pentagon(5)\n    25\n    >>> perimeter_pentagon(10)\n    50\n    >>> perimeter_pentagon(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return 5 * side_length"}
{"task_id": "Mbpp/172", "solution": "def count_occurrence(string):\n    \"\"\"\n    Count the number of occurrences of the string 'std' in a given string.\n\n    Args:\n        string (str): The input string to search for occurrences of 'std'.\n\n    Returns:\n        int: The number of occurrences of 'std' in the input string.\n\n    Examples:\n        >>> count_occurrence(\"letstdlenstdporstd\")\n        3\n        >>> count_occurrence(\"abcdefg\")\n        0\n        >>> count_occurrence(\"stdstdstd\")\n        3\n    \"\"\"\n    count = 0\n    index = 0\n    while index < len(string):\n        if string[index:index+3] == \"std\":\n            count += 1\n            index += 3\n        else:\n            index += 1\n    return count\n\n# Testing the function\nassert count_occurrence(\"letstdlenstdporstd\") == 3\nassert count_occurrence(\"abcdefg\") == 0\nassert count_occurrence(\"stdstdstd\") == 3"}
{"task_id": "Mbpp/222", "solution": "def check_type(tup):\n    \"\"\"\n    Check if all elements in a tuple have the same data type.\n\n    Args:\n        tup (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if all elements in the tuple have the same data type, False otherwise.\n    \"\"\"\n    # Check if the tuple is empty\n    if len(tup) == 0:\n        return False\n\n    # Get the data type of the first element\n    data_type = type(tup[0])\n\n    # Check if all elements in the tuple have the same data type\n    for element in tup:\n        if type(element) != data_type:\n            return False\n\n    return True"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    \"\"\"\n    Check if an element is the majority element in a sorted array.\n\n    Parameters:\n    arr (list): A sorted array.\n    n (int): The length of the array.\n    element: The element to check for majority.\n\n    Returns:\n    bool: True if the element is the majority element, False otherwise.\n    \"\"\"\n\n    # Find the first occurrence of the element\n    first_occurrence = find_first_occurrence(arr, n, element)\n\n    # If the element is not present in the array, it cannot be the majority element\n    if first_occurrence == -1:\n        return False\n\n    # Check if the element occurs more than n/2 times\n    if (first_occurrence + n // 2) < n and arr[first_occurrence + n // 2] == element:\n        return True\n\n    return False\ndef find_first_occurrence(arr, n, element):\n    \"\"\"\n    Find the first occurrence of an element in a sorted array.\n\n    Parameters:\n    arr (list): A sorted array.\n    n (int): The length of the array.\n    element: The element to find.\n\n    Returns:\n    int: The index of the first occurrence of the element, or -1 if not found.\n    \"\"\"\n\n    low = 0\n    high = n - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == element:\n            if mid == 0 or arr[mid - 1] < element:\n                return mid\n            else:\n                high = mid - 1\n        elif arr[mid] < element:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1"}
{"task_id": "Mbpp/224", "solution": "def count_set_bits(num):\n    \"\"\"\n    Count the number of set bits (binary digits with value 1) in a given number.\n\n    Args:\n        num (int): The number to count the set bits in.\n\n    Returns:\n        int: The number of set bits in the given number.\n\n    Examples:\n        >>> count_set_bits(2)\n        1\n        >>> count_set_bits(7)\n        3\n        >>> count_set_bits(0)\n        0\n    \"\"\"\n    count = 0\n    while num:\n        num &= num - 1\n        count += 1\n    return count\n\n\n# Testing the function\nassert count_set_bits(2) == 1\nassert count_set_bits(7) == 3\nassert count_set_bits(0) == 0"}
{"task_id": "Mbpp/226", "solution": "def remove_odd_index_chars(string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with characters with odd index values removed.\n\n    Examples:\n        >>> remove_odd_index_chars('abcdef')\n        'ace'\n        >>> remove_odd_index_chars('python')\n        'pto'\n        >>> remove_odd_index_chars('123456')\n        '135'\n    \"\"\"\n    return string[::2]\n\n# Testing the function\nassert remove_odd_index_chars('abcdef') == 'ace'\nassert remove_odd_index_chars('python') == 'pto'\nassert remove_odd_index_chars('123456') == '135'"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Finds the minimum of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n\n    Raises:\n    ValueError: If any of the input parameters is not a number.\n\n    Examples:\n    >>> min_of_three(10, 20, 0)\n    0\n    >>> min_of_three(10, 20, 15)\n    10\n    >>> min_of_three(10, 10, 10)\n    10\n    \"\"\"\n\n    # Check if any of the input parameters is not a number\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)) or not isinstance(c, (int, float)):\n        raise ValueError(\"Input parameters must be numbers.\")\n\n    # Find the minimum of the three numbers\n    return min(a, b, c)"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in a given string with a specified character.\n\n    Args:\n        string (str): The input string.\n        character (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by the specified character.\n\n    Examples:\n        >>> replace_blank(\"hello people\", '@')\n        'hello@people'\n        >>> replace_blank(\"Python is awesome\", '*')\n        'Python*is*awesome'\n    \"\"\"\n    return string.replace(\" \", character)"}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    \"\"\"\n    Returns a list containing the n largest items from the given list.\n\n    Parameters:\n    lst (list): The input list.\n    n (int): The number of largest items to be returned.\n\n    Returns:\n    list: A list containing the n largest items from the input list.\n\n    Raises:\n    ValueError: If n is greater than the length of the input list.\n\n    Examples:\n    >>> larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2)\n    [100, 90]\n    >>> larg_nnum([1, 2, 3, 4, 5], 3)\n    [5, 4, 3]\n    >>> larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 10)\n    [100, 90, 80, 70, 60, 50, 50, 40, 20, 20]\n    \"\"\"\n\n    if n > len(lst):\n        raise ValueError(\"n cannot be greater than the length of the input list.\")\n\n    # Sort the list in descending order\n    sorted_lst = sorted(lst, reverse=True)\n\n    # Return the first n items from the sorted list\n    return sorted_lst[:n]"}
{"task_id": "Mbpp/233", "solution": "import math"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculates the volume of a cube given its side length.\n\n    Parameters:\n    side_length (float or int): The length of one side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> volume_cube(3)\n    27\n    >>> volume_cube(0)\n    0\n    >>> volume_cube(-5)\n    Traceback (most recent call last):\n    ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length must be a positive number.\")\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(num):\n    \"\"\"\n    Set all even bits of a given number.\n\n    Parameters:\n    num (int): The number to set even bits for.\n\n    Returns:\n    int: The number with all even bits set.\n\n    Examples:\n    >>> even_bit_set_number(10)\n    10\n    >>> even_bit_set_number(15)\n    14\n    >>> even_bit_set_number(20)\n    20\n    \"\"\"\n\n    # Convert the number to binary representation\n    binary_num = bin(num)[2:]\n\n    # Set even bits to 1\n    binary_num = binary_num[:-1] + '1' + binary_num[-1]\n\n    # Convert the binary representation back to decimal\n    return int(binary_num, 2)"}
{"task_id": "Mbpp/237", "solution": "def check_occurences(lst):\n    \"\"\"\n    Function to count the occurrences of each unique tuple in a list.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        dict: A dictionary mapping each unique tuple to the number of times it occurs in the list.\n\n    Examples:\n        >>> check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)])\n        {(1, 3): 2, (2, 5): 2, (6, 3): 1}\n    \"\"\"\n    # Create an empty dictionary to store the occurrences\n    occurrences = {}\n\n    # Iterate over each tuple in the list\n    for tup in lst:\n        # Check if the tuple is already in the dictionary\n        if tup in occurrences:\n            # If it is, increment its count by 1\n            occurrences[tup] += 1\n        else:\n            # If it is not, add it to the dictionary with a count of 1\n            occurrences[tup] = 1\n\n    return occurrences"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(string):\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The number of non-empty substrings.\n\n    Examples:\n    >>> number_of_substrings(\"abc\")\n    6\n    >>> number_of_substrings(\"abcd\")\n    10\n    >>> number_of_substrings(\"\")\n    0\n    \"\"\"\n\n    # Calculate the length of the string\n    length = len(string)\n\n    # If the string is empty, return 0\n    if length == 0:\n        return 0\n\n    # Calculate the number of substrings using the formula: n * (n + 1) / 2\n    num_substrings = length * (length + 1) // 2\n\n    return num_substrings"}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Parameters:\n    m (int): The maximum value of each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The number of possible sequences.\n\n    \"\"\"\n\n    # Create a 2D table to store the number of sequences\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Base case: There is only one sequence of length 1\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Fill the table using dynamic programming\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # Calculate the total number of sequences\n    total_sequences = sum(dp[n])\n\n    return total_sequences"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: The modified list.\n\n    Raises:\n        ValueError: If either list1 or list2 is empty.\n\n    Examples:\n        >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n        [1, 3, 5, 7, 9, 2, 4, 6, 8]\n        >>> replace_list([], [2, 4, 6, 8])\n        Traceback (most recent call last):\n        ...\n        ValueError: List1 cannot be empty.\n        >>> replace_list([1, 3, 5, 7, 9, 10], [])\n        Traceback (most recent call last):\n        ...\n        ValueError: List2 cannot be empty.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"List1 cannot be empty.\")\n    if not list2:\n        raise ValueError(\"List2 cannot be empty.\")\n\n    list1[-1] = list2\n    return list1"}
{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    \"\"\"\n    Count the total number of characters in a string.\n\n    Parameters:\n    string (str): The input string.\n\n    Returns:\n    int: The total number of characters in the string.\n\n    Examples:\n    >>> count_charac(\"python programming\")\n    18\n    >>> count_charac(\"\")\n    0\n    >>> count_charac(\"a\")\n    1\n    \"\"\"\n    return len(string)"}
{"task_id": "Mbpp/244", "solution": "def next_perfect_square(num):\n    \"\"\"\n    Find the next perfect square greater than a given number.\n\n    Args:\n        num (int): The number to find the next perfect square for.\n\n    Returns:\n        int: The next perfect square greater than the given number.\n\n    Raises:\n        ValueError: If the given number is negative.\n\n    Examples:\n        >>> next_perfect_square(35)\n        36\n        >>> next_perfect_square(100)\n        121\n        >>> next_perfect_square(0)\n        1\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"The given number must be non-negative.\")\n\n    # Find the square root of the given number\n    sqrt = int(num ** 0.5)\n\n    # If the square root is a perfect square, increment it by 1\n    if sqrt * sqrt == num:\n        sqrt += 1\n\n    # Return the next perfect square\n    return sqrt * sqrt"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    \"\"\"\n    Finds the maximum sum of a bitonic subsequence in the given array.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int: The maximum sum of a bitonic subsequence.\n\n    Raises:\n        ValueError: If the input array is empty.\n\n    Examples:\n        >>> max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9])\n        194\n        >>> max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9])\n        36\n        >>> max_sum([9, 8, 7, 6, 5, 4, 3, 2, 1])\n        36\n        >>> max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        55\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n\n    # Calculate the increasing subsequence sum\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n\n    # Calculate the decreasing subsequence sum\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n\n    # Find the maximum sum of a bitonic subsequence\n    max_sum = max(inc[i] + dec[i] - arr[i] for i in range(n))\n\n    return max_sum"}
{"task_id": "Mbpp/247", "solution": "def lps(s):\n    \"\"\"\n    Find the length of the longest palindromic subsequence in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The length of the longest palindromic subsequence.\n\n    Examples:\n    >>> lps(\"TENS FOR TENS\")\n    5\n    >>> lps(\"ABCDEF\")\n    1\n    >>> lps(\"ABBCDAB\")\n    5\n    \"\"\"\n\n    # Create a 2D table to store the lengths of palindromic subsequences\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    # All substrings of length 1 are palindromes of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build the table diagonally\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\n    return dp[0][n-1]"}
{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    \"\"\"\n    Count the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        element: The element to count in the tuple.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n\n    Examples:\n        >>> count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 4)\n        0\n        >>> count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 8)\n        4\n    \"\"\"\n    return tup.count(element)"}
{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n\n    Args:\n        lst (list): The input list.\n        element: The element to be inserted before each element in the list.\n\n    Returns:\n        list: The resulting list with the element inserted before each element.\n\n    Examples:\n        >>> insert_element(['Red', 'Green', 'Black'], 'c')\n        ['c', 'Red', 'c', 'Green', 'c', 'Black']\n        >>> insert_element([1, 2, 3], 0)\n        [0, 1, 0, 2, 0, 3]\n    \"\"\"\n    return [element] + [element] * len(lst) + lst"}
{"task_id": "Mbpp/252", "solution": "import math\ndef convert(complex_number):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Parameters:\n    complex_number (complex): The complex number to be converted.\n\n    Returns:\n    tuple: A tuple containing the magnitude and phase of the complex number.\n\n    Raises:\n    TypeError: If the input is not a complex number.\n\n    Examples:\n    >>> convert(1)\n    (1.0, 0.0)\n    >>> convert(2+3j)\n    (3.605551275463989, 1.1071487177940904)\n    >>> convert(0)\n    (0.0, 0.0)\n    \"\"\"\n    if not isinstance(complex_number, complex):\n        raise TypeError(\"Input must be a complex number.\")\n\n    magnitude = abs(complex_number)\n    phase = math.atan2(complex_number.imag, complex_number.real)\n\n    return magnitude, phase"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    \"\"\"\n    Counts the number of integer elements in a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The number of integer elements in the list.\n\n    Examples:\n        >>> count_integer([1, 2, 'abc', 1.2])\n        2\n        >>> count_integer([])\n        0\n        >>> count_integer([1, 2, 3])\n        3\n    \"\"\"\n    count = 0\n    for element in lst:\n        if isinstance(element, int):\n            count += 1\n    return count"}
{"task_id": "Mbpp/255", "solution": "def combinations_colors(lst, n):\n    \"\"\"\n    Generates all combinations (with repetition) of the elements of a list and returns a list with a tuple for each combination.\n\n    Args:\n        lst (list): The input list.\n        n (int): The length of each combination.\n\n    Returns:\n        list: A list of tuples representing all combinations of length n.\n\n    Raises:\n        ValueError: If n is greater than the length of the input list.\n\n    Examples:\n        >>> combinations_colors([\"Red\", \"Green\", \"Blue\"], 1)\n        [('Red',), ('Green',), ('Blue',)]\n        >>> combinations_colors([\"Red\", \"Green\", \"Blue\"], 2)\n        [('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Red'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Red'), ('Blue', 'Green'), ('Blue', 'Blue')]\n    \"\"\"\n    if n > len(lst):\n        raise ValueError(\"n cannot be greater than the length of the input list.\")\n\n    if n == 0:\n        return [()]\n\n    result = []\n    for i in range(len(lst)):\n        sub_combinations = combinations_colors(lst, n - 1)\n        for combination in sub_combinations:\n            result.append(combination + (lst[i],))\n\n    return result"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Parameters:\n    n (int): The non-negative number to count prime numbers up to.\n\n    Returns:\n    int: The number of prime numbers less than the given non-negative number.\n\n    Raises:\n    ValueError: If the input number is negative.\n\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"Input number must be non-negative.\")\n\n    primes = [2]  # Start with the first prime number\n    num = 3  # Start checking from the next number\n\n    while num < n:\n        is_prime = True\n        for prime in primes:\n            if num % prime == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n        num += 1\n\n    return len(primes)"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    \"\"\"\n    Swaps the order of two numbers and returns a tuple with the second number first and the first number second.\n\n    Args:\n        a (int or float): The first number.\n        b (int or float): The second number.\n\n    Returns:\n        tuple: A tuple containing the second number first and the first number second.\n\n    Examples:\n        >>> swap_numbers(10, 20)\n        (20, 10)\n        >>> swap_numbers(5.5, 10.5)\n        (10.5, 5.5)\n    \"\"\"\n    return b, a"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuples1, tuples2):\n    \"\"\"\n    Maximize the given two tuples.\n\n    Args:\n        tuples1 (tuple): The first tuple of tuples.\n        tuples2 (tuple): The second tuple of tuples.\n\n    Returns:\n        tuple: A new tuple of tuples where each element is the maximum of the corresponding elements in tuples1 and tuples2.\n\n    Raises:\n        ValueError: If the lengths of tuples1 and tuples2 are not equal.\n\n    Examples:\n        >>> maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3)))\n        ((6, 7), (4, 9), (2, 9), (7, 10))\n    \"\"\"\n    if len(tuples1) != len(tuples2):\n        raise ValueError(\"The lengths of tuples1 and tuples2 must be equal.\")\n\n    return tuple(max(x) for x in zip(tuples1, tuples2))"}
{"task_id": "Mbpp/260", "solution": "def newman_prime(n):\n    \"\"\"\n    Find the nth newman\u2013shanks\u2013williams prime number.\n\n    Parameters:\n    n (int): The index of the prime number to be found.\n\n    Returns:\n    int: The nth newman\u2013shanks\u2013williams prime number.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1.\")\n\n    primes = [2, 3, 5]  # First three newman\u2013shanks\u2013williams primes\n    if n <= 3:\n        return primes[n - 1]\n\n    # Generate newman\u2013shanks\u2013williams primes until we reach the nth prime\n    while len(primes) < n:\n        next_prime = primes[-1] + 2\n        is_prime = True\n\n        # Check if the next_prime is divisible by any of the previous primes\n        for prime in primes:\n            if next_prime % prime == 0:\n                is_prime = False\n                break\n\n        if is_prime:\n            primes.append(next_prime)\n\n    return primes[n - 1]"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Perform element-wise division operation on two tuples.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple containing the result of element-wise division.\n\n    Raises:\n        ValueError: If the length of the input tuples are not equal.\n\n    Examples:\n        >>> division_elements((10, 4, 6, 9), (5, 2, 3, 3))\n        (2, 2, 2, 3)\n        >>> division_elements((1, 2, 3), (1, 2, 3, 4))\n        Traceback (most recent call last):\n        ...\n        ValueError: The length of the input tuples must be equal.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"The length of the input tuples must be equal.\")\n\n    result = tuple(a / b for a, b in zip(tuple1, tuple2))\n    return result"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits a given list into two parts where the length of the first part is L.\n\n    Args:\n        lst (list): The input list to be split.\n        L (int): The length of the first part of the list.\n\n    Returns:\n        tuple: A tuple containing the two resulting lists.\n\n    Raises:\n        ValueError: If L is greater than the length of the input list.\n\n    Examples:\n        >>> split_two_parts([1, 2, 3, 4, 5], 2)\n        ([1, 2], [3, 4, 5])\n\n        >>> split_two_parts([1, 2, 3, 4, 5], 5)\n        ([1, 2, 3, 4, 5], [])\n\n        >>> split_two_parts([1, 2, 3, 4, 5], 6)\n        Traceback (most recent call last):\n        ...\n        ValueError: L cannot be greater than the length of the input list.\n    \"\"\"\n    if L > len(lst):\n        raise ValueError(\"L cannot be greater than the length of the input list.\")\n\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/264", "solution": "def dog_age(human_age):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    Parameters:\n    human_age (int): The age of the dog in human years.\n\n    Returns:\n    int: The age of the dog in dog years.\n\n    Raises:\n    ValueError: If the input is not a positive integer.\n\n    \"\"\"\n\n    if not isinstance(human_age, int) or human_age <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of elements to skip between sublists.\n\n    Returns:\n        list: A list of sublists, where each sublist contains every nth element from the original list.\n\n    Raises:\n        ValueError: If the input list is empty or n is less than or equal to 0.\n\n    Examples:\n        >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3)\n        [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0.\")\n\n    sublists = []\n    for i in range(0, len(lst), n):\n        sublists.append(lst[i:i+n])\n\n    return sublists"}
{"task_id": "Mbpp/266", "solution": "def lateral_surface_cube(side_length):\n    \"\"\"\n    Calculates the lateral surface area of a cube given its side length.\n\n    Parameters:\n    side_length (float or int): The length of one side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> lateral_surface_cube(5)\n    100\n    >>> lateral_surface_cube(0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    return 4 * side_length ** 2"}
{"task_id": "Mbpp/267", "solution": "def square_sum(n):\n    \"\"\"\n    Calculates the sum of the squares of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> square_sum(2)\n    10\n    >>> square_sum(3)\n    35\n    >>> square_sum(4)\n    91\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    odd_numbers = [2 * i + 1 for i in range(n)]\n    return sum(num ** 2 for num in odd_numbers)"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Find the n'th star number.\n\n    A star number is a number that can be represented as the sum of n consecutive positive integers.\n\n    Args:\n        n (int): The number of consecutive positive integers to sum.\n\n    Returns:\n        int: The n'th star number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Examples:\n        >>> find_star_num(3)\n        37\n        >>> find_star_num(5)\n        125\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return sum(range(1, n + 1)) + n"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    Returns the ASCII value of a character.\n\n    Parameters:\n    char (str): The character to find the ASCII value of.\n\n    Returns:\n    int: The ASCII value of the character.\n\n    Raises:\n    ValueError: If the input is not a single character.\n\n    Examples:\n    >>> ascii_value('A')\n    65\n    >>> ascii_value('a')\n    97\n    >>> ascii_value('1')\n    49\n    >>> ascii_value('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a single character.\n    >>> ascii_value('abc')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a single character.\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError(\"Input must be a single character.\")\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    \"\"\"\n    Calculates the sum of even numbers at even positions in a list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even numbers at even positions in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If any element in the list is not an integer.\n\n    Examples:\n        >>> sum_even_and_even_index([5, 6, 12, 1, 18, 8])\n        30\n        >>> sum_even_and_even_index([1, 2, 3, 4, 5])\n        6\n        >>> sum_even_and_even_index([1, 3, 5, 7, 9])\n        0\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    for i, num in enumerate(lst):\n        if not isinstance(num, int):\n            raise ValueError(\"List must contain only integers.\")\n\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 0)"}
{"task_id": "Mbpp/271", "solution": "def even_power_sum(n):\n    \"\"\"\n    Calculates the sum of the first n even natural numbers raised to the fifth power.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of the first n even natural numbers raised to the fifth power.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> even_power_sum(2)\n    1056\n    >>> even_power_sum(3)\n    25136\n    >>> even_power_sum(0)\n    0\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return sum(num ** 5 for num in range(2, 2 * n + 1, 2))"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(lst):\n    \"\"\"\n    Extracts the rear element from each tuple in a list of tuples.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        list: A list containing the rear element of each tuple.\n\n    Raises:\n        ValueError: If the input is not a list of tuples.\n\n    Examples:\n        >>> rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)])\n        [21, 20, 19]\n    \"\"\"\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list.\")\n\n    if not all(isinstance(item, tuple) for item in lst):\n        raise ValueError(\"Input must be a list of tuples.\")\n\n    return [item[-1] for item in lst]"}
{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1, tuple2):\n    \"\"\"\n    Subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the result of subtracting the elements of tuple1 by tuple2.\n\n    Raises:\n        ValueError: If the lengths of the input tuples are not equal.\n\n    Examples:\n        >>> subtract_elements((10, 4, 5), (2, 5, 18))\n        (8, -1, -13)\n        >>> subtract_elements((1, 2, 3), (4, 5, 6))\n        (-3, -3, -3)\n        >>> subtract_elements((1, 2, 3), (4, 5))\n        Traceback (most recent call last):\n        ...\n        ValueError: The lengths of the input tuples are not equal.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"The lengths of the input tuples are not equal.\")\n\n    return tuple(a - b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculates the sum of even index binomial coefficients up to the given positive integer n.\n\n    Parameters:\n    n (int): A positive integer.\n\n    Returns:\n    int: The sum of even index binomial coefficients.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Initialize the sum to 0\n    sum_of_even_coeffs = 0\n\n    # Iterate through the even indices from 0 to n\n    for k in range(0, n+1, 2):\n        # Calculate the binomial coefficient using the formula (n k) = n!/((n-k)!k!)\n        binomial_coeff = factorial(n) // (factorial(n-k) * factorial(k))\n        sum_of_even_coeffs += binomial_coeff\n\n    return sum_of_even_coeffs\ndef factorial(n):\n    \"\"\"\n    Calculates the factorial of a non-negative integer.\n\n    Parameters:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The factorial of n.\n\n    Raises:\n    ValueError: If n is a negative integer.\n\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    if n == 0 or n == 1:\n        return 1\n\n    return n * factorial(n-1)"}
{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculates the volume of a cylinder given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n\n    Raises:\n    ValueError: If either the radius or height is negative.\n\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be positive.\")\n\n    volume = math.pi * radius**2 * height\n    return volume"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    \"\"\"\n    Filters a dictionary to only include entries with values greater than or equal to n.\n\n    Args:\n        dictionary (dict): The input dictionary.\n        n (int): The minimum value to filter the dictionary.\n\n    Returns:\n        dict: A new dictionary containing only the entries with values greater than or equal to n.\n\n    Examples:\n        >>> dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190}, 170)\n        {'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value >= n}"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    \"\"\"\n    Counts the number of elements that occur before the tuple element in the given tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        int: The number of elements that occur before the tuple element.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n\n    Examples:\n        >>> count_first_elements((1, 5, 7, (4, 6), 10))\n        3\n        >>> count_first_elements((1, 2, 3))\n        0\n        >>> count_first_elements((1, 2, 3, (4, 5)))\n        2\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    count = 0\n    for element in tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n\n    return count"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Calculates the nth decagonal number.\n\n    Parameters:\n    n (int): The position of the decagonal number to be calculated.\n\n    Returns:\n    int: The nth decagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> is_num_decagonal(3)\n    27\n    >>> is_num_decagonal(10)\n    1256\n    >>> is_num_decagonal(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    \"\"\"\n    Searches for an element in an array using sequential search.\n\n    Parameters:\n    arr (list): The array to search in.\n    element: The element to search for.\n\n    Returns:\n    tuple: A tuple containing a boolean indicating if the element is found and the index position of the element (or -1 if not found).\n\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return True, i\n    return False, -1"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if the elements of a given list are unique or not.\n\n    Args:\n        lst (list): The list to be checked.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Examples:\n        >>> all_unique([1, 2, 3])\n        True\n        >>> all_unique([1, 2, 2])\n        False\n        >>> all_unique([])\n        True\n    \"\"\"\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    \"\"\"\n    Subtracts two lists element-wise.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list containing the element-wise subtraction of list1 and list2.\n\n    Raises:\n        ValueError: If the lengths of list1 and list2 are not equal.\n\n    Examples:\n        >>> sub_list([1, 2, 3], [4, 5, 6])\n        [-3, -3, -3]\n        >>> sub_list([1, 2, 3], [1, 2])\n        Traceback (most recent call last):\n        ...\n        ValueError: Lengths of the two lists are not equal.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Lengths of the two lists are not equal.\")\n\n    return [x - y for x, y in zip(list1, list2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(num):\n    \"\"\"\n    Check whether the frequency of each digit in the given integer is less than or equal to the digit itself.\n\n    Args:\n        num (int): The integer to be validated.\n\n    Returns:\n        bool: True if the frequency of each digit is less than or equal to the digit itself, False otherwise.\n    \"\"\"\n    # Convert the integer to a string\n    num_str = str(num)\n\n    # Create a dictionary to store the frequency of each digit\n    digit_freq = {}\n\n    # Count the frequency of each digit\n    for digit in num_str:\n        if digit in digit_freq:\n            digit_freq[digit] += 1\n        else:\n            digit_freq[digit] = 1\n\n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, freq in digit_freq.items():\n        if int(digit) < freq:\n            return False\n\n    return True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    \"\"\"\n    Check if all items in a list are equal to a given element.\n\n    Args:\n        lst (list): The list to be checked.\n        element: The element to compare with the list items.\n\n    Returns:\n        bool: True if all items in the list are equal to the given element, False otherwise.\n    \"\"\"\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "solution": "def text_match_two_three(text):\n    \"\"\"\n    Check whether a string contains the 'a' character followed by two or three 'b' characters.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'a(b{2,3})'\n    import re\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, k, n):\n    \"\"\"\n    Finds the largest sum of a contiguous subarray in a modified array.\n\n    Parameters:\n    arr (list): The original array.\n    k (int): The number of times the original array is repeated.\n    n (int): The length of the original array.\n\n    Returns:\n    int: The largest sum of a contiguous subarray.\n\n    \"\"\"\n\n    # Calculate the sum of the original array\n    original_sum = sum(arr)\n\n    # Calculate the maximum sum of a subarray in the original array\n    max_sum = max_sub_array_sum(arr)\n\n    # Calculate the maximum sum of a subarray in the modified array\n    max_sum_modified = max_sum * k\n\n    # If the sum of the original array is positive, we can repeat it to get a larger sum\n    if original_sum > 0:\n        max_sum_modified += (k - 1) * original_sum\n\n    # If the sum of the original array is negative, we can repeat it to get a smaller sum\n    elif original_sum < 0:\n        max_sum_modified += (k - 2) * original_sum\n\n    return max_sum_modified\ndef max_sub_array_sum(arr):\n    \"\"\"\n    Finds the maximum sum of a contiguous subarray in an array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The maximum sum of a contiguous subarray.\n\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"}
{"task_id": "Mbpp/287", "solution": "def square_sum(n):\n    \"\"\"\n    Calculates the sum of squares of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of squares of the first n even natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> square_sum(2)\n    20\n    >>> square_sum(3)\n    50\n    >>> square_sum(4)\n    120\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return sum(i**2 for i in range(2, 2*n+1, 2))"}
{"task_id": "Mbpp/290", "solution": "def max_length(lst):\n    \"\"\"\n    Find the list with the maximum length in a list of lists.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        tuple: A tuple containing the length of the maximum length list and the maximum length list itself.\n\n    Raises:\n        ValueError: If the input is not a list of lists.\n\n    Examples:\n        >>> max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])\n        (3, [13, 15, 17])\n    \"\"\"\n    if not isinstance(lst, list) or not all(isinstance(sublst, list) for sublst in lst):\n        raise ValueError(\"Input must be a list of lists.\")\n\n    max_len = max(len(sublst) for sublst in lst)\n    max_lst = [sublst for sublst in lst if len(sublst) == max_len][0]\n\n    return max_len, max_lst"}
{"task_id": "Mbpp/292", "solution": "def find_quotient(dividend, divisor):\n    \"\"\"\n    Finds the quotient of two numbers (rounded down to the nearest integer).\n\n    Args:\n        dividend (int): The number to be divided.\n        divisor (int): The number to divide by.\n\n    Returns:\n        int: The quotient of the division.\n\n    Raises:\n        ZeroDivisionError: If the divisor is zero.\n\n    Examples:\n        >>> find_quotient(10, 3)\n        3\n        >>> find_quotient(10, 0)\n        Traceback (most recent call last):\n        ...\n        ZeroDivisionError: division by zero\n    \"\"\"\n    if divisor == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    return dividend // divisor"}
{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(side1, side2):\n    \"\"\"\n    Calculates the length of the third side of a right-angled triangle.\n\n    Parameters:\n    side1 (float): The length of the first side of the triangle.\n    side2 (float): The length of the second side of the triangle.\n\n    Returns:\n    float: The length of the third side of the triangle.\n\n    Raises:\n    ValueError: If either side1 or side2 is negative.\n\n    \"\"\"\n\n    if side1 < 0 or side2 < 0:\n        raise ValueError(\"Sides cannot be negative.\")\n\n    return math.sqrt(side1**2 + side2**2)"}
{"task_id": "Mbpp/294", "solution": "def max_val(lst):\n    \"\"\"\n    Finds the maximum value in a given heterogeneous list.\n\n    Args:\n        lst (list): The list to search for the maximum value.\n\n    Returns:\n        The maximum value found in the list.\n\n    Raises:\n        ValueError: If the list is empty or contains only non-numeric values.\n\n    Examples:\n        >>> max_val(['Python', 3, 2, 4, 5, 'version'])\n        5\n        >>> max_val([1, 2, 3, 4, 5])\n        5\n        >>> max_val(['a', 'b', 'c'])\n        'c'\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List cannot be empty.\")\n\n    max_value = lst[0]\n    for item in lst:\n        if isinstance(item, (int, float)) and item > max_value:\n            max_value = item\n\n    if isinstance(max_value, (int, float)):\n        return max_value\n    else:\n        raise ValueError(\"List must contain only numeric values.\")"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions in the array.\n\n    \"\"\"\n\n    def merge_sort(arr):\n        \"\"\"\n        Sorts the array using the merge sort algorithm.\n\n        Parameters:\n        arr (list): The input array.\n\n        Returns:\n        list: The sorted array.\n\n        \"\"\"\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        left_half = merge_sort(left_half)\n        right_half = merge_sort(right_half)\n\n        return merge(left_half, right_half)\n\n    def merge(left_half, right_half):\n        \"\"\"\n        Merges two sorted arrays into a single sorted array.\n\n        Parameters:\n        left_half (list): The left half of the array.\n        right_half (list): The right half of the array.\n\n        Returns:\n        list: The merged and sorted array.\n\n        \"\"\"\n        merged = []\n        i = j = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                merged.append(left_half[i])\n                i += 1\n            else:\n                merged.append(right_half[j])\n                j += 1\n                inv_count += len(left_half) - i\n\n        merged.extend(left_half[i:])\n        merged.extend(right_half[j:])\n\n        return merged\n\n    inv_count = 0\n    merge_sort(arr)\n    return inv_count"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"\n    Flatten a given nested list structure.\n\n    Args:\n        nested_list (list): The nested list to be flattened.\n\n    Returns:\n        list: The flattened list.\n\n    Examples:\n        >>> flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])\n        [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n    \"\"\"\n    flattened_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    return flattened_list"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(lst):\n    \"\"\"\n    Calculate the maximum aggregate from a list of tuples.\n\n    Args:\n        lst (list): A list of tuples, where each tuple contains a name and an aggregate score.\n\n    Returns:\n        tuple: A tuple containing the name with the maximum aggregate score and the maximum aggregate score.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)])\n        ('Juan Whelan', 212)\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    max_name = lst[0][0]\n    max_score = lst[0][1]\n\n    for name, score in lst:\n        if score > max_score:\n            max_name = name\n            max_score = score\n\n    return max_name, max_score"}
{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    \"\"\"\n    Function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n\n    Parameters:\n    n (int): The length of the binary sequence.\n\n    Returns:\n    float: The count of binary sequences satisfying the condition.\n\n    \"\"\"\n\n    # Base case: If n is 0, there is only one possible sequence (empty sequence)\n    if n == 0:\n        return 1\n\n    # Recursive case:\n    # For each possible bit value (0 or 1) at the current position,\n    # recursively count the number of sequences with the same sum of first and last n bits.\n    count = 0\n    for bit in [0, 1]:\n        count += count_binary_seq(n - 1)\n\n    return count"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):"}
{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    \"\"\"\n    Returns two words from a list of words starting with letter 'p'.\n\n    Args:\n        words (list): A list of words.\n\n    Returns:\n        tuple: A tuple containing two words starting with letter 'p'.\n\n    Raises:\n        ValueError: If no words are found starting with letter 'p'.\n\n    Examples:\n        >>> start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])\n        ('Python', 'PHP')\n    \"\"\"\n    p_words = [word for word in words if word.lower().startswith('p')]\n    if len(p_words) < 2:\n        raise ValueError(\"No words found starting with letter 'p'.\")\n    return tuple(p_words[:2])"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    \"\"\"\n    Finds the maximum sum of an increasing subsequence from prefix until the ith index,\n    including the kth element which is after i.\n\n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The length of the input list.\n    i (int): The index up to which the prefix is considered.\n    k (int): The index of the element to be included after i.\n\n    Returns:\n    int: The maximum sum of the increasing subsequence.\n\n    Raises:\n    ValueError: If the input list is empty or if i or k is out of range.\n\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    if i < 0 or i >= n or k < 0 or k >= n:\n        raise ValueError(\"i and k must be within the range of the input list.\")\n\n    # Initialize a list to store the maximum sum of increasing subsequences\n    max_sum = [0] * n\n\n    # Initialize the maximum sum of the subsequence ending at index i\n    max_sum[i] = arr[i]\n\n    # Iterate through the array from index i+1 to k-1\n    for j in range(i + 1, k):\n        # Initialize the maximum sum of the subsequence ending at index j\n        max_sum[j] = arr[j]\n\n        # Find the maximum sum of the subsequence ending at index j\n        for l in range(i, j):\n            if arr[j] > arr[l] and max_sum[j] < max_sum[l] + arr[j]:\n                max_sum[j] = max_sum[l] + arr[j]\n\n    # Find the maximum sum of the subsequence ending at index k\n    max_sum[k] = arr[k]\n\n    # Find the maximum sum of the subsequence ending at index i\n    for j in range(i + 1, k):\n        if arr[k] > arr[j] and max_sum[k] < max_sum[j] + arr[k]:\n            max_sum[k] = max_sum[j] + arr[k]\n\n    # Find the maximum sum of the subsequence\n    max_sum_subseq = max(max_sum)\n\n    return max_sum_subseq"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, num):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        num (int): The number of largest products to find.\n\n    Returns:\n        list: A list of the specified number of largest products.\n\n    Raises:\n        ValueError: If the number of products to find is greater than the total number of products that can be formed.\n\n    Examples:\n        >>> large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)\n        [60, 54, 50]\n    \"\"\"\n\n    # Check if the number of products to find is greater than the total number of products that can be formed\n    if num > len(list1) * len(list2):\n        raise ValueError(\"Number of products to find is greater than the total number of products that can be formed.\")\n\n    # Create a list to store the products\n    products = []\n\n    # Generate all possible products\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the specified number of largest products\n    return products[:num]"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    Find the maximum of two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The maximum of the two numbers.\n\n    Raises:\n    TypeError: If either `a` or `b` is not a number.\n\n    Examples:\n    >>> maximum(5, 10)\n    10\n    >>> maximum(-5, 10)\n    10\n    >>> maximum(5.5, 10.5)\n    10.5\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers.\")\n\n    return max(a, b)"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(string):\n    \"\"\"\n    Convert a given string to a tuple of characters.\n\n    Args:\n        string (str): The input string to be converted.\n\n    Returns:\n        tuple: A tuple of characters representing the input string.\n\n    Examples:\n        >>> string_to_tuple(\"python 3.0\")\n        ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n    \"\"\"\n    return tuple(string)"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(num):\n    \"\"\"\n    Set the left most unset bit in a given number.\n\n    Args:\n        num (int): The number for which the left most unset bit needs to be set.\n\n    Returns:\n        int: The number with the left most unset bit set.\n\n    Raises:\n        ValueError: If the input number is negative.\n\n    Examples:\n        >>> set_left_most_unset_bit(10)\n        14\n        >>> set_left_most_unset_bit(0)\n        1\n        >>> set_left_most_unset_bit(-1)\n        Traceback (most recent call last):\n        ...\n        ValueError: Input number cannot be negative.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input number cannot be negative.\")\n\n    # Find the leftmost unset bit\n    bit_index = 0\n    while num & (1 << bit_index):\n        bit_index += 1\n\n    # Set the leftmost unset bit\n    num |= (1 << bit_index)\n\n    return num"}
{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n\n    Parameters:\n    radius (float): The radius of the cone.\n    height (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n\n    Raises:\n    ValueError: If either radius or height is negative.\n\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be positive.\")\n\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume"}
{"task_id": "Mbpp/388", "solution": "def highest_power_of_2(n):\n    \"\"\"\n    Finds the highest power of 2 that is less than or equal to n.\n\n    Parameters:\n    n (int): The number to find the highest power of 2 for.\n\n    Returns:\n    int: The highest power of 2 that is less than or equal to n.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    Examples:\n    >>> highest_power_of_2(10)\n    8\n    >>> highest_power_of_2(1)\n    1\n    >>> highest_power_of_2(0)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be greater than or equal to 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1.\")\n\n    power = 1\n    while power <= n:\n        power *= 2\n\n    return power // 2"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    \"\"\"\n    Find the n'th Lucas number.\n\n    The Lucas numbers are a sequence of numbers in which each number is the sum of the two preceding ones.\n    The first two numbers in the sequence are 2 and 1.\n\n    Args:\n        n (int): The index of the Lucas number to find.\n\n    Returns:\n        int: The n'th Lucas number.\n\n    Raises:\n        ValueError: If n is less than 1.\n\n    Examples:\n        >>> find_lucas(1)\n        1\n        >>> find_lucas(2)\n        3\n        >>> find_lucas(9)\n        76\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 1\n    else:\n        return find_lucas(n - 1) + find_lucas(n - 2)"}
{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    \"\"\"\n    Apply a given format string to all elements in a list.\n\n    Args:\n        lst (list): The list of elements to be formatted.\n        format_str (str): The format string to be applied to each element.\n\n    Returns:\n        list: A new list with the formatted elements.\n\n    Raises:\n        TypeError: If the input arguments are not of the correct type.\n\n    Examples:\n        >>> add_string([1, 2, 3, 4], 'temp{0}')\n        ['temp1', 'temp2', 'temp3', 'temp4']\n        >>> add_string(['a', 'b', 'c'], '{0} is a letter')\n        ['a is a letter', 'b is a letter', 'c is a letter']\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if not isinstance(format_str, str):\n        raise TypeError(\"format_str must be a string\")\n\n    return [format_str.format(item) for item in lst]"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values, scores):\n    \"\"\"\n    Convert multiple lists into a nested dictionary.\n\n    Args:\n        keys (list): List of keys.\n        values (list): List of values.\n        scores (list): List of scores.\n\n    Returns:\n        list: List of dictionaries with keys and values.\n\n    Raises:\n        ValueError: If the lengths of the input lists are not equal.\n\n    Examples:\n        >>> convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])\n        [{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n    \"\"\"\n    if len(keys) != len(values) or len(keys) != len(scores):\n        raise ValueError(\"Input lists must have equal lengths.\")\n\n    nested_dict = []\n    for i in range(len(keys)):\n        nested_dict.append({keys[i]: {values[i]: scores[i]}})\n\n    return nested_dict"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Parameters:\n    n (int): The input number for which the maximum sum is to be calculated.\n\n    Returns:\n    int: The maximum sum possible.\n\n    \"\"\"\n\n    # Base case: If n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n\n    # Recursive case: Calculate the maximum sum using the given equation\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(tup):\n    \"\"\"\n    Check if given tuple contains no duplicates.\n\n    Args:\n        tup (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    return len(tup) == len(set(tup))"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The first non-repeated character in the string, or None if no non-repeated character is found.\n\n    Examples:\n        >>> first_non_repeating_character(\"abcabc\")\n        'c'\n        >>> first_non_repeating_character(\"abab\")\n        None\n    \"\"\"\n    # Create a dictionary to store the count of each character in the string\n    char_count = {}\n\n    # Iterate through each character in the string\n    for char in string:\n        # Increment the count of the character in the dictionary\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through each character in the string again\n    for char in string:\n        # If the count of the character is 1, it is the first non-repeated character\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    Find the median of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    float: The median of the three numbers.\n\n    Raises:\n    ValueError: If any of the input numbers is not a number (int or float).\n\n    Examples:\n    >>> median_numbers(25, 55, 65)\n    55.0\n    >>> median_numbers(10, 20, 30)\n    20.0\n    >>> median_numbers(10.5, 20.5, 30.5)\n    20.5\n    \"\"\"\n\n    # Check if the input numbers are numbers\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)) or not isinstance(c, (int, float)):\n        raise ValueError(\"Input numbers must be numbers (int or float).\")\n\n    # Find the median\n    if a <= b <= c or c <= b <= a:\n        median = b\n    elif b <= a <= c or c <= a <= b:\n        median = a\n    else:\n        median = c\n\n    return float(median)"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Compute the sum of digits of each number in a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A list of sums of digits for each number in the input list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If any element in the list is not a positive integer.\n\n    Examples:\n        >>> sum_of_digits([10, 2, 56])\n        [1, 2, 11]\n        >>> sum_of_digits([123, 456, 789])\n        [6, 15, 24]\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    result = []\n    for number in numbers:\n        if not isinstance(number, int) or number <= 0:\n            raise ValueError(\"All elements in the list must be positive integers.\")\n\n        digit_sum = 0\n        while number > 0:\n            digit_sum += number % 10\n            number //= 10\n\n        result.append(digit_sum)\n\n    return result"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    Find the minimum of two numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The minimum of the two numbers.\n\n    Raises:\n    TypeError: If either `a` or `b` is not a number.\n\n    Examples:\n    >>> minimum(1, 2)\n    1\n    >>> minimum(2, 1)\n    1\n    >>> minimum(1, 1)\n    1\n    >>> minimum(-1, 1)\n    -1\n    >>> minimum(1, -1)\n    -1\n    >>> minimum(0, 0)\n    0\n    >>> minimum(1.5, 2.5)\n    1.5\n    >>> minimum(2.5, 1.5)\n    1.5\n    >>> minimum(1.5, 1.5)\n    1.5\n    >>> minimum(-1.5, -2.5)\n    -2.5\n    >>> minimum(-2.5, -1.5)\n    -2.5\n    >>> minimum(-1.5, -1.5)\n    -1.5\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers.\")\n    return min(a, b)"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to be checked.\n        element: The element to be searched for in the tuple.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(num):\n    \"\"\"\n    This function takes an integer as input and returns True if the parity of the number is odd, and False otherwise.\n\n    Parameters:\n    num (int): The number to check the parity of.\n\n    Returns:\n    bool: True if the parity of the number is odd, False otherwise.\n    \"\"\"\n    # Check if the number is odd by checking if the number of 1s in its binary representation is odd\n    binary_rep = bin(num)[2:]  # Convert the number to binary representation, excluding the '0b' prefix\n    num_ones = binary_rep.count('1')  # Count the number of 1s in the binary representation\n    return num_ones % 2 != 0  # Return True if the number of 1s is odd, False otherwise"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(lst):\n    \"\"\"\n    Finds the minimum product from the pairs of tuples within a given list.\n\n    Args:\n        lst (list): A list of tuples.\n\n    Returns:\n        int: The minimum product of the pairs of tuples.\n\n    Raises:\n        ValueError: If the input list is empty or contains non-tuple elements.\n\n    Examples:\n        >>> min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)])\n        8\n        >>> min_product_tuple([(1, 2), (3, 4), (5, 6)])\n        6\n        >>> min_product_tuple([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n        >>> min_product_tuple([(1, 2), (3, 4), (5, 6), (7,)])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list must contain only tuples.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    for tup in lst:\n        if not isinstance(tup, tuple):\n            raise ValueError(\"Input list must contain only tuples.\")\n\n    min_product = float('inf')\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            product = lst[i][0] * lst[j][1]\n            if product < min_product:\n                min_product = product\n\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    \"\"\"\n    Find the minimum value in a given heterogeneous list.\n\n    Args:\n        lst (list): The list to find the minimum value from.\n\n    Returns:\n        The minimum value in the list.\n\n    Raises:\n        ValueError: If the list is empty.\n\n    Examples:\n        >>> min_val(['Python', 3, 2, 4, 5, 'version'])\n        2\n        >>> min_val([])\n        Traceback (most recent call last):\n        ...\n        ValueError: List is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty.\")\n\n    min_value = lst[0]\n    for item in lst:\n        if isinstance(item, (int, float)) and item < min_value:\n            min_value = item\n\n    return min_value"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(lst):\n    \"\"\"\n    Remove odd numbers from a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: A new list with odd numbers removed.\n\n    Examples:\n        >>> remove_odd([1, 2, 3, 4, 5])\n        [2, 4]\n        >>> remove_odd([1, 3, 5])\n        []\n        >>> remove_odd([2, 4, 6])\n        [2, 4, 6]\n    \"\"\"\n    return [num for num in lst if num % 2 == 0]"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(lst, n):\n    \"\"\"\n    Extracts the nth element from a given list of tuples.\n\n    Args:\n        lst (list): The list of tuples.\n        n (int): The index of the element to extract.\n\n    Returns:\n        list: A list containing the nth element from each tuple in the input list.\n\n    Raises:\n        IndexError: If the index is out of range.\n\n    Examples:\n        >>> extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0)\n        ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n        >>> extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1)\n        [98, 97, 91, 94]\n        >>> extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 2)\n        [99, 96, 94, 98]\n    \"\"\"\n    return [t[n] for t in lst]"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n\n    Args:\n        seq1 (list or tuple): The first sequence.\n        seq2 (list or tuple): The second sequence.\n\n    Returns:\n        bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)"}
{"task_id": "Mbpp/415", "solution": "def max_product(arr):\n    \"\"\"\n    Finds a pair with the highest product from a given array of integers.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        tuple: A tuple containing the two integers with the highest product.\n\n    Raises:\n        ValueError: If the input list is empty or contains less than two elements.\n\n    Examples:\n        >>> max_product([1, 2, 3, 4, 7, 0, 8, 4])\n        (7, 8)\n        >>> max_product([-1, -2, -3, -4, -7, 0, -8, -4])\n        (-7, -8)\n        >>> max_product([1, 2, 3, 4, 7, 0, 8, 4])\n        (7, 8)\n        >>> max_product([1, 2, 3, 4, 7, 0, 8, 4])\n        (7, 8)\n    \"\"\"\n\n    if len(arr) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n\n    max_product = float('-inf')\n    pair = ()\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                pair = (arr[i], arr[j])\n\n    return pair"}
{"task_id": "Mbpp/418", "solution": "def find_max_length_element(lst):\n    \"\"\"\n    Find the element of a list with the maximum length.\n\n    Args:\n        lst (list): A list of elements.\n\n    Returns:\n        list: The element with the maximum length.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> find_max_length_element([['A'], ['A', 'B'], ['A', 'B', 'C']])\n        ['A', 'B', 'C']\n        >>> find_max_length_element([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty.\")\n\n    max_length = max(len(element) for element in lst)\n    max_length_element = [element for element in lst if len(element) == max_length]\n\n    return max_length_element[0]"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    \"\"\"\n    Rounds every number in the given list and returns the sum multiplied by the length of the list.\n\n    Parameters:\n    numbers (list): A list of numbers to be rounded.\n\n    Returns:\n    int: The sum of the rounded numbers multiplied by the length of the list.\n\n    Examples:\n    >>> round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])\n    243\n    \"\"\"\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    return total_sum * len(rounded_numbers)"}
{"task_id": "Mbpp/420", "solution": "def cube_sum(n):\n    \"\"\"\n    Calculates the cube sum of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to include in the sum.\n\n    Returns:\n    int: The cube sum of the first n even natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> cube_sum(2)\n    72\n    >>> cube_sum(3)\n    216\n    >>> cube_sum(0)\n    0\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return sum(i**3 for i in range(2, 2*n+1, 2))"}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string using a delimiter.\n\n    Args:\n        tup (tuple): The input tuple to be concatenated.\n        delimiter (str, optional): The delimiter to be used between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n\n    Examples:\n        >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"))\n        'ID-is-4-UTS'\n        >>> concatenate_tuple((\"ID\", \"is\", 4, \"UTS\"), delimiter='_')\n        'ID_is_4_UTS'\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    return delimiter.join(str(item) for item in tup)"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    Calculates the average of the cubes of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    float: The average of the cubes of the first n natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> find_Average_Of_Cube(2)\n    4.5\n    >>> find_Average_Of_Cube(3)\n    10.0\n    >>> find_Average_Of_Cube(4)\n    22.5\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Calculate the sum of the cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n\n    # Calculate the average of the cubes\n    average_of_cubes = sum_of_cubes / n\n\n    return average_of_cubes"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n        tup (tuple): A tuple of strings.\n\n    Returns:\n        list: A list of rear index elements of each string in the given tuple.\n\n    Raises:\n        TypeError: If the input is not a tuple.\n\n    Examples:\n        >>> extract_rear(('Mers', 'for', 'Vers') )\n        ['s', 'r', 's']\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    return [string[-1] for string in tup]"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n        lst (list): The list of sublists to be searched.\n        element: The element to be counted.\n\n    Returns:\n        int: The number of sublists containing the element.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n        3\n        >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 2)\n        0\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    count = 0\n    for sublist in lst:\n        if isinstance(sublist, list) and element in sublist:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    \"\"\"\n    Filters odd numbers from a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A new list containing only the odd numbers from the input list.\n\n    Examples:\n        >>> filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        [1, 3, 5, 7, 9]\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date_str):\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Args:\n        date_str (str): The date string in yyyy-mm-dd format.\n\n    Returns:\n        str: The date string in dd-mm-yyyy format.\n\n    Raises:\n        ValueError: If the input date string is not in the correct format.\n\n    Examples:\n        >>> change_date_format(\"2026-01-02\")\n        '02-01-2026'\n        >>> change_date_format(\"2026-12-31\")\n        '31-12-2026'\n        >>> change_date_format(\"2026-01-01\")\n        '01-01-2026'\n    \"\"\"\n    try:\n        year, month, day = date_str.split('-')\n        return f\"{day}-{month}-{year}\"\n    except ValueError:\n        raise ValueError(\"Invalid date format. Please provide a date in yyyy-mm-dd format.\")"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell Sort algorithm.\n\n    Parameters:\n    arr (list): The array to be sorted.\n\n    Returns:\n    list: The sorted array.\n\n    \"\"\"\n\n    # Calculate the gap size\n    gap = len(arr) // 2\n\n    # Perform shell sort\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n\n            # Compare elements at current position with the elements at the gap positions before it\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        # Reduce the gap size\n        gap //= 2\n\n    return arr"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    Function to extract the elementwise and tuples from the given two tuples.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A tuple containing the elementwise and of the two input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> and_tuples((10, 4, 6, 9), (5, 2, 3, 3))\n        (0, 0, 2, 1)\n        >>> and_tuples((1, 2, 3), (4, 5, 6))\n        (0, 0, 2)\n        >>> and_tuples((1, 2, 3), (4, 5))\n        ValueError: Input tuples must have the same length.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    return tuple(a & b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculates the directrix of a parabola.\n\n    Parameters:\n    a (float): Coefficient of x^2 term.\n    b (float): Coefficient of x term.\n    c (float): Constant term.\n\n    Returns:\n    float: The directrix of the parabola.\n\n    Raises:\n    ValueError: If the parabola is vertical (i.e., a = 0).\n\n    \"\"\"\n\n    if a == 0:\n        raise ValueError(\"Parabola is vertical.\")\n\n    return -b / (2 * a)"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    \"\"\"\n    Calculates the median length of a trapezium.\n\n    Parameters:\n    a (float): Length of the first parallel side of the trapezium.\n    b (float): Length of the second parallel side of the trapezium.\n    c (float): Length of the base of the trapezium.\n\n    Returns:\n    float: Median length of the trapezium.\n\n    Raises:\n    ValueError: If any of the input lengths is negative or zero.\n\n    \"\"\"\n\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"Input lengths must be positive and non-zero.\")\n\n    # Calculate the height of the trapezium using the Pythagorean theorem\n    height = (a**2 + c**2 - b**2) / (2 * a)\n\n    # Calculate the median length using the formula for the median of a trapezium\n    median = (a + b) / 2\n\n    return median"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers.\n    num (int): The number to compare with the elements of the array.\n\n    Returns:\n    bool: True if the number is greater than all the elements of the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True"}
{"task_id": "Mbpp/435", "solution": "def last_digit(number):\n    \"\"\"\n    Returns the last digit of a given number.\n\n    Parameters:\n    number (int): The number for which the last digit needs to be found.\n\n    Returns:\n    int: The last digit of the given number.\n\n    Raises:\n    ValueError: If the input is not a positive integer.\n\n    Examples:\n    >>> last_digit(123)\n    3\n    >>> last_digit(1000)\n    0\n    >>> last_digit(-123)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be a positive integer.\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    return number % 10"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    \"\"\"\n    Returns a list of negative numbers from the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    list: A list of negative numbers from the given list.\n\n    Examples:\n    >>> neg_nos([-1, 4, 5, -6])\n    [-1, -6]\n    >>> neg_nos([1, 2, 3, 4, 5])\n    []\n    >>> neg_nos([-1, -2, -3])\n    [-1, -2, -3]\n    \"\"\"\n    return [num for num in lst if num < 0]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The string with odd characters removed.\n\n    Examples:\n        >>> remove_odd(\"python\")\n        'yhn'\n        >>> remove_odd(\"hello\")\n        'hlo'\n    \"\"\"\n    return ''.join([string[i] for i in range(len(string)) if i % 2 == 0])"}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    \"\"\"\n    Join a list of multiple integers into a single integer.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The joined integer.\n\n    Raises:\n        ValueError: If the input is not a list or if any element in the list is not an integer.\n\n    Examples:\n        >>> multiple_to_single([11, 33, 50])\n        113350\n        >>> multiple_to_single([100, 200, 300])\n        100200300\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"All elements in the list must be integers.\")\n\n    return int(''.join(map(str, numbers)))"}
{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    \"\"\"\n    Calculates the surface area of a cube.\n\n    Parameters:\n    side_length (float or int): The length of one side of the cube.\n\n    Returns:\n    float: The surface area of the cube.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    Examples:\n    >>> surfacearea_cube(5)\n    150\n    >>> surfacearea_cube(0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Side length must be a positive number.\n    \"\"\"\n\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    return 6 * side_length ** 2"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    \"\"\"\n    Perform index wise multiplication of tuple elements in the given two tuples.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple with the result of index wise multiplication of elements from the input tuples.\n\n    Raises:\n        ValueError: If the input tuples have different lengths.\n\n    Examples:\n        >>> index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) )\n        ((6, 21), (12, 45), (2, 9), (7, 30))\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple(a * b for a, b in zip(tuple1[i], tuple2[i])))\n\n    return tuple(result)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Args:\n        tuple_input (tuple): The input tuple.\n        list_input (list): The input list.\n\n    Returns:\n        int: The count of occurrences of elements in the list in the tuple.\n\n    Raises:\n        TypeError: If either the tuple_input or list_input is not of the correct type.\n\n    Examples:\n        >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'])\n        3\n        >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b', 'c'])\n        4\n        >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b', 'c', 'd'])\n        5\n    \"\"\"\n    if not isinstance(tuple_input, tuple):\n        raise TypeError(\"tuple_input must be a tuple.\")\n    if not isinstance(list_input, list):\n        raise TypeError(\"list_input must be a list.\")\n\n    count = 0\n    for element in list_input:\n        count += tuple_input.count(element)\n\n    return count"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    \"\"\"\n    Function to find cubes of individual elements in a list.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    list: A new list with the cubes of the elements in the input list.\n\n    Examples:\n    >>> cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    \"\"\"\n    return [num ** 3 for num in nums]"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of the first n Perrin numbers.\n\n    Parameters:\n    n (int): The number of Perrin numbers to sum.\n\n    Returns:\n    int: The sum of the first n Perrin numbers.\n\n    Raises:\n    ValueError: If n is less than 1.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1.\")\n\n    perrin_numbers = [3, 0, 2]\n    while len(perrin_numbers) < n:\n        perrin_numbers.append(perrin_numbers[-3] + perrin_numbers[-2])\n\n    return sum(perrin_numbers[:n])"}
{"task_id": "Mbpp/450", "solution": "def extract_string(string_list, size):\n    \"\"\"\n    Extracts specified size of strings from a given list of string values.\n\n    Args:\n        string_list (list): A list of string values.\n        size (int): The size of the strings to be extracted.\n\n    Returns:\n        list: A list of strings with the specified size.\n\n    Raises:\n        ValueError: If the size is not a positive integer.\n\n    Examples:\n        >>> extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8)\n        ['practice', 'solution']\n        >>> extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 10)\n        []\n    \"\"\"\n    if not isinstance(size, int) or size <= 0:\n        raise ValueError(\"Size must be a positive integer.\")\n\n    return [s for s in string_list if len(s) == size]"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The string with all whitespaces removed.\n\n    Examples:\n        >>> remove_whitespaces(' Google    Flutter ')\n        'GoogleFlutter'\n    \"\"\"\n    return string.replace(\" \", \"\")"}
{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    \"\"\"\n    Calculates the sum of even factors of a given number.\n\n    Parameters:\n    n (int): The number for which the sum of even factors needs to be calculated.\n\n    Returns:\n    int: The sum of even factors of the given number.\n\n    Raises:\n    ValueError: If the input number is not a positive integer.\n\n    Examples:\n    >>> sumofFactors(18)\n    26\n    >>> sumofFactors(24)\n    42\n    >>> sumofFactors(1)\n    0\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input number must be a positive integer.\")\n\n    factors = [i for i in range(1, n+1) if n % i == 0]\n    even_factors = [i for i in factors if i % 2 == 0]\n    return sum(even_factors)"}
{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    \"\"\"\n    Check if a given text contains the word 'z'.\n\n    Args:\n        text (str): The text to be checked.\n\n    Returns:\n        bool: True if the text contains the word 'z', False otherwise.\n    \"\"\"\n    pattern = r'\\bz\\w*\\b'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/455", "solution": "def check_month_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 31 days or not.\n\n    Parameters:\n    month_number (int): The month number to be checked.\n\n    Returns:\n    bool: True if the month number contains 31 days, False otherwise.\n    \"\"\"\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    elif month_number in [4, 6, 9, 11]:\n        return False\n    elif month_number == 2:\n        return False\n    else:\n        raise ValueError(\"Invalid month number. Please provide a number between 1 and 12.\")\n\n# Testing the function\nassert check_month_number(5) == True\nassert check_month_number(2) == False\nassert check_month_number(13) == ValueError"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Args:\n        string_list (list): A list of string values.\n\n    Returns:\n        list: A new list with each string reversed.\n\n    Examples:\n        >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n        ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list"}
{"task_id": "Mbpp/457", "solution": "def find_min_sublist(lst):\n    \"\"\"\n    Finds the sublist with the minimum length in a given list of sublists.\n\n    Args:\n        lst (list): A list of sublists.\n\n    Returns:\n        list: The sublist with the minimum length.\n\n    Raises:\n        ValueError: If the input is not a list of sublists.\n\n    Examples:\n        >>> find_min_sublist([[1], [1, 2], [1, 2, 3]])\n        [1]\n        >>> find_min_sublist([[1, 2, 3], [1, 2], [1]])\n        [1]\n        >>> find_min_sublist([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [1, 2, 3]\n    \"\"\"\n    if not isinstance(lst, list) or not all(isinstance(sublist, list) for sublist in lst):\n        raise ValueError(\"Input must be a list of sublists.\")\n\n    min_length = min(len(sublist) for sublist in lst)\n    min_sublist = [sublist for sublist in lst if len(sublist) == min_length]\n\n    return min_sublist[0]"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculates the area of a rectangle.\n\n    Parameters:\n    length (float or int): The length of the rectangle.\n    width (float or int): The width of the rectangle.\n\n    Returns:\n    float or int: The area of the rectangle.\n\n    Raises:\n    ValueError: If either length or width is negative.\n\n    Examples:\n    >>> rectangle_area(10, 20)\n    200\n    >>> rectangle_area(5, 5)\n    25\n    >>> rectangle_area(0, 10)\n    0\n    >>> rectangle_area(10, 0)\n    0\n    >>> rectangle_area(-10, 20)\n    Traceback (most recent call last):\n    ...\n    ValueError: Length and width must be positive numbers.\n    >>> rectangle_area(10, -20)\n    Traceback (most recent call last):\n    ...\n    ValueError: Length and width must be positive numbers.\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"Length and width must be positive numbers.\")\n    return length * width"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    \"\"\"\n    Remove uppercase substrings from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with uppercase substrings removed.\n\n    Examples:\n        >>> remove_uppercase('cAstyoUrFavoRitETVshoWs')\n        'cstyoravoitshos'\n    \"\"\"\n    result = ''\n    current_substring = ''\n\n    for char in string:\n        if char.isupper():\n            current_substring += char\n        else:\n            if current_substring.isupper():\n                current_substring = ''\n            else:\n                result += current_substring\n                current_substring = ''\n            result += char\n\n    if current_substring.isupper():\n        current_substring = ''\n    result += current_substring\n\n    return result"}
{"task_id": "Mbpp/460", "solution": "def extract_first_elements(sublists):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n        sublists (list): A list of sublists.\n\n    Returns:\n        list: A list containing the first element of each sublist.\n\n    Raises:\n        ValueError: If the input is not a list of sublists.\n\n    Examples:\n        >>> extract_first_elements([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n        [1, 3, 6]\n\n        >>> extract_first_elements([[1], [2, 3], [4, 5, 6]])\n        [1, 2, 4]\n\n        >>> extract_first_elements([[1, 2, 3], [4, 5], [6]])\n        [1, 4, 6]\n\n        >>> extract_first_elements([])\n        []\n\n        >>> extract_first_elements([[], [1, 2], [3, 4, 5]])\n        [None, 1, 3]\n\n        >>> extract_first_elements([[1, 2], [3, 4, 5], []])\n        [1, 3, None]\n\n        >>> extract_first_elements([[1, 2], [3, 4, 5], [6, 7, 8, 9], []])\n        [1, 3, 6, None]\n\n        >>> extract_first_elements([[1, 2], [3, 4, 5], [6, 7, 8, 9], [10, 11, 12]])\n        [1, 3, 6, 10]\n\n    \"\"\"\n    if not isinstance(sublists, list):\n        raise ValueError(\"Input must be a list of sublists.\")\n\n    return [sublist[0] if sublist else None for sublist in sublists]"}
{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    \"\"\"\n    Find all possible combinations of the elements of a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: A list of all possible combinations of the elements of the input list.\n\n    Examples:\n        >>> combinations_list(['orange', 'red', 'green', 'blue'])\n        [[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n    \"\"\"\n    def backtrack(start, path):\n        # Add the current combination to the result\n        result.append(path[:])\n\n        # Explore the remaining elements\n        for i in range(start, len(lst)):\n            # Add the current element to the path\n            path.append(lst[i])\n            # Recursively explore the remaining elements\n            backtrack(i + 1, path)\n            # Remove the current element from the path\n            path.pop()\n\n    result = []\n    backtrack(0, [])\n    return result"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    \"\"\"\n    Drop empty items from a given dictionary.\n\n    Args:\n        dictionary (dict): The input dictionary.\n\n    Returns:\n        dict: A new dictionary with empty items removed.\n\n    Examples:\n        >>> drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})\n        {'c1': 'Red', 'c2': 'Green'}\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    \"\"\"\n    Finds the maximum product formed by multiplying numbers of an increasing subsequence of an array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum product formed by multiplying numbers of an increasing subsequence.\n\n    Raises:\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> max_product([3, 100, 4, 5, 150, 6])\n    3000\n    >>> max_product([1, 2, 3, 4, 5])\n    60\n    >>> max_product([5, 4, 3, 2, 1])\n    60\n    >>> max_product([])\n    Traceback (most recent call last):\n    ...\n    ValueError: Input list cannot be empty.\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    n = len(arr)\n    max_product = [0] * n\n\n    for i in range(n):\n        max_product[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j] and max_product[i] < max_product[j] * arr[i]:\n                max_product[i] = max_product[j] * arr[i]\n\n    return max(max_product)"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(tup):\n    \"\"\"\n    Function to find the pairwise addition of the neighboring elements of the given tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        tuple: A new tuple with the pairwise addition of the neighboring elements.\n\n    Raises:\n        ValueError: If the input is not a tuple.\n\n    Examples:\n        >>> add_pairwise((1, 5, 7, 8, 10))\n        (6, 12, 15, 18)\n        >>> add_pairwise((1, 2, 3))\n        (3, 5)\n        >>> add_pairwise((1,))\n        (1,)\n        >>> add_pairwise(())\n        ()\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    result = []\n    for i in range(len(tup) - 1):\n        result.append(tup[i] + tup[i + 1])\n\n    return tuple(result)"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    Calculates the product of the array multiplication modulo n.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The modulo value.\n\n    Returns:\n    int: The product of the array multiplication modulo n.\n\n    Raises:\n    ValueError: If the modulo value is zero or negative.\n\n    Examples:\n    >>> find_remainder([100, 10, 5, 25, 35, 14], 11)\n    9\n    >>> find_remainder([1, 2, 3, 4, 5], 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Modulo value cannot be zero or negative.\n    >>> find_remainder([1, 2, 3, 4, 5], -1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Modulo value cannot be zero or negative.\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"Modulo value cannot be zero or negative.\")\n\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n\n    return product"}
{"task_id": "Mbpp/472", "solution": "def check_consecutive(lst):\n    \"\"\"\n    Check whether the given list contains consecutive numbers or not.\n\n    Args:\n        lst (list): The list to be checked.\n\n    Returns:\n        bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n\n    # Check if the difference between consecutive elements is 1\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i+1] - sorted_lst[i] != 1:\n            return False\n\n    return True\n\n# Test cases\nassert check_consecutive([1, 2, 3, 4, 5]) == True\nassert check_consecutive([1, 3, 4, 5]) == False\nassert check_consecutive([1, 2, 4, 5]) == False\nassert check_consecutive([1, 2, 3, 5]) == False\nassert check_consecutive([1, 2, 3, 4, 6]) == False"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(tuple_list1, tuple_list2):\n    \"\"\"\n    Find the tuple intersection of elements in the given tuple list irrespective of their order.\n\n    Args:\n        tuple_list1 (list): The first tuple list.\n        tuple_list2 (list): The second tuple list.\n\n    Returns:\n        set: A set of tuples representing the intersection of the two input lists.\n\n    Raises:\n        TypeError: If either `tuple_list1` or `tuple_list2` is not a list.\n        TypeError: If any element in `tuple_list1` or `tuple_list2` is not a tuple.\n\n    Examples:\n        >>> tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)])\n        {(4, 5), (3, 4), (5, 6)}\n    \"\"\"\n\n    # Check if the input arguments are lists\n    if not isinstance(tuple_list1, list) or not isinstance(tuple_list2, list):\n        raise TypeError(\"Both arguments must be lists.\")\n\n    # Check if each element in the lists is a tuple\n    if not all(isinstance(t, tuple) for t in tuple_list1) or not all(isinstance(t, tuple) for t in tuple_list2):\n        raise TypeError(\"All elements in the lists must be tuples.\")\n\n    # Convert the lists to sets of tuples\n    set1 = set(tuple_list1)\n    set2 = set(tuple_list2)\n\n    # Find the intersection of the sets\n    intersection = set1.intersection(set2)\n\n    return intersection"}
{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a given character in a string with a new character.\n\n    Args:\n        string (str): The input string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace the old character with.\n\n    Returns:\n        str: The modified string with all occurrences of the old character replaced with the new character.\n\n    Raises:\n        TypeError: If the input arguments are not of the correct type.\n\n    Examples:\n        >>> replace_char(\"polygon\",'y','l')\n        'pollgon'\n        >>> replace_char(\"hello\",'l','x')\n        'hexxo'\n    \"\"\"\n    if not isinstance(string, str) or not isinstance(old_char, str) or not isinstance(new_char, str):\n        raise TypeError(\"All input arguments must be strings.\")\n\n    return string.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    \"\"\"\n    Sorts a dictionary by value in descending order.\n\n    Args:\n        dictionary (dict): The dictionary to be sorted.\n\n    Returns:\n        list: A list of tuples representing the sorted dictionary, where each tuple contains a key-value pair.\n\n    Raises:\n        TypeError: If the input is not a dictionary.\n\n    Examples:\n        >>> sort_counter({'Math': 81, 'Physics': 83, 'Chemistry': 87})\n        [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        raise TypeError(\"Input must be a dictionary.\")\n\n    sorted_dict = sorted(dictionary.items(), key=lambda x: x[1], reverse=True)\n    return sorted_dict"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    \"\"\"\n    Calculates the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int: The sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n\n    Examples:\n    >>> big_sum([1, 2, 3])\n    4\n    >>> big_sum([5, 10, 15, 20])\n    25\n    >>> big_sum([-10, 0, 10])\n    0\n    \"\"\"\n\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n\n    largest = float('-inf')\n    smallest = float('inf')\n\n    for num in arr:\n        if num > largest:\n            largest = num\n        if num < smallest:\n            smallest = num\n\n    return largest + smallest"}
{"task_id": "Mbpp/477", "solution": "def convert_to_lower(string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        string (str): The string to be converted.\n\n    Returns:\n        str: The lower case version of the input string.\n\n    Examples:\n        >>> convert_to_lower(\"Hello\")\n        'hello'\n        >>> convert_to_lower(\"WORLD\")\n        'world'\n        >>> convert_to_lower(\"Python\")\n        'python'\n    \"\"\"\n    return string.lower()\n\n\n# Testing the function\nassert convert_to_lower(\"InValid\") == \"invalid\""}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(string):\n    \"\"\"\n    Remove lowercase substrings from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with lowercase substrings removed.\n\n    Examples:\n        >>> remove_lowercase(\"PYTHon\")\n        'PYTH'\n        >>> remove_lowercase(\"Python\")\n        'Python'\n        >>> remove_lowercase(\"pythoN\")\n        'pythoN'\n    \"\"\"\n    # Initialize an empty list to store the uppercase characters\n    uppercase_chars = []\n\n    # Iterate through each character in the string\n    for char in string:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Append the uppercase character to the list\n            uppercase_chars.append(char)\n\n    # Join the uppercase characters to form the modified string\n    modified_string = ''.join(uppercase_chars)\n\n    return modified_string"}
{"task_id": "Mbpp/479", "solution": "def first_digit(number):\n    \"\"\"\n    Finds the first digit of a given number.\n\n    Parameters:\n    number (int): The number for which the first digit needs to be found.\n\n    Returns:\n    int: The first digit of the given number.\n\n    Raises:\n    ValueError: If the input number is not a positive integer.\n\n    Examples:\n    >>> first_digit(123)\n    1\n    >>> first_digit(987654321)\n    9\n    >>> first_digit(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input number must be a positive integer.\n    \"\"\"\n\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input number must be a positive integer.\")\n\n    # Convert the number to a positive integer\n    number = abs(number)\n\n    # Find the first digit by repeatedly dividing the number by 10 until the quotient is less than 10\n    while number >= 10:\n        number //= 10\n\n    return number"}
{"task_id": "Mbpp/554", "solution": "def get_odd_numbers(numbers):\n    \"\"\"\n    Returns a list of odd numbers from the given list of integers.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        list: A list of odd numbers.\n\n    Examples:\n        >>> get_odd_numbers([1, 2, 3, 4, 5, 6])\n        [1, 3, 5]\n        >>> get_odd_numbers([2, 4, 6, 8])\n        []\n        >>> get_odd_numbers([1, 3, 5, 7, 9])\n        [1, 3, 5, 7, 9]\n    \"\"\"\n    odd_numbers = []\n    for number in numbers:\n        if number % 2 != 0:\n            odd_numbers.append(number)\n    return odd_numbers"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    \"\"\"\n    Calculates the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    int: The difference between the sum of cubes and the sum of the first n natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> difference(3)\n    30\n    >>> difference(5)\n    225\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(i for i in range(1, n+1))\n\n    return sum_of_cubes - sum_of_numbers"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    \"\"\"\n    Count the number of pairs whose xor value is odd.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The length of the list.\n\n    Returns:\n    int: The number of pairs whose xor value is odd.\n\n    \"\"\"\n\n    # Initialize a dictionary to store the count of each element in the array\n    count_dict = {}\n\n    # Initialize a variable to store the count of pairs whose xor value is odd\n    count = 0\n\n    # Iterate through each element in the array\n    for i in range(n):\n        # Calculate the xor value of the current element with all the previous elements\n        xor_val = arr[i]\n\n        # Check if the xor value is odd\n        if xor_val % 2 != 0:\n            # Increment the count of pairs whose xor value is odd\n            count += count_dict.get(xor_val, 0)\n\n        # Increment the count of the current element in the dictionary\n        count_dict[xor_val] = count_dict.get(xor_val, 0) + 1\n\n    return count"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    \"\"\"\n    Toggle the case of all characters in a string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with toggled case.\n\n    Examples:\n        >>> toggle_string(\"Python\")\n        'pYTHON'\n        >>> toggle_string(\"Hello, World\")\n        'hELLO, wORLD'\n    \"\"\"\n    return ''.join(char.lower() if char.isupper() else char.upper() for char in string)"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculates the sum of the per-digit difference between two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The sum of the per-digit difference between the two integers.\n\n    Raises:\n        ValueError: If either of the input integers is negative.\n\n    Examples:\n        >>> digit_distance_nums(1, 2)\n        1\n        >>> digit_distance_nums(123, 321)\n        0\n        >>> digit_distance_nums(123, 456)\n        6\n    \"\"\"\n    if num1 < 0 or num2 < 0:\n        raise ValueError(\"Input integers must be non-negative.\")\n\n    num1_digits = [int(digit) for digit in str(num1)]\n    num2_digits = [int(digit) for digit in str(num2)]\n\n    # Pad the shorter list with zeros to make them the same length\n    if len(num1_digits) < len(num2_digits):\n        num1_digits = num1_digits + [0] * (len(num2_digits) - len(num1_digits))\n    elif len(num2_digits) < len(num1_digits):\n        num2_digits = num2_digits + [0] * (len(num1_digits) - len(num2_digits))\n\n    # Calculate the per-digit difference\n    diff_digits = [abs(num1_digits[i] - num2_digits[i]) for i in range(len(num1_digits))]\n\n    # Calculate the sum of the per-digit difference\n    return sum(diff_digits)"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    \"\"\"\n    Finds the sum of the largest contiguous sublist in the given list.\n\n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The length of the input list.\n\n    Returns:\n    int: The sum of the largest contiguous sublist.\n\n    Examples:\n    >>> max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8)\n    7\n    >>> max_sub_array_sum([1, 2, 3, 4, 5], 5)\n    15\n    >>> max_sub_array_sum([-1, -2, -3, -4, -5], 5)\n    -1\n    \"\"\"\n\n    # Initialize variables\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n\n    # Iterate through the list\n    for i in range(1, n):\n        # Update max_ending_here by adding the current element to the previous sublist\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n\n        # Update max_so_far if max_ending_here is greater\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    \"\"\"\n    Find the union of the elements of two given tuples and output them in sorted order.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple containing the union of elements from both input tuples in sorted order.\n\n    Examples:\n        >>> union_elements((3, 4, 5, 6), (5, 7, 4, 10))\n        (3, 4, 5, 6, 7, 10)\n        >>> union_elements((), (1, 2, 3))\n        (1, 2, 3)\n        >>> union_elements((1, 2, 3), ())\n        (1, 2, 3)\n    \"\"\"\n    # Convert tuples to sets to remove duplicates and then back to tuples\n    union_set = set(tuple1 + tuple2)\n    union_tuple = tuple(sorted(union_set))\n    return union_tuple"}
{"task_id": "Mbpp/562", "solution": "def find_max_length(lst):\n    \"\"\"\n    Find the length of the longest sublists in a given list.\n\n    Args:\n        lst (list): A list of sublists.\n\n    Returns:\n        int: The length of the longest sublist.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> find_max_length([[1], [1, 4], [5, 6, 7, 8]])\n        4\n        >>> find_max_length([[1, 2, 3], [4, 5], [6, 7, 8, 9, 10]])\n        5\n        >>> find_max_length([])\n        ValueError: Input list is empty.\n        >>> find_max_length(1)\n        TypeError: Input must be a list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if not lst:\n        raise ValueError(\"Input list is empty.\")\n\n    return max(len(sublist) for sublist in lst)"}
{"task_id": "Mbpp/563", "solution": "def extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of values extracted from the string.\n\n    Raises:\n        ValueError: If the input string is empty or does not contain any quotation marks.\n\n    Examples:\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n        >>> extract_values('\"Python\"')\n        ['Python']\n        >>> extract_values('\"Python\", \"PHP\"')\n        ['Python', 'PHP']\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n        >>> extract_values('\"Python\", \"PHP\", \"Java\"')\n        ['Python', 'PHP', 'Java']\n        >>> extract_values('')\n        Traceback (most recent call last):\n        ...\n        ValueError: Input string is empty.\n        >>> extract_values('Hello, world')\n        Traceback (most recent call last):\n        ...\n        ValueError: Input string does not contain any quotation marks.\n    \"\"\"\n    if not string:\n        raise ValueError(\"Input string is empty.\")\n\n    if '\"' not in string:\n        raise ValueError(\"Input string does not contain any quotation marks.\")\n\n    values = []\n    start_index = 0\n    while True:\n        start_index = string.find('\"', start_index)\n        if start_index == -1:\n            break\n        end_index = string.find('\"', start_index + 1)\n        if end_index == -1:\n            break\n        value = string[start_index + 1:end_index]\n        values.append(value)\n        start_index = end_index + 1\n\n    return values"}
{"task_id": "Mbpp/564", "solution": "def count_pairs(lst, n):\n    \"\"\"\n    Counts the number of possible unordered pairs where both elements are unequal.\n\n    Args:\n        lst (list): A list of integers.\n        n (int): The length of the list.\n\n    Returns:\n        int: The number of possible unordered pairs.\n\n    Raises:\n        ValueError: If the length of the list is less than 2.\n\n    Examples:\n        >>> count_pairs([1, 2, 1], 3)\n        2\n        >>> count_pairs([1, 2, 3, 4, 5], 5)\n        10\n        >>> count_pairs([1, 1, 1, 1], 4)\n        0\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"List length must be at least 2.\")\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] != lst[j]:\n                count += 1\n\n    return count"}
{"task_id": "Mbpp/565", "solution": "def split_string(string):\n    \"\"\"\n    Split a string into characters.\n\n    Args:\n        string (str): The string to be split.\n\n    Returns:\n        list: A list of characters from the input string.\n\n    Examples:\n        >>> split_string('python')\n        ['p', 'y', 't', 'h', 'o', 'n']\n        >>> split_string('')\n        []\n        >>> split_string('12345')\n        ['1', '2', '3', '4', '5']\n    \"\"\"\n    return list(string)\n\n# Testing the function\nassert split_string('python') == ['p', 'y', 't', 'h', 'o', 'n']\nassert split_string('') == []\nassert split_string('12345') == ['1', '2', '3', '4', '5']"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculates the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): The non-negative integer for which the sum of digits needs to be calculated.\n\n    Returns:\n    int: The sum of the digits of the given non-negative integer.\n\n    Raises:\n    ValueError: If the input is a negative integer.\n\n    Examples:\n    >>> sum_digits(345)\n    12\n    >>> sum_digits(0)\n    0\n    >>> sum_digits(12345)\n    15\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    digit_sum = 0\n    while n > 0:\n        digit_sum += n % 10\n        n //= 10\n\n    return digit_sum"}
{"task_id": "Mbpp/567", "solution": "def is_sorted_list(lst):\n    \"\"\"\n    Check whether a specified list is sorted or not.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted in ascending order, False otherwise.\n    \"\"\"\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\n# Testing the function\nassert is_sorted_list([1,2,4,6,8,10,12,14,16,17]) == True\nassert is_sorted_list([1,2,4,6,8,10,12,14,16,15]) == False"}
{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Args:\n        n (int): The number of empty dictionaries to create.\n\n    Returns:\n        list: A list of N empty dictionaries.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Examples:\n        >>> empty_list(5)\n        [{}, {}, {}, {}, {}]\n\n        >>> empty_list(0)\n        []\n\n        >>> empty_list(-1)\n        Traceback (most recent call last):\n        ...\n        ValueError: n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return [{} for _ in range(n)]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        lst (list): A list of lists, where each sublist contains strings.\n\n    Returns:\n        list: A new list with each sublist sorted in ascending order.\n\n    Examples:\n        >>> sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])\n        [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n    \"\"\"\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/572", "solution": "def remove_duplicates(num_lists):\n    \"\"\"\n    Remove duplicate numbers from a given number of lists.\n\n    Args:\n        num_lists (list): A list of lists containing numbers.\n\n    Returns:\n        list: A new list containing unique numbers from all the input lists.\n\n    Examples:\n        >>> remove_duplicates([[1, 2, 3, 2, 3, 4, 5], [2, 3, 4, 5, 6, 7]])\n        [1, 6, 7]\n        >>> remove_duplicates([[1, 2, 3], [4, 5, 6]])\n        [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    unique_nums = set()\n    for num_list in num_lists:\n        unique_nums.update(num_list)\n    return list(unique_nums)\n\n\n# Testing the function\nassert remove_duplicates([[1, 2, 3, 2, 3, 4, 5], [2, 3, 4, 5, 6, 7]]) == [1, 6, 7]\nassert remove_duplicates([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]"}
{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The product of the unique numbers in the list.\n\n    Raises:\n        ValueError: If the input is not a list or if the list is empty.\n\n    Examples:\n        >>> unique_product([10, 20, 30, 40, 20, 50, 60, 40])\n        720000000\n        >>> unique_product([])\n        Traceback (most recent call last):\n        ...\n        ValueError: The input list is empty.\n        >>> unique_product(\"not a list\")\n        Traceback (most recent call last):\n        ...\n        ValueError: The input must be a list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"The input must be a list.\")\n\n    if not numbers:\n        raise ValueError(\"The input list is empty.\")\n\n    unique_numbers = set(numbers)\n    product = 1\n    for number in unique_numbers:\n        product *= number\n\n    return product"}
{"task_id": "Mbpp/576", "solution": "def is_sub_array(arr, sub_arr):\n    \"\"\"\n    Check if a list is a sublist of another list.\n\n    Parameters:\n    arr (list): The main list.\n    sub_arr (list): The sublist to be checked.\n\n    Returns:\n    bool: True if sub_arr is a sublist of arr, False otherwise.\n    \"\"\"\n    if len(sub_arr) == 0:\n        return True\n\n    if len(arr) < len(sub_arr):\n        return False\n\n    for i in range(len(arr)):\n        if arr[i] == sub_arr[0]:\n            if arr[i:i+len(sub_arr)] == sub_arr:\n                return True\n\n    return False\n\n# Test cases\nassert is_sub_array([1, 4, 3, 5], [1, 2]) == False\nassert is_sub_array([1, 2, 3, 4, 5], [2, 3]) == True\nassert is_sub_array([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == True\nassert is_sub_array([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]) == False\nassert is_sub_array([1, 2, 3, 4, 5], []) == True"}
{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    Calculates the last digit of the factorial of a given number.\n\n    Parameters:\n    n (int): The number for which the last digit of the factorial needs to be calculated.\n\n    Returns:\n    int: The last digit of the factorial of the given number.\n\n    Raises:\n    ValueError: If the input number is negative.\n\n    Examples:\n    >>> last_digit_factorial(4)\n    4\n    >>> last_digit_factorial(10)\n    0\n    >>> last_digit_factorial(15)\n    0\n    >>> last_digit_factorial(20)\n    0\n    >>> last_digit_factorial(25)\n    0\n    >>> last_digit_factorial(30)\n    0\n    >>> last_digit_factorial(35)\n    0\n    >>> last_digit_factorial(40)\n    0\n    >>> last_digit_factorial(45)\n    0\n    >>> last_digit_factorial(50)\n    0\n    >>> last_digit_factorial(55)\n    0\n    >>> last_digit_factorial(60)\n    0\n    >>> last_digit_factorial(65)\n    0\n    >>> last_digit_factorial(70)\n    0\n    >>> last_digit_factorial(75)\n    0\n    >>> last_digit_factorial(80)\n    0\n    >>> last_digit_factorial(85)\n    0\n    >>> last_digit_factorial(90)\n    0\n    >>> last_digit_factorial(95)\n    0\n    >>> last_digit_factorial(100)\n    0\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"Input number must be non-negative.\")\n\n    # Calculate the last digit of the factorial using the property that the last digit of the factorial is the product of the last digits of the factorial of the individual digits\n    last_digit = 1\n    for i in range(1, n + 1):\n        last_digit = (last_digit * i) % 10\n\n    return last_digit"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to be interleaved.\n        list2 (list): The second list to be interleaved.\n        list3 (list): The third list to be interleaved.\n\n    Returns:\n        list: A single flat list containing the interleaved elements from the input lists.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n\n    Examples:\n        >>> interleave_lists([1, 2, 3], [4, 5, 6], [7, 8, 9])\n        [1, 4, 7, 2, 5, 8, 3, 6, 9]\n\n        >>> interleave_lists([1, 2, 3, 4], [5, 6, 7], [8, 9, 10])\n        ValueError: Input lists must be of the same length.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A tuple containing the dissimilar elements from both input tuples.\n\n    Raises:\n        TypeError: If either `tuple1` or `tuple2` is not a tuple.\n\n    Examples:\n        >>> find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10))\n        (3, 6, 7, 10)\n    \"\"\"\n    if not isinstance(tuple1, tuple) or not isinstance(tuple2, tuple):\n        raise TypeError(\"Both inputs must be tuples.\")\n\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n\n    dissimilar_elements = set1.symmetric_difference(set2)\n\n    return tuple(dissimilar_elements)"}
{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    \"\"\"\n    Extracts even elements from a nested mixed tuple.\n\n    Args:\n        nested_tuple (tuple): The nested mixed tuple.\n\n    Returns:\n        tuple: A new tuple with only the even elements from the nested mixed tuple.\n\n    Examples:\n        >>> extract_even((4, 5, (7, 6, (2, 4)), 6, 8))\n        (4, (6, (2, 4)), 6, 8)\n        >>> extract_even((1, 3, 5, 7, 9))\n        ()\n        >>> extract_even((2, 4, 6, 8))\n        (2, 4, 6, 8)\n    \"\"\"\n    def is_even(num):\n        return num % 2 == 0\n\n    def extract_even_recursive(nested_tuple):\n        result = []\n        for item in nested_tuple:\n            if isinstance(item, tuple):\n                result.append(extract_even_recursive(item))\n            elif is_even(item):\n                result.append(item)\n        return tuple(result)\n\n    return extract_even_recursive(nested_tuple)"}
{"task_id": "Mbpp/581", "solution": "def surface_area(base_edge, height):\n    \"\"\"\n    Calculates the surface area of a square pyramid.\n\n    Parameters:\n    base_edge (float or int): The length of the base edge of the square pyramid.\n    height (float or int): The height of the square pyramid.\n\n    Returns:\n    float: The surface area of the square pyramid.\n\n    Raises:\n    ValueError: If either base_edge or height is negative.\n\n    \"\"\"\n\n    if base_edge < 0 or height < 0:\n        raise ValueError(\"Base edge and height must be positive.\")\n\n    # Calculate the area of the base\n    base_area = base_edge ** 2\n\n    # Calculate the slant height\n    slant_height = (base_edge ** 2 + height ** 2) ** 0.5\n\n    # Calculate the lateral surface area\n    lateral_area = base_edge * slant_height\n\n    # Calculate the total surface area\n    surface_area = base_area + lateral_area\n\n    return surface_area\n\n# Test the function\nassert surface_area(3, 4) == 33"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Calculates the nth Catalan number using a recursive approach.\n\n    Parameters:\n    n (int): The index of the Catalan number to be calculated.\n\n    Returns:\n    int: The nth Catalan number.\n\n    Raises:\n    ValueError: If the input n is negative.\n\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"Input n must be non-negative.\")\n\n    if n == 0 or n == 1:\n        return 1\n\n    # Recursive formula for Catalan numbers\n    catalan_num = (4 * n - 2) * catalan_number(n - 1) // (n + 1)\n\n    return catalan_num"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(items, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n\n    Args:\n        items (list): A list of dictionaries, where each dictionary represents an item with a 'name' and 'price' key.\n        n (int): The number of most expensive items to find.\n\n    Returns:\n        list: A list of dictionaries representing the n most expensive items.\n\n    Raises:\n        ValueError: If the input 'items' is not a list or if any item in the list does not have 'name' and 'price' keys.\n\n    Examples:\n        >>> expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}], 1)\n        [{'name': 'Item-2', 'price': 555.22}]\n        >>> expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}], 2)\n        [{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-1', 'price': 101.1}]\n    \"\"\"\n    if not isinstance(items, list):\n        raise ValueError(\"Input 'items' must be a list.\")\n\n    for item in items:\n        if not isinstance(item, dict) or 'name' not in item or 'price' not in item:\n            raise ValueError(\"Each item in the list must have 'name' and 'price' keys.\")\n\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which the list should be split.\n\n    Returns:\n    list: The modified list with the first part added to the end.\n\n    Raises:\n    IndexError: If the index is out of range.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36],2)\n    [5, 6, 52, 36, 12, 10]\n    >>> split_Arr([1, 2, 3, 4, 5], 0)\n    [1, 2, 3, 4, 5]\n    >>> split_Arr([1, 2, 3, 4, 5], 5)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        raise IndexError(\"Index out of range\")\n\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "solution": "def list_to_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        tuple: The converted tuple.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> list_to_tuple([5, 10, 7, 4, 15, 3])\n        (5, 10, 7, 4, 15, 3)\n        >>> list_to_tuple([])\n        ()\n        >>> list_to_tuple([1, 'a', 3.14, True])\n        (1, 'a', 3.14, True)\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest values in a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The difference between the largest and smallest values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> big_diff([1, 2, 3, 4])\n        3\n        >>> big_diff([10, 20, 30, 40])\n        30\n        >>> big_diff([100, 200, 300, 400])\n        300\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    return max(nums) - min(nums)"}
{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    \"\"\"\n    Finds perfect squares between two given numbers.\n\n    Args:\n        start (int): The starting number.\n        end (int): The ending number.\n\n    Returns:\n        list: A list of perfect squares between the given numbers.\n\n    Raises:\n        ValueError: If the starting number is greater than the ending number.\n\n    Examples:\n        >>> perfect_squares(1, 30)\n        [1, 4, 9, 16, 25]\n        >>> perfect_squares(10, 1)\n        []\n        >>> perfect_squares(1, 1)\n        [1]\n    \"\"\"\n    if start > end:\n        raise ValueError(\"Starting number cannot be greater than the ending number.\")\n\n    squares = []\n    for num in range(start, end + 1):\n        if int(num ** 0.5) ** 2 == num:\n            squares.append(num)\n\n    return squares"}
{"task_id": "Mbpp/590", "solution": "import cmath\ndef polar_rect(r, theta):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n\n    Parameters:\n    r (float): The radius of the polar coordinate.\n    theta (float): The angle of the polar coordinate in radians.\n\n    Returns:\n    tuple: A tuple containing the rectangular coordinates (x, y).\n\n    Raises:\n    ValueError: If r is negative.\n\n    Examples:\n    >>> polar_rect(3, 4)\n    ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n    \"\"\"\n\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n\n    return (x, y)"}
{"task_id": "Mbpp/591", "solution": "def swap_list(lst):\n    \"\"\"\n    Swaps the first and last elements in a list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The modified list with the first and last elements swapped.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> swap_list([12, 35, 9, 56, 24])\n        [24, 35, 9, 56, 12]\n        >>> swap_list([])\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"}
{"task_id": "Mbpp/592", "solution": "def sum_of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    Parameters:\n    n (int): The number of consecutive binomial coefficients to consider.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> sum_of_product(3)\n    15\n    >>> sum_of_product(5)\n    120\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Initialize the sum and the product\n    sum_product = 0\n    product = 1\n\n    # Calculate the sum of the product of consecutive binomial coefficients\n    for i in range(1, n+1):\n        product *= (i * (i+1)) // i\n        sum_product += product\n\n    return sum_product"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    \"\"\"\n    Remove leading zeroes from an IP address.\n\n    Args:\n        ip_address (str): The IP address to be processed.\n\n    Returns:\n        str: The IP address with leading zeroes removed.\n\n    Raises:\n        ValueError: If the input is not a valid IP address.\n\n    Examples:\n        >>> removezero_ip(\"216.08.094.196\")\n        '216.8.94.196'\n        >>> removezero_ip(\"0.0.0.0\")\n        '0.0.0.0'\n        >>> removezero_ip(\"192.168.001.001\")\n        '192.168.1.1'\n    \"\"\"\n    # Split the IP address into its components\n    components = ip_address.split('.')\n\n    # Check if the IP address has exactly four components\n    if len(components) != 4:\n        raise ValueError(\"Invalid IP address\")\n\n    # Remove leading zeroes from each component\n    components = [str(int(component)) for component in components]\n\n    # Reconstruct the IP address with leading zeroes removed\n    ip_address_without_zeroes = '.'.join(components)\n\n    return ip_address_without_zeroes"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(numbers):\n    \"\"\"\n    Find the difference of the first even and first odd number of a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The difference between the first even and first odd number.\n\n    Raises:\n        ValueError: If the list does not contain any even or odd numbers.\n\n    Examples:\n        >>> diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n        3\n        >>> diff_even_odd([2, 4, 6, 8])\n        0\n        >>> diff_even_odd([1, 3, 5, 7])\n        Traceback (most recent call last):\n        ...\n        ValueError: The list does not contain any even or odd numbers.\n    \"\"\"\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    odd_numbers = [num for num in numbers if num % 2 != 0]\n\n    if not even_numbers and not odd_numbers:\n        raise ValueError(\"The list does not contain any even or odd numbers.\")\n\n    return even_numbers[0] - odd_numbers[0]"}
{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(t):\n    \"\"\"\n    Calculates the size in bytes of a given tuple.\n\n    Parameters:\n    t (tuple): The tuple for which the size needs to be calculated.\n\n    Returns:\n    int: The size in bytes of the given tuple.\n\n    Raises:\n    TypeError: If the input is not a tuple.\n\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    # Calculate the size of the tuple\n    size = sys.getsizeof(t)\n\n    # Calculate the size of each element in the tuple\n    for element in t:\n        size += sys.getsizeof(element)\n\n    return size"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n\n    Args:\n        arr1 (list): The first sorted array.\n        arr2 (list): The second sorted array.\n        k (int): The kth element to find.\n\n    Returns:\n        int: The kth element from the merged sorted array.\n\n    Raises:\n        ValueError: If k is out of range.\n\n    \"\"\"\n\n    # Check if k is out of range\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise ValueError(\"k is out of range\")\n\n    # Initialize pointers for arr1 and arr2\n    i, j = 0, 0\n\n    # Initialize the merged array\n    merged = []\n\n    # Merge the two arrays until the kth element is found\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n\n        # Check if the kth element is found\n        if len(merged) == k:\n            return merged[-1]\n\n    # Append the remaining elements from arr1 or arr2\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n\n    # Return the kth element\n    return merged[k - 1]"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\n    \"\"\"\n    Check whether the given number is an Armstrong number or not.\n\n    An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits.\n\n    Args:\n        num (int): The number to be checked.\n\n    Returns:\n        bool: True if the number is an Armstrong number, False otherwise.\n    \"\"\"\n    # Convert the number to a string to count the number of digits\n    num_str = str(num)\n    num_digits = len(num_str)\n\n    # Calculate the sum of each digit raised to the power of the number of digits\n    armstrong_sum = sum(int(digit) ** num_digits for digit in num_str)\n\n    # Check if the sum is equal to the original number\n    if armstrong_sum == num:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculates the sum and average of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> sum_average(10)\n    (55, 5.5)\n    >>> sum_average(0)\n    (0, 0.0)\n    >>> sum_average(-5)\n    Traceback (most recent call last):\n    ...\n    ValueError: n must be a positive integer.\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n\n    # Calculate the average of the first n natural numbers\n    average_n = sum_n / n\n\n    return sum_n, average_n"}
{"task_id": "Mbpp/600", "solution": "def is_even(num):\n    \"\"\"\n    Check whether the given number is even or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is even, False otherwise.\n    \"\"\"\n    return num % 2 == 0\n\n# Test cases\nassert is_even(1) == False\nassert is_even(2) == True\nassert is_even(3) == False\nassert is_even(4) == True\nassert is_even(5) == False\nassert is_even(6) == True\nassert is_even(7) == False\nassert is_even(8) == True\nassert is_even(9) == False\nassert is_even(10) == True"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(string):\n    \"\"\"\n    Find the first repeated character in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The first repeated character in the string, or None if no repeated character is found.\n\n    Examples:\n        >>> first_repeated_char(\"abcabc\")\n        'a'\n        >>> first_repeated_char(\"abcd\")\n        None\n    \"\"\"\n    # Create an empty set to store characters encountered\n    seen = set()\n\n    # Iterate over each character in the string\n    for char in string:\n        # If the character is already in the set, it is a repeated character\n        if char in seen:\n            return char\n        # Add the character to the set\n        seen.add(char)\n\n    # If no repeated character is found, return None\n    return None"}
{"task_id": "Mbpp/603", "solution": "def get_lucid(n):\n    \"\"\"\n    Get all Lucid numbers smaller than or equal to a given integer.\n\n    Parameters:\n    n (int): The upper limit for the Lucid numbers.\n\n    Returns:\n    list: A list of Lucid numbers smaller than or equal to n.\n\n    \"\"\"\n\n    def is_lucid(num):\n        \"\"\"\n        Check if a number is Lucid.\n\n        Parameters:\n        num (int): The number to check.\n\n        Returns:\n        bool: True if the number is Lucid, False otherwise.\n\n        \"\"\"\n        if num == 1:\n            return True\n        elif num % 2 == 0:\n            return False\n        else:\n            return is_lucid(num - 2)\n\n    lucid_numbers = []\n    for i in range(1, n + 1):\n        if is_lucid(i):\n            lucid_numbers.append(i)\n\n    return lucid_numbers\n\n\n# Testing the function\nassert get_lucid(10) == [1, 2, 3, 5, 7]"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    \"\"\"\n    Reverse the order of words in a given string.\n\n    Args:\n        string (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: The input string with the order of words reversed.\n\n    Examples:\n        >>> reverse_words(\"python program\")\n        'program python'\n        >>> reverse_words(\"Hello World\")\n        'World Hello'\n    \"\"\"\n    # Split the string into a list of words\n    words = string.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words back into a string\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string"}
{"task_id": "Mbpp/605", "solution": "def is_prime(n):\n    \"\"\"\n    Check if the given integer is a prime number.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# Test cases\nassert is_prime(13) == True\nassert is_prime(15) == False\nassert is_prime(2) == True\nassert is_prime(1) == False\nassert is_prime(0) == False"}
{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n\n    Parameters:\n    degrees (float): The angle in degrees.\n\n    Returns:\n    float: The angle in radians.\n\n    Raises:\n    ValueError: If the input is not a number.\n\n    Examples:\n    >>> radian_degree(90)\n    1.5707963267948966\n    >>> radian_degree(0)\n    0.0\n    >>> radian_degree(360)\n    6.283185307179586\n    \"\"\"\n    if not isinstance(degrees, (int, float)):\n        raise ValueError(\"Input must be a number.\")\n\n    return degrees * math.pi / 180"}
{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(string, pattern):\n    \"\"\"\n    Searches a string for a regex pattern and returns the matching substring, start index, and end index.\n\n    Args:\n        string (str): The string to search.\n        pattern (str): The regex pattern to match.\n\n    Returns:\n        tuple: A tuple containing the matching substring, start index, and end index.\n\n    Raises:\n        ValueError: If the pattern is not found in the string.\n\n    Examples:\n        >>> find_literals('The quick brown fox jumps over the lazy dog.', 'fox')\n        ('fox', 16, 19)\n        >>> find_literals('The quick brown fox jumps over the lazy dog.', 'cat')\n        Traceback (most recent call last):\n        ...\n        ValueError: Pattern not found in the string.\n    \"\"\"\n    match = re.search(pattern, string)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        raise ValueError(\"Pattern not found in the string.\")"}
{"task_id": "Mbpp/608", "solution": "def bell_number(n):\n    \"\"\"\n    Calculates the nth Bell number using the recursive formula.\n\n    Parameters:\n    n (int): The index of the Bell number to calculate.\n\n    Returns:\n    int: The nth Bell number.\n\n    Raises:\n    ValueError: If n is negative.\n\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    if n == 0 or n == 1:\n        return 1\n\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n\n    return bell[n][0]\n\n\n# Testing the function\nassert bell_number(0) == 1\nassert bell_number(1) == 1\nassert bell_number(2) == 2\nassert bell_number(3) == 5\nassert bell_number(4) == 15\nassert bell_number(5) == 52"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from a given list.\n\n    Args:\n        lst (list): The input list.\n        k (int): The index of the element to be removed.\n\n    Returns:\n        list: A new list with the k'th element removed.\n\n    Raises:\n        IndexError: If the index is out of range.\n\n    Examples:\n        >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n        [1, 1, 3, 4, 4, 5, 1]\n        >>> remove_kth_element([1, 2, 3, 4, 5], 5)\n        Traceback (most recent call last):\n        ...\n        IndexError: list index out of range\n    \"\"\"\n    if k < 0 or k >= len(lst):\n        raise IndexError(\"list index out of range\")\n\n    return lst[:k] + lst[k+1:]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of a matrix.\n\n    Args:\n        matrix (list of lists): The matrix represented as a list of lists.\n        n (int): The index of the column to find the maximum value for.\n\n    Returns:\n        int: The maximum value in the nth column of the matrix.\n\n    Raises:\n        IndexError: If the column index is out of range.\n\n    Examples:\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n        19\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 0)\n        8\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 3)\n        Traceback (most recent call last):\n        ...\n        IndexError: Column index out of range.\n    \"\"\"\n    if n < 0 or n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range.\")\n\n    return max(row[n] for row in matrix)"}
{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    \"\"\"\n    Merge a list of lists into two lists.\n\n    Args:\n        lst (list): A list of lists, where each sublist has two elements.\n\n    Returns:\n        list: A list of two lists, where the first list contains the first element of each sublist,\n              and the second list contains the second element of each sublist.\n\n    Raises:\n        ValueError: If the input list is empty or any sublist has more than two elements.\n\n    Examples:\n        >>> merge([['x', 'y'], ['a', 'b'], ['m', 'n']])\n        [['x', 'a', 'm'], ['y', 'b', 'n']]\n\n        >>> merge([['x', 'y'], ['a', 'b'], ['m', 'n'], ['p', 'q']])\n        ValueError: All sublists must have exactly two elements.\n\n        >>> merge([])\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    for sublist in lst:\n        if len(sublist) != 2:\n            raise ValueError(\"All sublists must have exactly two elements.\")\n\n    return [list(x) for x in zip(*lst)]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    \"\"\"\n    Calculates the cumulative sum of all the values in the given tuple list.\n\n    Args:\n        tuple_list (list): A list of tuples.\n\n    Returns:\n        int: The cumulative sum of all the values in the tuple list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        TypeError: If any element in the list is not a tuple.\n        TypeError: If any element in the tuple is not an integer.\n\n    Examples:\n        >>> cummulative_sum([(1, 3), (5, 6, 7), (2, 6)])\n        30\n        >>> cummulative_sum([(1, 2, 3), (4, 5, 6)])\n        21\n        >>> cummulative_sum([(1, 2), (3, 4), (5, 6)])\n        21\n    \"\"\"\n    if not isinstance(tuple_list, list):\n        raise TypeError(\"Input must be a list.\")\n\n    for element in tuple_list:\n        if not isinstance(element, tuple):\n            raise TypeError(\"All elements in the list must be tuples.\")\n\n    total_sum = 0\n    for tup in tuple_list:\n        for num in tup:\n            if not isinstance(num, int):\n                raise TypeError(\"All elements in the tuple must be integers.\")\n            total_sum += num\n\n    return total_sum"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    \"\"\"\n    Calculates the average value for each tuple in a given tuple of tuples.\n\n    Args:\n        tuples (tuple): A tuple of tuples.\n\n    Returns:\n        list: A list of average values for each tuple.\n\n    Raises:\n        ValueError: If the input is not a tuple of tuples.\n\n    Examples:\n        >>> average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))\n        [30.5, 34.25, 27.0, 23.25]\n    \"\"\"\n    if not isinstance(tuples, tuple):\n        raise ValueError(\"Input must be a tuple of tuples.\")\n\n    averages = []\n    for t in tuples:\n        if not isinstance(t, tuple):\n            raise ValueError(\"Each element in the input must be a tuple.\")\n        averages.append(sum(t) / len(t))\n\n    return averages"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(t1, t2):\n    \"\"\"\n    Perform element-wise modulo operation on two tuples of the same length.\n\n    Args:\n        t1 (tuple): The first tuple.\n        t2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the element-wise modulo of the input tuples.\n\n    Raises:\n        ValueError: If the input tuples are not of the same length.\n\n    Examples:\n        >>> tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5))\n        (0, 4, 5, 1)\n        >>> tuple_modulo((1, 2, 3), (4, 5, 6))\n        (1, 2, 3)\n        >>> tuple_modulo((1, 2, 3), (4, 5))\n        Traceback (most recent call last):\n        ...\n        ValueError: Input tuples must have the same length.\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    return tuple(a % b for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divides two lists element-wise.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list containing the element-wise division of list1 and list2.\n\n    Raises:\n        ValueError: If the lengths of list1 and list2 are not equal.\n\n    Examples:\n        >>> div_list([4, 5, 6], [1, 2, 3])\n        [4.0, 2.5, 2.0]\n        >>> div_list([1, 2, 3], [4, 5, 6])\n        [0.25, 0.4, 0.5]\n        >>> div_list([1, 2, 3], [0, 0, 0])\n        Traceback (most recent call last):\n        ...\n        ZeroDivisionError: division by zero\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"The lengths of list1 and list2 must be equal.\")\n\n    return [x / y for x, y in zip(list1, list2)]"}
{"task_id": "Mbpp/619", "solution": "def move_num(string):\n    \"\"\"\n    Move all the numbers to the end of the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with all the numbers moved to the end.\n\n    Examples:\n        >>> move_num('I1love143you55three3000thousand')\n        'Iloveyouthreethousand1143553000'\n    \"\"\"\n    nums = ''\n    letters = ''\n\n    for char in string:\n        if char.isdigit():\n            nums += char\n        else:\n            letters += char\n\n    return letters + nums"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(nums):\n    \"\"\"\n    Finds the size of the largest subset of a list of numbers where every pair is divisible.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The size of the largest subset.\n\n    Examples:\n        >>> largest_subset([1, 3, 6, 13, 17, 18])\n        4\n        >>> largest_subset([2, 4, 6, 8, 10])\n        5\n        >>> largest_subset([1, 2, 3, 4, 5])\n        1\n    \"\"\"\n\n    def is_divisible(a, b):\n        \"\"\"\n        Checks if two numbers are divisible.\n\n        Args:\n            a (int): The first number.\n            b (int): The second number.\n\n        Returns:\n            bool: True if a and b are divisible, False otherwise.\n        \"\"\"\n        return a % b == 0 or b % a == 0\n\n    def find_subset(start, subset):\n        \"\"\"\n        Recursive function to find the largest subset.\n\n        Args:\n            start (int): The index to start the search from.\n            subset (list): The current subset being built.\n\n        Returns:\n            int: The size of the largest subset.\n        \"\"\"\n        if start == len(nums):\n            return len(subset)\n\n        max_subset_size = 0\n        for i in range(start, len(nums)):\n            if all(is_divisible(nums[i], num) for num in subset):\n                max_subset_size = max(max_subset_size, find_subset(i + 1, subset + [nums[i]]))\n\n        return max_subset_size\n\n    return find_subset(0, [])"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, n):\n    \"\"\"\n    Finds the median of two sorted lists of same size.\n\n    Args:\n        list1 (list): The first sorted list.\n        list2 (list): The second sorted list.\n        n (int): The size of the lists.\n\n    Returns:\n        float: The median of the two lists.\n\n    Raises:\n        ValueError: If the size of the lists is not equal to n.\n\n    \"\"\"\n    if len(list1) != n or len(list2) != n:\n        raise ValueError(\"The size of the lists must be equal to n.\")\n\n    i = 0  # Pointer for list1\n    j = 0  # Pointer for list2\n    count = 0  # Counter for the number of elements considered\n    median1 = 0  # Median of list1\n    median2 = 0  # Median of list2\n\n    while count < n:\n        if list1[i] <= list2[j]:\n            median1 = median2\n            median2 = list1[i]\n            i += 1\n        else:\n            median1 = median2\n            median2 = list2[j]\n            j += 1\n        count += 1\n\n    return (median1 + median2) / 2"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    \"\"\"\n    Compute the n-th power of each number in a list.\n\n    Args:\n        nums (list): A list of numbers.\n        n (int): The power to raise each number to.\n\n    Returns:\n        list: A new list with the n-th power of each number in the original list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> nth_nums([1, 2, 3, 4, 5], 2)\n        [1, 4, 9, 16, 25]\n        >>> nth_nums([2, 4, 6, 8, 10], 3)\n        [8, 64, 216, 512, 1000]\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "solution": "def convert_to_uppercase(string):\n    \"\"\"\n    Convert a given string to uppercase.\n\n    Parameters:\n    string (str): The string to be converted to uppercase.\n\n    Returns:\n    str: The uppercase version of the input string.\n\n    Examples:\n    >>> convert_to_uppercase(\"person\")\n    'PERSON'\n    >>> convert_to_uppercase(\"Hello, Worlds\")\n    'HELLO, WORLDS'\n    >>> convert_to_uppercase(\"12345\")\n    '12345'\n    \"\"\"\n    return string.upper()\n\n# Testing the function\nassert convert_to_uppercase(\"person\") == \"PERSON\"\nassert convert_to_uppercase(\"Hello, Worlds\") == \"HELLO, WORLDS\"\nassert convert_to_uppercase(\"12345\") == \"12345\""}
{"task_id": "Mbpp/626", "solution": "import math\ndef triangle_area(radius):\n    \"\"\"\n    Calculates the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Parameters:\n    radius (float): The radius of the semicircle.\n\n    Returns:\n    float: The area of the largest triangle inscribed in the semicircle.\n    None: If the radius is negative.\n\n    Raises:\n    ValueError: If the radius is not a positive number.\n\n    \"\"\"\n\n    if radius < 0:\n        return None\n\n    if radius == 0:\n        return 0\n\n    if not isinstance(radius, (int, float)):\n        raise ValueError(\"Radius must be a positive number.\")\n\n    # Calculate the height of the triangle\n    height = math.sqrt(radius**2 - (radius/2)**2)\n\n    # Calculate the area of the triangle\n    area = (radius**2) * math.pi / 4\n\n    return area"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces all spaces in the given string with '%20'.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with spaces replaced by '%20'.\n\n    Examples:\n        >>> replace_spaces(\"My Name is Dawood\")\n        'My%20Name%20is%20Dawood'\n        >>> replace_spaces(\"Hello World\")\n        'Hello%20World'\n    \"\"\"\n    return string.replace(\" \", \"%20\")"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    Find even numbers from a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A list of even numbers.\n\n    Examples:\n        >>> find_even_numbers([1, 2, 3, 4, 5])\n        [2, 4]\n        >>> find_even_numbers([2, 4, 6, 8])\n        [2, 4, 6, 8]\n        >>> find_even_numbers([1, 3, 5, 7])\n        []\n    \"\"\"\n    even_numbers = []\n    for number in numbers:\n        if number % 2 == 0:\n            even_numbers.append(number)\n    return even_numbers"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coordinate):\n    \"\"\"\n    Extracts all the adjacent coordinates of the given coordinate tuple.\n\n    Args:\n        coordinate (tuple): A tuple representing the coordinates.\n\n    Returns:\n        list: A list of adjacent coordinates.\n\n    Raises:\n        ValueError: If the input is not a tuple or if the tuple has more than two elements.\n\n    Examples:\n        >>> get_coordinates((3, 4))\n        [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    \"\"\"\n    if not isinstance(coordinate, tuple):\n        raise ValueError(\"Input must be a tuple.\")\n\n    if len(coordinate) != 2:\n        raise ValueError(\"Tuple must have exactly two elements.\")\n\n    x, y = coordinate\n    adjacent_coordinates = []\n\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx != 0 or dy != 0:\n                adjacent_coordinates.append([x + dx, y + dy])\n\n    return adjacent_coordinates"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces whitespaces in a given string with underscores and vice versa.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with whitespaces replaced.\n\n    Examples:\n        >>> replace_spaces('Jumanji The Jungle')\n        'Jumanji_The_Jungle'\n        >>> replace_spaces('Hello_World')\n        'Hello World'\n    \"\"\"\n    return string.replace(' ', '_')"}
{"task_id": "Mbpp/632", "solution": "def move_zeroes(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The modified list with all zeroes moved to the end.\n\n    Examples:\n        >>> move_zeroes([1, 0, 2, 0, 3, 4])\n        [1, 2, 3, 4, 0, 0]\n        >>> move_zeroes([0, 0, 0, 1, 2, 3])\n        [1, 2, 3, 0, 0, 0]\n        >>> move_zeroes([1, 2, 3, 4, 5])\n        [1, 2, 3, 4, 5]\n    \"\"\"\n    # Create a new list to store the non-zero elements\n    non_zero_lst = [num for num in lst if num != 0]\n\n    # Create a new list to store the zero elements\n    zero_lst = [num for num in lst if num == 0]\n\n    # Combine the non-zero and zero lists\n    modified_lst = non_zero_lst + zero_lst\n\n    return modified_lst"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n        nums (list): A list of integers.\n        n (int): The length of the list.\n\n    Returns:\n        int: The sum of XOR of all pairs of numbers in the given list.\n\n    Raises:\n        ValueError: If the length of the list is less than 2.\n\n    Examples:\n        >>> pair_xor_Sum([5, 9, 7, 6], 4)\n        47\n        >>> pair_xor_Sum([1, 2, 3], 3)\n        2\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"List length should be at least 2.\")\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += nums[i] ^ nums[j]\n\n    return xor_sum"}
{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    \"\"\"\n    Sorts the given list using the heap sort algorithm.\n\n    Parameters:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: The sorted list.\n\n    \"\"\"\n\n    def heapify(arr, n, i):\n        \"\"\"\n        Builds a max heap from the given list.\n\n        Parameters:\n        arr (list): The list to be heapified.\n        n (int): The size of the heap.\n        i (int): The index of the current root node.\n\n        \"\"\"\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] < arr[left]:\n            largest = left\n\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    def heap_sort_helper(arr):\n        \"\"\"\n        Sorts the given list using the heap sort algorithm.\n\n        Parameters:\n        arr (list): The list to be sorted.\n\n        \"\"\"\n        n = len(arr)\n\n        # Build a max heap\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n\n        # Extract elements from the heap one by one\n        for i in range(n - 1, 0, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify(arr, i, 0)\n\n    heap_sort_helper(arr)\n    return arr"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(buy_price, sell_price):\n    \"\"\"\n    Check whether the given amount has no profit and no loss.\n\n    Parameters:\n    buy_price (float): The price at which the stock was bought.\n    sell_price (float): The price at which the stock was sold.\n\n    Returns:\n    bool: True if the amount has no profit and no loss, False otherwise.\n    \"\"\"\n    if buy_price == sell_price:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/638", "solution": "def wind_chill(wind_speed, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Parameters:\n    wind_speed (float): The wind speed in km/h.\n    temperature (float): The temperature in celsius.\n\n    Returns:\n    int: The wind chill index rounded to the next integer.\n\n    Raises:\n    ValueError: If the wind speed is greater than 120 km/h or the temperature is less than -273.15 celsius.\n\n    Formula:\n    The wind chill index is calculated using the formula:\n    wind_chill = 13.12 + 0.6215 * temperature - 11.37 * (wind_speed ** 0.16) + 0.3965 * temperature * (wind_speed ** 0.16)\n\n    Example:\n    >>> wind_chill(120, 35)\n    40\n    \"\"\"\n\n    if wind_speed > 120:\n        raise ValueError(\"Wind speed cannot be greater than 120 km/h.\")\n    if temperature < -273.15:\n        raise ValueError(\"Temperature cannot be less than -273.15 celsius.\")\n\n    wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * (wind_speed ** 0.16) + 0.3965 * temperature * (wind_speed ** 0.16)\n    return round(wind_chill_index)"}
{"task_id": "Mbpp/639", "solution": "def sum_name_lengths(names):\n    \"\"\"\n    Calculates the sum of the lengths of names in a given list after removing names that start with a lowercase letter.\n\n    Args:\n        names (list): A list of names.\n\n    Returns:\n        int: The sum of the lengths of the remaining names.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> sum_name_lengths(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith'])\n        16\n        >>> sum_name_lengths(['John', 'Jane', 'Bob'])\n        10\n    \"\"\"\n    if not isinstance(names, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Remove names that start with a lowercase letter\n    names = [name for name in names if not name[0].islower()]\n\n    # Calculate the sum of the lengths of the remaining names\n    total_length = sum(len(name) for name in names)\n\n    return total_length"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Calculates the nth nonagonal number.\n\n    Parameters:\n    n (int): The position of the nonagonal number to be calculated.\n\n    Returns:\n    int: The nth nonagonal number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> is_nonagonal(1)\n    1\n    >>> is_nonagonal(2)\n    11\n    >>> is_nonagonal(3)\n    21\n    >>> is_nonagonal(4)\n    32\n    >>> is_nonagonal(5)\n    45\n    >>> is_nonagonal(6)\n    61\n    >>> is_nonagonal(7)\n    80\n    >>> is_nonagonal(8)\n    102\n    >>> is_nonagonal(9)\n    127\n    >>> is_nonagonal(10)\n    155\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(text):\n    \"\"\"\n    Check if a string contains 'z' except at the start and end of the word.\n\n    Args:\n        text (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string contains 'z' except at the start and end of the word, False otherwise.\n    \"\"\"\n    # Split the text into words\n    words = text.split()\n\n    # Iterate over each word\n    for word in words:\n        # Check if the word has 'z' except at the start and end\n        if word.startswith('z') or word.endswith('z'):\n            continue\n        elif 'z' in word:\n            return True\n\n    return False"}
{"task_id": "Mbpp/644", "solution": "def reverse_array_upto_k(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The reversed array.\n\n    Raises:\n    ValueError: If the given position is out of range.\n\n    Examples:\n    >>> reverse_array_upto_k([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    >>> reverse_array_upto_k([1, 2, 3, 4, 5, 6], 6)\n    [6, 5, 4, 3, 2, 1]\n    >>> reverse_array_upto_k([1, 2, 3, 4, 5, 6], 0)\n    [1, 2, 3, 4, 5, 6]\n    >>> reverse_array_upto_k([1, 2, 3, 4, 5, 6], 7)\n    Traceback (most recent call last):\n    ...\n    ValueError: Position is out of range.\n    \"\"\"\n\n    if k < 0 or k >= len(arr):\n        raise ValueError(\"Position is out of range.\")\n\n    return arr[:k][::-1] + arr[k:]"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        tuple: The resulting tuple with the dictionary added.\n\n    Raises:\n        TypeError: If the input is not a tuple or a dictionary.\n\n    Examples:\n        >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3})\n        (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if not isinstance(dictionary, dict):\n        raise TypeError(\"Input must be a dictionary.\")\n\n    return tup + (dictionary,)"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    \"\"\"\n    Finds the maximum average of a path in a square matrix.\n\n    Args:\n        matrix (list of lists): The square matrix of size N*N, where each cell is associated with a specific cost.\n\n    Returns:\n        float: The maximum average of a path in the matrix.\n\n    Raises:\n        ValueError: If the input matrix is not square or empty.\n\n    \"\"\"\n\n    # Check if the matrix is empty\n    if not matrix:\n        raise ValueError(\"Input matrix is empty.\")\n\n    # Check if the matrix is square\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    if num_rows != num_cols:\n        raise ValueError(\"Input matrix is not square.\")\n\n    # Initialize the dynamic programming table\n    dp = [[0] * num_cols for _ in range(num_rows)]\n\n    # Fill the dynamic programming table\n    for i in range(num_rows):\n        for j in range(num_cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average of a path\n    max_average = dp[num_rows-1][num_cols-1] / (num_rows + num_cols - 1)\n\n    return max_average"}
{"task_id": "Mbpp/722", "solution": "def filter_data(student_data, min_height, min_weight):\n    \"\"\"\n    Filters students based on their height and weight.\n\n    Args:\n        student_data (dict): A dictionary with student names as keys and tuples of height and weight as values.\n        min_height (float): The minimum height required for a student to be included.\n        min_weight (float): The minimum weight required for a student to be included.\n\n    Returns:\n        dict: A dictionary containing only the students that have height and weight above the minimum.\n\n    Examples:\n        >>> filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70)\n        {'Cierra Vega': (6.2, 70)}\n    \"\"\"\n    filtered_data = {}\n    for student, (height, weight) in student_data.items():\n        if height >= min_height and weight >= min_weight:\n            filtered_data[student] = (height, weight)\n    return filtered_data"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    Counts the number of indices where the two input lists have the same values.\n\n    Args:\n        list1 (list): The first input list.\n        list2 (list): The second input list.\n\n    Returns:\n        int: The number of indices where the lists have the same values.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n\n    Examples:\n        >>> count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9])\n        4\n        >>> count_same_pair([1, 2, 3], [4, 5, 6])\n        0\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must be of the same length.\")\n\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    \"\"\"\n    Calculate the sum of all digits of the base to the specified power.\n\n    Parameters:\n    base (int): The base number.\n    power (int): The power to which the base is raised.\n\n    Returns:\n    int: The sum of all digits of the base to the specified power.\n\n    Raises:\n    ValueError: If either base or power is negative.\n\n    Examples:\n    >>> power_base_sum(2, 100)\n    115\n    >>> power_base_sum(3, 4)\n    8\n    >>> power_base_sum(10, 1)\n    1\n    \"\"\"\n\n    if base < 0 or power < 0:\n        raise ValueError(\"Base and power must be non-negative.\")\n\n    result = base ** power\n    digit_sum = sum(int(digit) for digit in str(result))\n    return digit_sum"}
{"task_id": "Mbpp/725", "solution": "def extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        list: A list of strings containing the values between quotation marks.\n\n    Examples:\n        >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n        ['A53', 'multi', 'Processor']\n    \"\"\"\n    import re\n\n    # Use regular expression to find all occurrences of quotation marks and their contents\n    matches = re.findall(r'\"([^\"]*)\"', string)\n\n    return matches"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    \"\"\"\n    Function to multiply adjacent elements in a tuple.\n\n    Args:\n        t (tuple): A tuple of numbers.\n\n    Returns:\n        tuple: A tuple of length N where the i-th element is equal to t_i * t_{i+1}.\n\n    Raises:\n        ValueError: If the input tuple is empty or has only one element.\n\n    Examples:\n        >>> multiply_elements((1, 5, 7, 8, 10))\n        (5, 35, 56, 80)\n        >>> multiply_elements((1,))\n        Traceback (most recent call last):\n        ...\n        ValueError: Input tuple must have at least two elements.\n        >>> multiply_elements(())\n        Traceback (most recent call last):\n        ...\n        ValueError: Input tuple must have at least two elements.\n    \"\"\"\n    if len(t) < 2:\n        raise ValueError(\"Input tuple must have at least two elements.\")\n\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    This function takes two lists as input and returns a new list where each element is the sum of the corresponding elements from the input lists.\n\n    Args:\n        list1 (list): The first input list.\n        list2 (list): The second input list.\n\n    Returns:\n        list: A new list where each element is the sum of the corresponding elements from the input lists.\n\n    Raises:\n        ValueError: If the input lists have different lengths.\n\n    Examples:\n        >>> sum_list([10, 20, 30], [15, 25, 35])\n        [25, 45, 65]\n\n        >>> sum_list([1, 2, 3], [4, 5, 6, 7])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input lists must have the same length.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    \"\"\"\n    Remove consecutive duplicates from a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The list with consecutive duplicates removed.\n\n    Examples:\n        >>> consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the input list\n    for item in lst:\n        # If the result list is empty or the current item is not a duplicate of the last item in the result list,\n        # append the current item to the result list\n        if not result or item != result[-1]:\n            result.append(item)\n\n    return result"}
{"task_id": "Mbpp/731", "solution": "import math"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in the given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with all special characters replaced by colons.\n\n    Examples:\n        >>> replace_specialchar('Python language, Programming language.')\n        'Python:language::Programming:language:'\n    \"\"\"\n    # Replace spaces, commas, and dots with colons\n    modified_string = string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")\n\n    return modified_string"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    \"\"\"\n    Find the index of the first occurrence of a given number in a sorted array.\n\n    Args:\n        arr (list): A sorted list of integers.\n        target (int): The number to find the first occurrence of.\n\n    Returns:\n        int: The index of the first occurrence of the target number in the array.\n            Returns -1 if the target number is not found.\n\n    Examples:\n        >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5)\n        1\n        >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 6)\n        4\n        >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 9)\n        6\n        >>> find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 1)\n        -1\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1"}
{"task_id": "Mbpp/734", "solution": "def sum_of_subarray_prod(lst):\n    \"\"\"\n    Calculates the sum of products of all possible sublists of a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The sum of products of all possible sublists.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> sum_of_subarray_prod([1, 2, 3])\n        20\n        >>> sum_of_subarray_prod([4, 5, 6])\n        180\n        >>> sum_of_subarray_prod([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    n = len(lst)\n    total_sum = 0\n\n    for i in range(n):\n        sublist_product = 1\n        for j in range(i, n):\n            sublist_product *= lst[j]\n            total_sum += sublist_product\n\n    return total_sum"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(num):\n    \"\"\"\n    Toggle bits of the number except the first and the last bit.\n\n    Args:\n        num (int): The number for which the middle bits need to be toggled.\n\n    Returns:\n        int: The number with toggled middle bits.\n\n    Raises:\n        ValueError: If the number is negative.\n\n    Examples:\n        >>> toggle_middle_bits(9)\n        15\n        >>> toggle_middle_bits(10)\n        14\n        >>> toggle_middle_bits(15)\n        15\n        >>> toggle_middle_bits(0)\n        0\n        >>> toggle_middle_bits(-1)\n        ValueError: Number must be non-negative.\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Number must be non-negative.\")\n\n    # Count the number of bits in the number\n    num_bits = num.bit_length()\n\n    # If the number is 0 or 1, no bits need to be toggled\n    if num_bits <= 1:\n        return num\n\n    # Calculate the mask to toggle the middle bits\n    mask = (1 << (num_bits - 2)) - 1\n\n    # Toggle the middle bits using bitwise XOR\n    toggled_num = num ^ mask\n\n    return toggled_num"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, value):\n    \"\"\"\n    Find the left insertion point for a specified value in a sorted list.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    value (int): The value to be inserted.\n\n    Returns:\n    int: The index of the left insertion point.\n\n    Raises:\n    ValueError: If the input list is not sorted.\n\n    Examples:\n    >>> left_insertion([1,2,4,5], 6)\n    4\n    >>> left_insertion([1,2,4,5], 3)\n    2\n    >>> left_insertion([1,2,4,5], 1)\n    0\n    >>> left_insertion([1,2,4,5], 5)\n    3\n    \"\"\"\n\n    # Check if the list is sorted\n    if arr != sorted(arr):\n        raise ValueError(\"Input list is not sorted.\")\n\n    # Perform binary search to find the left insertion point\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left"}
{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(string):\n    \"\"\"\n    Check whether the given string starts with a vowel or not using regex.\n\n    Args:\n        string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    pattern = r'^[aeiouAEIOU].*'\n    return bool(re.match(pattern, string))"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Find the index of the smallest triangular number with n digits.\n\n    Parameters:\n    n (int): The number of digits in the triangular number.\n\n    Returns:\n    int: The index of the smallest triangular number with n digits.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Initialize variables\n    index = 1\n    triangular_number = 1\n\n    # Generate triangular numbers until we find one with n digits\n    while len(str(triangular_number)) < n:\n        index += 1\n        triangular_number += index\n\n    return index"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        dict: A dictionary with adjacent elements as keys and values.\n\n    Raises:\n        ValueError: If the length of the tuple is odd.\n\n    Examples:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n\n        >>> tuple_to_dict(())\n        {}\n\n        >>> tuple_to_dict((1, 2, 3))\n        Traceback (most recent call last):\n        ...\n        ValueError: Tuple length must be even.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple length must be even.\")\n\n    return dict(zip(tup[::2], tup[1::2]))"}
{"task_id": "Mbpp/741", "solution": "def all_characters_same(string):\n    \"\"\"\n    Check if all characters in a string are the same.\n\n    Args:\n        string (str): The input string to check.\n\n    Returns:\n        bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    # Check if the string is empty or has only one character\n    if len(string) < 2:\n        return True\n\n    # Get the first character\n    first_char = string[0]\n\n    # Iterate through the remaining characters in the string\n    for char in string[1:]:\n        # If any character is different from the first character, return False\n        if char != first_char:\n            return False\n\n    # If all characters are the same, return True\n    return True\n\n# Test cases\nassert all_characters_same(\"python\") == False\nassert all_characters_same(\"aaaaa\") == True\nassert all_characters_same(\"\") == True\nassert all_characters_same(\"a\") == True"}
{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(side_length):\n    \"\"\"\n    Calculates the area of a tetrahedron.\n\n    Parameters:\n    side_length (float or int): The length of the side of the tetrahedron.\n\n    Returns:\n    float: The area of the tetrahedron.\n\n    Raises:\n    ValueError: If the side length is not a positive number.\n\n    \"\"\"\n\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    # Calculate the area of a square with side length 'side_length'\n    square_area = side_length ** 2\n\n    # Calculate the height of the tetrahedron\n    height = side_length / (2 * math.sqrt(3))\n\n    # Calculate the area of the base triangle\n    base_area = (math.sqrt(3) / 4) * square_area\n\n    # Calculate the area of the lateral triangles\n    lateral_area = (math.sqrt(3) / 4) * square_area * 3\n\n    # Calculate the total area of the tetrahedron\n    total_area = base_area + lateral_area\n\n    return total_area"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n\n    Args:\n        lst (list): The list to be rotated.\n        n (int): The number of items to rotate.\n\n    Returns:\n        list: The rotated list.\n\n    Raises:\n        ValueError: If the number of items to rotate is greater than the length of the list.\n\n    Examples:\n        >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)\n        [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n        >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        >>> rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11)\n        Traceback (most recent call last):\n        ...\n        ValueError: Number of items to rotate cannot be greater than the length of the list.\n    \"\"\"\n    if n > len(lst):\n        raise ValueError(\"Number of items to rotate cannot be greater than the length of the list.\")\n\n    return lst[-n:] + lst[:-n]"}
{"task_id": "Mbpp/744", "solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any none value or not.\n\n    Args:\n        tup (tuple): The tuple to be checked.\n\n    Returns:\n        bool: True if the tuple has any none value, False otherwise.\n    \"\"\"\n    return None in tup"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    \"\"\"\n    Find numbers within a given range from startnum to endnum where every number is divisible by every digit it contains.\n\n    Args:\n        startnum (int): The starting number of the range.\n        endnum (int): The ending number of the range.\n\n    Returns:\n        list: A list of numbers within the given range that are divisible by every digit they contain.\n\n    Raises:\n        ValueError: If startnum is greater than endnum.\n\n    Examples:\n        >>> divisible_by_digits(1, 22)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n    \"\"\"\n\n    if startnum > endnum:\n        raise ValueError(\"startnum must be less than or equal to endnum.\")\n\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = set(int(digit) for digit in str(num))\n        if all(num % digit == 0 for digit in digits):\n            result.append(num)\n\n    return result"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(string):\n    \"\"\"\n    Function to put spaces between words starting with capital letters in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The modified string with spaces between words starting with capital letters.\n\n    Examples:\n        >>> capital_words_spaces(\"Python\")\n        'Python'\n        >>> capital_words_spaces(\"PythonIsAwesome\")\n        'Python Is Awesome'\n        >>> capital_words_spaces(\"PythonIsAwesomeProgrammingLanguage\")\n        'Python Is Awesome Programming Language'\n    \"\"\"\n    # Split the string into words\n    words = string.split()\n\n    # Iterate over each word\n    for i in range(len(words)):\n        # Check if the word starts with a capital letter\n        if words[i][0].isupper():\n            # Insert a space before the word\n            words[i] = \" \" + words[i]\n\n    # Join the words back into a string\n    modified_string = \"\".join(words)\n\n    return modified_string"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(num_list):\n    \"\"\"\n    Sorts a given list of strings of numbers numerically.\n\n    Args:\n        num_list (list): A list of strings representing numbers.\n\n    Returns:\n        list: A new list with the same elements as the input list, but sorted numerically.\n\n    Raises:\n        ValueError: If any element in the input list is not a valid number.\n\n    Examples:\n        >>> sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500'])\n        [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n    \"\"\"\n    try:\n        # Convert the strings to numbers and sort them\n        sorted_nums = sorted(map(int, num_list))\n        return sorted_nums\n    except ValueError:\n        raise ValueError(\"Invalid number found in the input list.\")"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Args:\n        lst (list): The list to which the tuple will be added.\n        tup (tuple): The tuple to be added to the list.\n\n    Returns:\n        list: The updated list with the tuple added.\n\n    Raises:\n        TypeError: If the input arguments are not of the correct type.\n\n    Examples:\n        >>> add_tuple([5, 6, 7], (9, 10))\n        [5, 6, 7, 9, 10]\n        >>> add_tuple([], (1, 2, 3))\n        [1, 2, 3]\n        >>> add_tuple([1, 2, 3], ())\n        [1, 2, 3]\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(tup, tuple):\n        raise TypeError(\"The second argument must be a tuple.\")\n\n    return lst + list(tup)"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    \"\"\"\n    Check if the given array represents a min heap.\n\n    Parameters:\n    arr (list): The input array to be checked.\n\n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    # Helper function to check if a node is a valid min heap\n    def is_min_heap(arr, i, n):\n        # If the node is a leaf node, it is a valid min heap\n        if i >= (n // 2) - 1:\n            return True\n\n        # If the node has two children and both are valid min heaps\n        if (arr[i] <= arr[2 * i + 1] and\n                arr[i] <= arr[2 * i + 2] and\n                is_min_heap(arr, 2 * i + 1, n) and\n                is_min_heap(arr, 2 * i + 2, n)):\n            return True\n\n        return False\n\n    # Check if the array is empty or has only one element\n    if len(arr) == 0 or len(arr) == 1:\n        return True\n\n    # Check if the array represents a valid min heap\n    return is_min_heap(arr, 0, len(arr))"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    Calculates the nth Jacobsthal number.\n\n    Parameters:\n    n (int): The index of the Jacobsthal number to be calculated.\n\n    Returns:\n    int: The nth Jacobsthal number.\n\n    Raises:\n    ValueError: If n is negative.\n\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return 2 * jacobsthal_num(n - 1) + 3 * jacobsthal_num(n - 2)"}
{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records (list): A list of tuples, where each tuple contains a name and a value.\n        k (int): The number of minimum records to find.\n\n    Returns:\n        list: A list of tuples containing the minimum k records.\n\n    Raises:\n        ValueError: If k is greater than the number of records.\n\n    Examples:\n        >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n        [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    if k > len(records):\n        raise ValueError(\"k cannot be greater than the number of records.\")\n\n    sorted_records = sorted(records, key=lambda x: x[1])\n    return sorted_records[:k]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts common elements from three lists based on their indices.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list containing the common elements from the three lists.\n\n    Raises:\n        ValueError: If the input lists have different lengths.\n\n    Examples:\n        >>> extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])\n        [1, 7]\n        >>> extract_index_list([1, 2, 3], [4, 5, 6], [7, 8, 9])\n        []\n    \"\"\"\n    if len(l1) != len(l2) or len(l1) != len(l3):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    common_elements = []\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The second smallest number in the list.\n\n    Raises:\n        ValueError: If the list has less than two elements.\n\n    Examples:\n        >>> second_smallest([1, 2, -8, -2, 0, -2])\n        -2\n        >>> second_smallest([1, 1, 1, 1])\n        Traceback (most recent call last):\n        ...\n        ValueError: List must have at least two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements.\")\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n\n    Args:\n        string_list (list): A list of strings.\n\n    Returns:\n        int: The number of pairs of reverse strings.\n\n    Examples:\n        >>> count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])\n        2\n        >>> count_reverse_pairs([\"hello\", \"world\", \"python\", \"programming\"])\n        0\n    \"\"\"\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the number of occurrences of each unique sublist in a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        dict: A dictionary where the keys are tuples representing unique sublists,\n              and the values are the number of occurrences of each sublist.\n\n    Examples:\n        >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n        {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    sublist_counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    return sublist_counts"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(string):\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n\n    Args:\n        string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string is a decimal number with a precision of 2, False otherwise.\n    \"\"\"\n    try:\n        # Convert the string to a float\n        num = float(string)\n\n        # Check if the number has a precision of 2\n        if num.is_integer():\n            return False\n\n        # Check if the number has a precision of 2\n        if len(str(num).split('.')[1]) == 2:\n            return True\n\n        return False\n\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/760", "solution": "def unique_element(nums):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Create a set from the list to remove duplicates\n    unique_nums = set(nums)\n\n    # If the length of the set is 1, then all elements are distinct\n    if len(unique_nums) == 1:\n        return True\n    else:\n        return False\n\n# Test cases\nassert unique_element([1, 1, 1]) == True\nassert unique_element([1, 2, 3]) == False\nassert unique_element([1, 1, 2, 2, 3, 3]) == False\nassert unique_element([1]) == True\nassert unique_element([]) == False"}
{"task_id": "Mbpp/762", "solution": "def check_month_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n\n    Args:\n        month_number (int): The month number to be checked.\n\n    Returns:\n        bool: True if the month number contains 30 days, False otherwise.\n\n    Raises:\n        ValueError: If the month number is not between 1 and 12.\n\n    Examples:\n        >>> check_month_number(6)\n        True\n        >>> check_month_number(12)\n        False\n        >>> check_month_number(13)\n        Traceback (most recent call last):\n        ...\n        ValueError: Month number should be between 1 and 12.\n    \"\"\"\n    if month_number < 1 or month_number > 12:\n        raise ValueError(\"Month number should be between 1 and 12.\")\n\n    if month_number in [4, 6, 9, 11]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    \"\"\"\n    Find the minimum difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): The input array of integers.\n    n (int): The size of the array.\n\n    Returns:\n    int: The minimum difference between any two elements in the array.\n\n    Raises:\n    ValueError: If the array is empty or has less than two elements.\n\n    \"\"\"\n\n    if n < 2:\n        raise ValueError(\"Array must have at least two elements.\")\n\n    arr = sorted(arr)\n    min_diff = float('inf')\n\n    for i in range(n - 1):\n        diff = arr[i+1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The number of digits in the string.\n\n    Examples:\n        >>> number_ctr('program2bedone')\n        1\n        >>> number_ctr('12345')\n        5\n        >>> number_ctr('abcdefg')\n        0\n    \"\"\"\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n\n    A polite number is a number that is divisible by the sum of its digits.\n\n    Args:\n        n (int): The position of the polite number to find.\n\n    Returns:\n        int: The nth polite number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Examples:\n        >>> is_polite(7)\n        11\n        >>> is_polite(10)\n        101\n        >>> is_polite(15)\n        105\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if num % sum(int(digit) for digit in str(num)) == 0:\n            count += 1\n\n    return num"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: A list of tuples, where each tuple contains two consecutive items from the input list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n\n        >>> pair_wise([])\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(nums, target_sum):\n    \"\"\"\n    Count the number of pairs whose sum is equal to the target sum.\n\n    Args:\n        nums (list): A list of numbers.\n        target_sum (int): The target sum.\n\n    Returns:\n        int: The number of pairs whose sum is equal to the target sum.\n\n    Raises:\n        TypeError: If the input `nums` is not a list.\n        TypeError: If the input `target_sum` is not an integer.\n\n    Examples:\n        >>> get_pairs_count([1, 1, 1, 1], 2)\n        6\n        >>> get_pairs_count([1, 2, 3, 4, 5], 5)\n        2\n        >>> get_pairs_count([1, 2, 3, 4, 5], 10)\n        0\n    \"\"\"\n\n    if not isinstance(nums, list):\n        raise TypeError(\"Input 'nums' must be a list.\")\n\n    if not isinstance(target_sum, int):\n        raise TypeError(\"Input 'target_sum' must be an integer.\")\n\n    count = 0\n    num_counts = {}\n\n    for num in nums:\n        complement = target_sum - num\n        if complement in num_counts:\n            count += num_counts[complement]\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    return count"}
{"task_id": "Mbpp/769", "solution": "def get_difference(list1, list2):\n    \"\"\"\n    Get the difference between two lists.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list containing the elements that are present in list1 but not in list2.\n\n    Examples:\n        >>> get_difference([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])\n        [10, 20, 30, 15]\n    \"\"\"\n    return [item for item in list1 if item not in list2]\n\n\n# Testing the function\nassert get_difference([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]) == [10, 20, 30, 15]"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculates the sum of the fourth power of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the fourth power of the first n odd natural numbers.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Examples:\n    >>> odd_num_sum(2)\n    82\n    >>> odd_num_sum(3)\n    202\n    >>> odd_num_sum(4)\n    422\n    \"\"\"\n\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Calculate the sum of the fourth power of the first n odd natural numbers\n    sum_of_fourth_power = 0\n    for i in range(1, n + 1):\n        sum_of_fourth_power += (2 * i - 1) ** 4\n\n    return sum_of_fourth_power"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    \"\"\"\n    Check if the given expression is balanced or not.\n\n    Args:\n        expression (str): The expression to be checked.\n\n    Returns:\n        bool: True if the expression is balanced, False otherwise.\n\n    Raises:\n        ValueError: If the expression contains invalid characters.\n\n    Examples:\n        >>> check_expression(\"{()}[{}]\")\n        True\n        >>> check_expression(\"{()}[{]\")\n        False\n        >>> check_expression(\"{()}[{]\")\n        False\n    \"\"\"\n\n    # Check if the expression is empty\n    if not expression:\n        return True\n\n    # Check if the expression has odd length\n    if len(expression) % 2 != 0:\n        return False\n\n    # Create a dictionary to map opening brackets to closing brackets\n    brackets = {\n        '(': ')',\n        '{': '}',\n        '[': ']'\n    }\n\n    # Create a stack to keep track of opening brackets\n    stack = []\n\n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in brackets:\n            stack.append(char)\n        # If the character is a closing bracket, check if it matches the top of the stack\n        elif char in brackets.values():\n            # If the stack is empty or the closing bracket doesn't match the top of the stack, return False\n            if not stack or char != brackets[stack.pop()]:\n                return False\n\n    # If the stack is not empty, return False\n    if stack:\n        return False\n\n    # If all checks pass, return True\n    return True"}
{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    \"\"\"\n    Remove all words with length k from the given string.\n\n    Args:\n        string (str): The input string.\n        k (int): The length of words to be removed.\n\n    Returns:\n        str: The modified string with words of length k removed.\n\n    Examples:\n        >>> remove_length('The person is most value tet', 3)\n        'person is most value'\n    \"\"\"\n    words = string.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)"}
{"task_id": "Mbpp/773", "solution": "def find_occurrence_substring(string, substring):\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n\n    Args:\n        string (str): The input string to search for the substring.\n        substring (str): The substring to search for within the string.\n\n    Returns:\n        tuple: A tuple containing the substring, the starting index of the first occurrence, and the ending index of the last occurrence.\n               If there is no match, returns None.\n\n    Examples:\n        >>> find_occurrence_substring('python programming, python language', 'python')\n        ('python', 0, 6)\n        >>> find_occurrence_substring('python programming, python language', 'java')\n        None\n    \"\"\"\n    if substring in string:\n        start_index = string.index(substring)\n        end_index = start_index + len(substring) - 1\n        return substring, start_index, end_index\n    else:\n        return None"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Args:\n        lst (list): The input list to be checked.\n\n    Returns:\n        bool: True if every odd index contains odd numbers, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of non-repeated elements in the list.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the list contains non-integer elements.\n\n    Examples:\n        >>> find_sum([1, 2, 3, 1, 1, 4, 5, 6])\n        21\n        >>> find_sum([1, 1, 1, 1, 1])\n        1\n        >>> find_sum([1, 2, 3, 4, 5])\n        15\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if not all(isinstance(x, int) for x in lst):\n        raise ValueError(\"List must contain only integers.\")\n\n    return sum(set(lst))"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    \"\"\"\n    Packs consecutive duplicates of a given list elements into sublists.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: A list of sublists, where each sublist contains consecutive duplicates of the input list elements.\n\n    Examples:\n        >>> pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])\n        [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n    \"\"\"\n    result = []\n    current_sublist = []\n\n    for i in range(len(lst)):\n        if i == 0 or lst[i] == lst[i-1]:\n            current_sublist.append(lst[i])\n        else:\n            result.append(current_sublist)\n            current_sublist = [lst[i]]\n\n    result.append(current_sublist)\n\n    return result"}
{"task_id": "Mbpp/780", "solution": "def find_combinations(tuple_list):\n    \"\"\"\n    Finds all combinations of sums with tuples in the given tuple list.\n\n    Args:\n        tuple_list (list): A list of tuples.\n\n    Returns:\n        list: A list of tuples representing the combinations of sums.\n\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)])\n        [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n    \"\"\"\n    if not isinstance(tuple_list, list):\n        raise TypeError(\"Input must be a list.\")\n    if not tuple_list:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    combinations = []\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            combinations.append((tuple_list[i][0] + tuple_list[j][0], tuple_list[i][1] + tuple_list[j][1]))\n\n    return combinations"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a given number is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    \"\"\"\n    Calculates the sum of all odd length subarrays in a given list.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of all odd length subarrays.\n\n    Examples:\n    >>> odd_length_sum([1, 2, 4])\n    14\n    >>> odd_length_sum([1, 2, 4, 6, 8])\n    44\n    >>> odd_length_sum([1, 2, 4, 6, 8, 10])\n    64\n    \"\"\"\n\n    n = len(arr)\n    total_sum = 0\n\n    # Iterate through each element in the list\n    for i in range(n):\n        # Calculate the number of subarrays that can be formed with the current element\n        subarray_count = (i + 1) * (n - i)\n\n        # If the number of subarrays is odd, add the element to the sum\n        if subarray_count % 2 != 0:\n            total_sum += arr[i]\n\n    return total_sum"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    \"\"\"\n    Find the product of the first even and odd numbers in a given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The product of the first even and odd numbers in the list.\n\n    Raises:\n        ValueError: If the list is empty or does not contain any even or odd numbers.\n\n    Examples:\n        >>> mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8])\n        4\n        >>> mul_even_odd([1, 3, 5, 7])\n        Traceback (most recent call last):\n        ...\n        ValueError: List does not contain any even or odd numbers.\n        >>> mul_even_odd([])\n        Traceback (most recent call last):\n        ...\n        ValueError: List is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty.\")\n\n    even_numbers = [num for num in lst if num % 2 == 0]\n    odd_numbers = [num for num in lst if num % 2 != 0]\n\n    if not even_numbers or not odd_numbers:\n        raise ValueError(\"List does not contain any even or odd numbers.\")\n\n    return even_numbers[0] * odd_numbers[0]"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    \"\"\"\n    Converts a string representation of a tuple to an integer tuple.\n\n    Args:\n        tuple_str (str): A string representation of a tuple.\n\n    Returns:\n        tuple: An integer tuple.\n\n    Raises:\n        ValueError: If the input string is not a valid tuple representation.\n\n    Examples:\n        >>> tuple_str_int(\"(7, 8, 9)\")\n        (7, 8, 9)\n        >>> tuple_str_int(\"(1, 2, 3, 4)\")\n        (1, 2, 3, 4)\n        >>> tuple_str_int(\"(10, 20, 30)\")\n        (10, 20, 30)\n    \"\"\"\n    try:\n        # Remove the parentheses from the string\n        tuple_str = tuple_str.strip(\"()\")\n\n        # Split the string by commas\n        elements = tuple_str.split(\",\")\n\n        # Convert each element to an integer\n        elements = [int(element.strip()) for element in elements]\n\n        # Create a tuple from the list of integers\n        result = tuple(elements)\n\n        return result\n\n    except ValueError:\n        raise ValueError(\"Invalid tuple representation\")"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, target):\n    \"\"\"\n    Find the right insertion point for a specified value in sorted order.\n\n    Parameters:\n    arr (list): A sorted list of integers.\n    target (int): The value to be inserted into the list.\n\n    Returns:\n    int: The index at which the target value should be inserted to maintain sorted order.\n\n    Examples:\n    >>> right_insertion([1,2,4,5], 6)\n    4\n    >>> right_insertion([1,2,4,5], 3)\n    2\n    >>> right_insertion([1,2,4,5], 1)\n    1\n    \"\"\"\n\n    # Initialize left and right pointers\n    left = 0\n    right = len(arr) - 1\n\n    # Binary search to find the right insertion point\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left"}
{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    \"\"\"\n    Check if a string has an 'a' followed by three 'b's.\n\n    Args:\n        text (str): The string to be checked.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'ab{3}'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, str):\n    \"\"\"\n    Create a new tuple from the given string and list.\n\n    Args:\n        lst (list): A list of strings.\n        str (str): A string.\n\n    Returns:\n        tuple: A new tuple containing the elements of the list and the string.\n\n    Examples:\n        >>> new_tuple([\"WEB\", \"is\"], \"best\")\n        ('WEB', 'is', 'best')\n    \"\"\"\n    return tuple(lst) + (str,)"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    \"\"\"\n    Check whether every even index contains even numbers in a given list.\n\n    Args:\n        lst (list): The input list to be checked.\n\n    Returns:\n        bool: True if every even index contains even numbers, False otherwise.\n    \"\"\"\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(tup):\n    \"\"\"\n    Remove tuples from the given tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        tuple: A new tuple with nested tuples removed.\n\n    Examples:\n        >>> remove_nested((1, 5, 7, (4, 6), 10))\n        (1, 5, 7, 10)\n        >>> remove_nested(('a', 'b', ('c', 'd'), 'e'))\n        ('a', 'b', 'e')\n    \"\"\"\n    return tuple(elem for elem in tup if not isinstance(elem, tuple))"}
{"task_id": "Mbpp/792", "solution": "def count_lists(lists):\n    \"\"\"\n    Count the number of lists in a given number of lists.\n\n    Args:\n        lists (list): A list of lists.\n\n    Returns:\n        int: The number of lists in the given list of lists.\n\n    Raises:\n        TypeError: If the input is not a list.\n\n    Examples:\n        >>> count_lists([[1, 3], [5, 7], [9, 11], [13, 15, 17]])\n        4\n        >>> count_lists([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        3\n        >>> count_lists([[1], [2], [3]])\n        3\n    \"\"\"\n    if not isinstance(lists, list):\n        raise TypeError(\"Input must be a list.\")\n\n    count = 0\n    for lst in lists:\n        if isinstance(lst, list):\n            count += 1\n\n    return count"}
{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    \"\"\"\n    Find the last position of an element in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of elements.\n    target: The element to find the last position of.\n\n    Returns:\n    int: The last position of the target element in the array, or -1 if the element is not found.\n\n    Examples:\n    >>> last([1,2,3], 1)\n    0\n    >>> last([1,2,3], 2)\n    1\n    >>> last([1,2,3], 3)\n    2\n    >>> last([1,2,3], 4)\n    -1\n    \"\"\"\n\n    # Perform binary search to find the first occurrence of the target element\n    left = 0\n    right = len(arr) - 1\n    first_pos = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            first_pos = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    # If the target element is not found, return -1\n    if first_pos == -1:\n        return -1\n\n    # Perform binary search to find the last occurrence of the target element\n    left = first_pos\n    right = len(arr) - 1\n    last_pos = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            last_pos = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return last_pos"}
{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(text):\n    \"\"\"\n    Check if a string has an 'a' followed by anything, ending in 'b'.\n\n    Args:\n        text (str): The string to be checked.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    Calculates the sum of all values in a given dictionary.\n\n    Args:\n        dictionary (dict): A dictionary containing key-value pairs.\n\n    Returns:\n        int: The sum of all values in the dictionary.\n\n    Raises:\n        TypeError: If the input is not a dictionary.\n\n    Examples:\n        >>> return_sum({'a': 100, 'b': 200, 'c': 300})\n        600\n        >>> return_sum({'x': 1, 'y': 2, 'z': 3})\n        6\n        >>> return_sum({})\n        0\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        raise TypeError(\"Input must be a dictionary.\")\n\n    return sum(dictionary.values())"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    Calculates the sum of all odd natural numbers within the given range (l, r).\n\n    Parameters:\n    l (int): The lower bound of the range (inclusive).\n    r (int): The upper bound of the range (inclusive).\n\n    Returns:\n    int: The sum of all odd natural numbers within the given range.\n\n    Raises:\n    ValueError: If l is greater than r or either l or r is negative.\n\n    Examples:\n    >>> sum_in_range(2, 5)\n    8\n    >>> sum_in_range(1, 10)\n    25\n    >>> sum_in_range(10, 1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Lower bound must be less than or equal to upper bound.\n    >>> sum_in_range(-1, 5)\n    Traceback (most recent call last):\n    ...\n    ValueError: Lower bound must be a non-negative integer.\n    >>> sum_in_range(2, -5)\n    Traceback (most recent call last):\n    ...\n    ValueError: Upper bound must be a non-negative integer.\n    \"\"\"\n\n    if l > r:\n        raise ValueError(\"Lower bound must be less than or equal to upper bound.\")\n    if l < 0 or r < 0:\n        if l < 0:\n            raise ValueError(\"Lower bound must be a non-negative integer.\")\n        else:\n            raise ValueError(\"Upper bound must be a non-negative integer.\")\n\n    odd_sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            odd_sum += num\n\n    return odd_sum"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"\n    Calculates the sum of an array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The sum of the array.\n\n    Raises:\n    TypeError: If the input is not a list.\n    ValueError: If the input list is empty.\n\n    Examples:\n    >>> _sum([1, 2, 3])\n    6\n    >>> _sum([-1, 0, 1])\n    0\n    >>> _sum([])\n    ValueError: Input list is empty.\n    >>> _sum(1)\n    TypeError: Input must be a list.\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if len(arr) == 0:\n        raise ValueError(\"Input list is empty.\")\n\n    return sum(arr)"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(num, d):\n    \"\"\"\n    Rotate the bits of a given number to the left by d positions.\n\n    Args:\n        num (int): The number to be rotated.\n        d (int): The number of positions to rotate the bits.\n\n    Returns:\n        int: The rotated number.\n\n    Raises:\n        ValueError: If the number is not a 32-bit integer.\n\n    Examples:\n        >>> left_rotate(16, 2)\n        64\n        >>> left_rotate(10, 3)\n        160\n    \"\"\"\n    if not isinstance(num, int) or num.bit_length() > 32:\n        raise ValueError(\"Number must be a 32-bit integer.\")\n\n    # Shift the bits to the left by d positions\n    rotated_num = (num << d) | (num >> (32 - d))\n\n    return rotated_num"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(string):\n    \"\"\"\n    Removes all whitespaces from a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        str: The string with all whitespaces removed.\n\n    Examples:\n        >>> remove_all_spaces('python  program')\n        'pythonprogram'\n        >>> remove_all_spaces('  hello   world  ')\n        'helloworld'\n    \"\"\"\n    return string.replace(\" \", \"\")"}
{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n        c (int): The third integer.\n\n    Returns:\n        int: The number of equal integers.\n\n    Raises:\n        TypeError: If any of the input arguments is not an integer.\n\n    Examples:\n        >>> test_three_equal(1, 1, 1)\n        3\n        >>> test_three_equal(1, 2, 3)\n        0\n        >>> test_three_equal(1, 1, 2)\n        2\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int) or not isinstance(c, int):\n        raise TypeError(\"All input arguments must be integers.\")\n\n    if a == b == c:\n        return 3\n    elif a == b or a == c or b == c:\n        return 2\n    else:\n        return 0"}
{"task_id": "Mbpp/803", "solution": "def is_perfect_square(num):\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n\n    # Using the property that a perfect square number can be written as the sum of odd numbers\n    # starting from 1, 3, 5, 7, ...\n    odd_num = 1\n    while num > 0:\n        num -= odd_num\n        odd_num += 2\n\n    return num == 0"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        bool: True if the product of numbers is even, False otherwise.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> is_product_even([1, 2, 3])\n        False\n        >>> is_product_even([2, 4, 6])\n        True\n        >>> is_product_even([])\n        Traceback (most recent call last):\n        ...\n        ValueError: Input list cannot be empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n\n    product = 1\n    for num in numbers:\n        product *= num\n\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lst):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: The list with the highest sum of elements.\n\n    Raises:\n        ValueError: If the input is not a list of lists.\n\n    Examples:\n        >>> max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]])\n        [10, 11, 12]\n        >>> max_sum_list([[1, 2, 3], [4, 5, 6]])\n        [1, 2, 3]\n        >>> max_sum_list([[1, 2, 3]])\n        [1, 2, 3]\n        >>> max_sum_list([])\n        []\n    \"\"\"\n    if not isinstance(lst, list) or not all(isinstance(sublist, list) for sublist in lst):\n        raise ValueError(\"Input must be a list of lists.\")\n\n    if not lst:\n        return []\n\n    max_sum = float('-inf')\n    max_list = []\n\n    for sublist in lst:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_list = sublist\n\n    return max_list"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(string):\n    \"\"\"\n    Finds the maximum run of uppercase characters in a given string.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The length of the maximum run of uppercase characters.\n\n    Examples:\n        >>> max_run_uppercase('GeMKSForGERksISBESt')\n        5\n        >>> max_run_uppercase('abcdefg')\n        0\n        >>> max_run_uppercase('ABCDEFG')\n        7\n    \"\"\"\n    max_run = 0\n    current_run = 0\n\n    for char in string:\n        if char.isupper():\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_run = 0\n\n    return max(max_run, current_run)"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    \"\"\"\n    Find the first odd number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The first odd number found in the list.\n\n    Raises:\n        ValueError: If no odd number is found in the list.\n\n    Examples:\n        >>> first_odd([1, 3, 5])\n        1\n        >>> first_odd([2, 4, 6])\n        ValueError: No odd number found in the list.\n    \"\"\"\n    for number in numbers:\n        if number % 2 != 0:\n            return number\n    raise ValueError(\"No odd number found in the list.\")"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuples contain the k.\n\n    Args:\n        tup (tuple): The input tuple to be checked.\n        k: The value to be searched in the tuple.\n\n    Returns:\n        bool: True if the tuple contains the k, False otherwise.\n    \"\"\"\n    return k in tup"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    Check if each element of the second tuple is smaller than its corresponding element in the first tuple.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        bool: True if each element of the second tuple is smaller than its corresponding element in the first tuple,\n              False otherwise.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        return False\n\n    for i in range(len(tuple1)):\n        if tuple1[i] >= tuple2[i]:\n            return False\n\n    return True"}
